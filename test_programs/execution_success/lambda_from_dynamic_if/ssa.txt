After Initial SSA:
acir(inline) fn main f0 {
  b0(v0: u32):
    v2 = sub v0, u32 1
    v4 = call f2(v2) -> u32
    call f1(v4)
    return
}
acir(inline) fn println f1 {
  b0(v0: u32):
    call f6(u1 1, v0)
    return
}
acir(inline) fn lambdas_with_input_and_return_values f2 {
  b0(v0: u32):
    v4 = eq v0, u32 0
    jmpif v4 then: b1, else: b2
  b1():
    jmp b3(f3)
  b2():
    v6 = eq v0, u32 1
    jmpif v6 then: b4, else: b5
  b3(v1: function):
    v10 = call v1(v0) -> u32
    return v10
  b4():
    jmp b6(f4)
  b5():
    jmp b6(f5)
  b6(v2: function):
    jmp b3(v2)
}
acir(inline) fn lambda f3 {
  b0(v0: u32):
    return v0
}
acir(inline) fn lambda f4 {
  b0(v0: u32):
    v2 = add v0, u32 1
    return v2
}
acir(inline) fn lambda f5 {
  b0(v0: u32):
    v2 = add v0, u32 2
    return v2
}
brillig(inline) fn print_unconstrained f6 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Removing Unreachable Functions (1):
acir(inline) fn main f0 {
  b0(v0: u32):
    v2 = sub v0, u32 1
    v4 = call f2(v2) -> u32
    call f1(v4)
    return
}
acir(inline) fn println f1 {
  b0(v0: u32):
    call f6(u1 1, v0)
    return
}
acir(inline) fn lambdas_with_input_and_return_values f2 {
  b0(v0: u32):
    v4 = eq v0, u32 0
    jmpif v4 then: b1, else: b2
  b1():
    jmp b3(f3)
  b2():
    v6 = eq v0, u32 1
    jmpif v6 then: b4, else: b5
  b3(v1: function):
    v10 = call v1(v0) -> u32
    return v10
  b4():
    jmp b6(f4)
  b5():
    jmp b6(f5)
  b6(v2: function):
    jmp b3(v2)
}
acir(inline) fn lambda f3 {
  b0(v0: u32):
    return v0
}
acir(inline) fn lambda f4 {
  b0(v0: u32):
    v2 = add v0, u32 1
    return v2
}
acir(inline) fn lambda f5 {
  b0(v0: u32):
    v2 = add v0, u32 2
    return v2
}
brillig(inline) fn print_unconstrained f6 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Defunctionalization (1):
acir(inline) fn main f0 {
  b0(v0: u32):
    v2 = sub v0, u32 1
    v4 = call f2(v2) -> u32
    call f1(v4)
    return
}
acir(inline) fn println f1 {
  b0(v0: u32):
    call f6(u1 1, v0)
    return
}
acir(inline) fn lambdas_with_input_and_return_values f2 {
  b0(v0: u32):
    v4 = eq v0, u32 0
    jmpif v4 then: b1, else: b2
  b1():
    jmp b3(Field 3)
  b2():
    v6 = eq v0, u32 1
    jmpif v6 then: b4, else: b5
  b3(v1: Field):
    v11 = call f7(v1, v0) -> u32
    return v11
  b4():
    jmp b6(Field 4)
  b5():
    jmp b6(Field 5)
  b6(v2: Field):
    jmp b3(v2)
}
acir(inline) fn lambda f3 {
  b0(v0: u32):
    return v0
}
acir(inline) fn lambda f4 {
  b0(v0: u32):
    v2 = add v0, u32 1
    return v2
}
acir(inline) fn lambda f5 {
  b0(v0: u32):
    v2 = add v0, u32 2
    return v2
}
brillig(inline) fn print_unconstrained f6 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}
acir(inline_always) fn apply f7 {
  b0(v0: Field, v1: u32):
    v9 = eq v0, Field 3
    jmpif v9 then: b3, else: b2
  b1(v2: u32):
    return v2
  b2():
    v13 = eq v0, Field 4
    jmpif v13 then: b6, else: b5
  b3():
    v11 = call f3(v1) -> u32
    jmp b4(v11)
  b4(v3: u32):
    jmp b10(v3)
  b5():
    constrain v0 == Field 5
    v18 = call f5(v1) -> u32
    jmp b8(v18)
  b6():
    v15 = call f4(v1) -> u32
    jmp b7(v15)
  b7(v4: u32):
    jmp b9(v4)
  b8(v5: u32):
    jmp b9(v5)
  b9(v6: u32):
    jmp b10(v6)
  b10(v7: u32):
    jmp b1(v7)
}

After Inlining simple functions (1):
acir(inline) fn main f0 {
  b0(v0: u32):
    v2 = sub v0, u32 1
    v4 = call f2(v2) -> u32
    call f6(u1 1, v4)
    return
}
acir(inline) fn println f1 {
  b0(v0: u32):
    call f6(u1 1, v0)
    return
}
acir(inline) fn lambdas_with_input_and_return_values f2 {
  b0(v0: u32):
    v4 = eq v0, u32 0
    jmpif v4 then: b1, else: b2
  b1():
    jmp b3(Field 3)
  b2():
    v6 = eq v0, u32 1
    jmpif v6 then: b4, else: b5
  b3(v1: Field):
    v11 = call f7(v1, v0) -> u32
    return v11
  b4():
    jmp b6(Field 4)
  b5():
    jmp b6(Field 5)
  b6(v2: Field):
    jmp b3(v2)
}
acir(inline) fn lambda f3 {
  b0(v0: u32):
    return v0
}
acir(inline) fn lambda f4 {
  b0(v0: u32):
    v2 = add v0, u32 1
    return v2
}
acir(inline) fn lambda f5 {
  b0(v0: u32):
    v2 = add v0, u32 2
    return v2
}
brillig(inline) fn print_unconstrained f6 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}
acir(inline_always) fn apply f7 {
  b0(v0: Field, v1: u32):
    v9 = eq v0, Field 3
    jmpif v9 then: b1, else: b2
  b1():
    jmp b3(v1)
  b2():
    v11 = eq v0, Field 4
    jmpif v11 then: b4, else: b5
  b3(v2: u32):
    jmp b6(v2)
  b4():
    v16 = add v1, u32 1
    jmp b7(v16)
  b5():
    constrain v0 == Field 5
    v14 = add v1, u32 2
    jmp b8(v14)
  b6(v3: u32):
    jmp b9(v3)
  b7(v4: u32):
    jmp b10(v4)
  b8(v5: u32):
    jmp b10(v5)
  b9(v6: u32):
    return v6
  b10(v7: u32):
    jmp b6(v7)
}

After Removing Paired rc_inc & rc_decs (1):
acir(inline) fn main f0 {
  b0(v0: u32):
    v2 = sub v0, u32 1
    v4 = call f2(v2) -> u32
    call f6(u1 1, v4)
    return
}
acir(inline) fn println f1 {
  b0(v0: u32):
    call f6(u1 1, v0)
    return
}
acir(inline) fn lambdas_with_input_and_return_values f2 {
  b0(v0: u32):
    v4 = eq v0, u32 0
    jmpif v4 then: b1, else: b2
  b1():
    jmp b3(Field 3)
  b2():
    v6 = eq v0, u32 1
    jmpif v6 then: b4, else: b5
  b3(v1: Field):
    v11 = call f7(v1, v0) -> u32
    return v11
  b4():
    jmp b6(Field 4)
  b5():
    jmp b6(Field 5)
  b6(v2: Field):
    jmp b3(v2)
}
acir(inline) fn lambda f3 {
  b0(v0: u32):
    return v0
}
acir(inline) fn lambda f4 {
  b0(v0: u32):
    v2 = add v0, u32 1
    return v2
}
acir(inline) fn lambda f5 {
  b0(v0: u32):
    v2 = add v0, u32 2
    return v2
}
brillig(inline) fn print_unconstrained f6 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}
acir(inline_always) fn apply f7 {
  b0(v0: Field, v1: u32):
    v9 = eq v0, Field 3
    jmpif v9 then: b1, else: b2
  b1():
    jmp b3(v1)
  b2():
    v11 = eq v0, Field 4
    jmpif v11 then: b4, else: b5
  b3(v2: u32):
    jmp b6(v2)
  b4():
    v16 = add v1, u32 1
    jmp b7(v16)
  b5():
    constrain v0 == Field 5
    v14 = add v1, u32 2
    jmp b8(v14)
  b6(v3: u32):
    jmp b9(v3)
  b7(v4: u32):
    jmp b10(v4)
  b8(v5: u32):
    jmp b10(v5)
  b9(v6: u32):
    return v6
  b10(v7: u32):
    jmp b6(v7)
}

After Preprocessing Functions (1):
acir(inline) fn main f0 {
  b0(v0: u32):
    v2 = sub v0, u32 1
    v4 = call f1(v2) -> u32
    call f2(u1 1, v4)
    return
}
acir(inline) fn lambdas_with_input_and_return_values f1 {
  b0(v0: u32):
    v6 = eq v0, u32 0
    jmpif v6 then: b1, else: b2
  b1():
    jmp b3(Field 3)
  b2():
    v8 = eq v0, u32 1
    jmpif v8 then: b4, else: b5
  b3(v1: Field):
    v12 = eq v1, Field 3
    jmpif v12 then: b6, else: b7
  b4():
    jmp b12(Field 4)
  b5():
    jmp b12(Field 5)
  b6():
    jmp b8(v0)
  b7():
    v13 = eq v1, Field 4
    jmpif v13 then: b9, else: b10
  b8(v2: u32):
    return v2
  b9():
    v16 = add v0, u32 1
    jmp b11(v16)
  b10():
    constrain v1 == Field 5
    v15 = add v0, u32 2
    jmp b11(v15)
  b11(v3: u32):
    jmp b8(v3)
  b12(v4: Field):
    jmp b3(v4)
}
brillig(inline) fn print_unconstrained f2 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Inlining (1):
acir(inline) fn main f0 {
  b0(v0: u32):
    v6 = sub v0, u32 1
    v8 = eq v6, u32 0
    jmpif v8 then: b1, else: b2
  b1():
    jmp b3(Field 3)
  b2():
    v9 = eq v6, u32 1
    jmpif v9 then: b4, else: b5
  b3(v1: Field):
    v13 = eq v1, Field 3
    jmpif v13 then: b6, else: b7
  b4():
    jmp b8(Field 4)
  b5():
    jmp b8(Field 5)
  b6():
    jmp b9(v6)
  b7():
    v14 = eq v1, Field 4
    jmpif v14 then: b10, else: b11
  b8(v2: Field):
    jmp b3(v2)
  b9(v3: u32):
    call f1(u1 1, v3)
    return
  b10():
    v17 = add v6, u32 1
    jmp b12(v17)
  b11():
    constrain v1 == Field 5
    v16 = add v6, u32 2
    jmp b12(v16)
  b12(v4: u32):
    jmp b9(v4)
}
brillig(inline) fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Mem2Reg (1):
acir(inline) fn main f0 {
  b0(v0: u32):
    v6 = sub v0, u32 1
    v8 = eq v6, u32 0
    jmpif v8 then: b1, else: b2
  b1():
    jmp b3(Field 3)
  b2():
    v9 = eq v6, u32 1
    jmpif v9 then: b4, else: b5
  b3(v1: Field):
    v13 = eq v1, Field 3
    jmpif v13 then: b6, else: b7
  b4():
    jmp b8(Field 4)
  b5():
    jmp b8(Field 5)
  b6():
    jmp b9(v6)
  b7():
    v14 = eq v1, Field 4
    jmpif v14 then: b10, else: b11
  b8(v2: Field):
    jmp b3(v2)
  b9(v3: u32):
    call f1(u1 1, v3)
    return
  b10():
    v17 = add v6, u32 1
    jmp b12(v17)
  b11():
    constrain v1 == Field 5
    v16 = add v6, u32 2
    jmp b12(v16)
  b12(v4: u32):
    jmp b9(v4)
}
brillig(inline) fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Simplifying (1):
acir(inline) fn main f0 {
  b0(v0: u32):
    v6 = sub v0, u32 1
    v8 = eq v6, u32 0
    jmpif v8 then: b1, else: b2
  b1():
    jmp b3(Field 3)
  b2():
    v9 = eq v6, u32 1
    jmpif v9 then: b4, else: b5
  b3(v1: Field):
    v13 = eq v1, Field 3
    jmpif v13 then: b6, else: b7
  b4():
    jmp b8(Field 4)
  b5():
    jmp b8(Field 5)
  b6():
    jmp b9(v6)
  b7():
    v14 = eq v1, Field 4
    jmpif v14 then: b10, else: b11
  b8(v2: Field):
    jmp b3(v2)
  b9(v3: u32):
    call f1(u1 1, v3)
    return
  b10():
    v17 = add v6, u32 1
    jmp b12(v17)
  b11():
    constrain v1 == Field 5
    v16 = add v6, u32 2
    jmp b12(v16)
  b12(v4: u32):
    jmp b9(v4)
}
brillig(inline) fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After `as_slice` optimization (1):
acir(inline) fn main f0 {
  b0(v0: u32):
    v6 = sub v0, u32 1
    v8 = eq v6, u32 0
    jmpif v8 then: b1, else: b2
  b1():
    jmp b3(Field 3)
  b2():
    v9 = eq v6, u32 1
    jmpif v9 then: b4, else: b5
  b3(v1: Field):
    v13 = eq v1, Field 3
    jmpif v13 then: b6, else: b7
  b4():
    jmp b8(Field 4)
  b5():
    jmp b8(Field 5)
  b6():
    jmp b9(v6)
  b7():
    v14 = eq v1, Field 4
    jmpif v14 then: b10, else: b11
  b8(v2: Field):
    jmp b3(v2)
  b9(v3: u32):
    call f1(u1 1, v3)
    return
  b10():
    v17 = add v6, u32 1
    jmp b12(v17)
  b11():
    constrain v1 == Field 5
    v16 = add v6, u32 2
    jmp b12(v16)
  b12(v4: u32):
    jmp b9(v4)
}
brillig(inline) fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Removing Unreachable Functions (2):
acir(inline) fn main f0 {
  b0(v0: u32):
    v6 = sub v0, u32 1
    v8 = eq v6, u32 0
    jmpif v8 then: b1, else: b2
  b1():
    jmp b3(Field 3)
  b2():
    v9 = eq v6, u32 1
    jmpif v9 then: b4, else: b5
  b3(v1: Field):
    v13 = eq v1, Field 3
    jmpif v13 then: b6, else: b7
  b4():
    jmp b8(Field 4)
  b5():
    jmp b8(Field 5)
  b6():
    jmp b9(v6)
  b7():
    v14 = eq v1, Field 4
    jmpif v14 then: b10, else: b11
  b8(v2: Field):
    jmp b3(v2)
  b9(v3: u32):
    call f1(u1 1, v3)
    return
  b10():
    v17 = add v6, u32 1
    jmp b12(v17)
  b11():
    constrain v1 == Field 5
    v16 = add v6, u32 2
    jmp b12(v16)
  b12(v4: u32):
    jmp b9(v4)
}
brillig(inline) fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After `static_assert` and `assert_constant` (1):
acir(inline) fn main f0 {
  b0(v0: u32):
    v6 = sub v0, u32 1
    v8 = eq v6, u32 0
    jmpif v8 then: b1, else: b2
  b1():
    jmp b3(Field 3)
  b2():
    v9 = eq v6, u32 1
    jmpif v9 then: b4, else: b5
  b3(v1: Field):
    v13 = eq v1, Field 3
    jmpif v13 then: b6, else: b7
  b4():
    jmp b8(Field 4)
  b5():
    jmp b8(Field 5)
  b6():
    jmp b9(v6)
  b7():
    v14 = eq v1, Field 4
    jmpif v14 then: b10, else: b11
  b8(v2: Field):
    jmp b3(v2)
  b9(v3: u32):
    call f1(u1 1, v3)
    return
  b10():
    v17 = add v6, u32 1
    jmp b12(v17)
  b11():
    constrain v1 == Field 5
    v16 = add v6, u32 2
    jmp b12(v16)
  b12(v4: u32):
    jmp b9(v4)
}
brillig(inline) fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Purity Analysis (1):
acir(inline) impure fn main f0 {
  b0(v0: u32):
    v6 = sub v0, u32 1
    v8 = eq v6, u32 0
    jmpif v8 then: b1, else: b2
  b1():
    jmp b3(Field 3)
  b2():
    v9 = eq v6, u32 1
    jmpif v9 then: b4, else: b5
  b3(v1: Field):
    v13 = eq v1, Field 3
    jmpif v13 then: b6, else: b7
  b4():
    jmp b8(Field 4)
  b5():
    jmp b8(Field 5)
  b6():
    jmp b9(v6)
  b7():
    v14 = eq v1, Field 4
    jmpif v14 then: b10, else: b11
  b8(v2: Field):
    jmp b3(v2)
  b9(v3: u32):
    call f1(u1 1, v3)
    return
  b10():
    v17 = add v6, u32 1
    jmp b12(v17)
  b11():
    constrain v1 == Field 5
    v16 = add v6, u32 2
    jmp b12(v16)
  b12(v4: u32):
    jmp b9(v4)
}
brillig(inline) impure fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Loop Invariant Code Motion (1):
acir(inline) impure fn main f0 {
  b0(v0: u32):
    v6 = sub v0, u32 1
    v8 = eq v6, u32 0
    jmpif v8 then: b1, else: b2
  b1():
    jmp b3(Field 3)
  b2():
    v9 = eq v6, u32 1
    jmpif v9 then: b4, else: b5
  b3(v1: Field):
    v13 = eq v1, Field 3
    jmpif v13 then: b6, else: b7
  b4():
    jmp b8(Field 4)
  b5():
    jmp b8(Field 5)
  b6():
    jmp b9(v6)
  b7():
    v14 = eq v1, Field 4
    jmpif v14 then: b10, else: b11
  b8(v2: Field):
    jmp b3(v2)
  b9(v3: u32):
    call f1(u1 1, v3)
    return
  b10():
    v17 = add v6, u32 1
    jmp b12(v17)
  b11():
    constrain v1 == Field 5
    v16 = add v6, u32 2
    jmp b12(v16)
  b12(v4: u32):
    jmp b9(v4)
}
brillig(inline) impure fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Unrolling (1):
acir(inline) impure fn main f0 {
  b0(v0: u32):
    v6 = sub v0, u32 1
    v8 = eq v6, u32 0
    jmpif v8 then: b1, else: b2
  b1():
    jmp b3(Field 3)
  b2():
    v9 = eq v6, u32 1
    jmpif v9 then: b4, else: b5
  b3(v1: Field):
    v13 = eq v1, Field 3
    jmpif v13 then: b6, else: b7
  b4():
    jmp b8(Field 4)
  b5():
    jmp b8(Field 5)
  b6():
    jmp b9(v6)
  b7():
    v14 = eq v1, Field 4
    jmpif v14 then: b10, else: b11
  b8(v2: Field):
    jmp b3(v2)
  b9(v3: u32):
    call f1(u1 1, v3)
    return
  b10():
    v17 = add v6, u32 1
    jmp b12(v17)
  b11():
    constrain v1 == Field 5
    v16 = add v6, u32 2
    jmp b12(v16)
  b12(v4: u32):
    jmp b9(v4)
}
brillig(inline) impure fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Simplifying (2):
acir(inline) impure fn main f0 {
  b0(v0: u32):
    v6 = sub v0, u32 1
    v8 = eq v6, u32 0
    jmpif v8 then: b1, else: b2
  b1():
    jmp b3(Field 3)
  b2():
    v9 = eq v6, u32 1
    jmpif v9 then: b4, else: b5
  b3(v1: Field):
    v13 = eq v1, Field 3
    jmpif v13 then: b6, else: b7
  b4():
    jmp b8(Field 4)
  b5():
    jmp b8(Field 5)
  b6():
    jmp b9(v6)
  b7():
    v14 = eq v1, Field 4
    jmpif v14 then: b10, else: b11
  b8(v2: Field):
    jmp b3(v2)
  b9(v3: u32):
    call f1(u1 1, v3)
    return
  b10():
    v17 = add v6, u32 1
    jmp b12(v17)
  b11():
    constrain v1 == Field 5
    v16 = add v6, u32 2
    jmp b12(v16)
  b12(v4: u32):
    jmp b9(v4)
}
brillig(inline) impure fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Mem2Reg (2):
acir(inline) impure fn main f0 {
  b0(v0: u32):
    v6 = sub v0, u32 1
    v8 = eq v6, u32 0
    jmpif v8 then: b1, else: b2
  b1():
    jmp b3(Field 3)
  b2():
    v9 = eq v6, u32 1
    jmpif v9 then: b4, else: b5
  b3(v1: Field):
    v13 = eq v1, Field 3
    jmpif v13 then: b6, else: b7
  b4():
    jmp b8(Field 4)
  b5():
    jmp b8(Field 5)
  b6():
    jmp b9(v6)
  b7():
    v14 = eq v1, Field 4
    jmpif v14 then: b10, else: b11
  b8(v2: Field):
    jmp b3(v2)
  b9(v3: u32):
    call f1(u1 1, v3)
    return
  b10():
    v17 = add v6, u32 1
    jmp b12(v17)
  b11():
    constrain v1 == Field 5
    v16 = add v6, u32 2
    jmp b12(v16)
  b12(v4: u32):
    jmp b9(v4)
}
brillig(inline) impure fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Flattening (1):
acir(inline) impure fn main f0 {
  b0(v0: u32):
    v2 = sub v0, u32 1
    v4 = eq v2, u32 0
    enable_side_effects v4
    v5 = not v4
    enable_side_effects v5
    v6 = eq v2, u32 1
    v7 = unchecked_mul v5, v6
    enable_side_effects v7
    v8 = not v6
    v9 = unchecked_mul v5, v8
    enable_side_effects v5
    v10 = cast v7 as Field
    v11 = cast v9 as Field
    v13 = mul v10, Field 4
    v15 = mul v11, Field 5
    v16 = add v13, v15
    enable_side_effects u1 1
    v18 = cast v4 as Field
    v19 = cast v5 as Field
    v21 = mul v18, Field 3
    v22 = mul v19, v16
    v23 = add v21, v22
    v24 = eq v23, Field 3
    enable_side_effects v24
    v25 = not v24
    enable_side_effects v25
    v26 = eq v23, Field 4
    v27 = unchecked_mul v25, v26
    enable_side_effects v27
    v28 = add v2, u32 1
    v29 = not v26
    v30 = unchecked_mul v25, v29
    enable_side_effects v30
    v31 = cast v30 as Field
    v32 = cast v30 as Field
    v33 = mul v23, v32
    v34 = cast v30 as Field
    v35 = mul Field 5, v34
    constrain v33 == v35
    v37 = add v2, u32 2
    enable_side_effects v25
    v38 = cast v27 as u32
    v39 = cast v30 as u32
    v40 = unchecked_mul v38, v28
    v41 = unchecked_mul v39, v37
    v42 = unchecked_add v40, v41
    enable_side_effects u1 1
    v43 = cast v24 as u32
    v44 = cast v25 as u32
    v45 = unchecked_mul v43, v2
    v46 = unchecked_mul v44, v42
    v47 = unchecked_add v45, v46
    call f1(u1 1, v47)
    return
}
brillig(inline) impure fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Removing Bit Shifts (1):
acir(inline) impure fn main f0 {
  b0(v0: u32):
    v2 = sub v0, u32 1
    v4 = eq v2, u32 0
    enable_side_effects v4
    v5 = not v4
    enable_side_effects v5
    v6 = eq v2, u32 1
    v7 = unchecked_mul v5, v6
    enable_side_effects v7
    v8 = not v6
    v9 = unchecked_mul v5, v8
    enable_side_effects v5
    v10 = cast v7 as Field
    v11 = cast v9 as Field
    v13 = mul v10, Field 4
    v15 = mul v11, Field 5
    v16 = add v13, v15
    enable_side_effects u1 1
    v18 = cast v4 as Field
    v19 = cast v5 as Field
    v21 = mul v18, Field 3
    v22 = mul v19, v16
    v23 = add v21, v22
    v24 = eq v23, Field 3
    enable_side_effects v24
    v25 = not v24
    enable_side_effects v25
    v26 = eq v23, Field 4
    v27 = unchecked_mul v25, v26
    enable_side_effects v27
    v28 = add v2, u32 1
    v29 = not v26
    v30 = unchecked_mul v25, v29
    enable_side_effects v30
    v31 = cast v30 as Field
    v32 = cast v30 as Field
    v33 = mul v23, v32
    v34 = cast v30 as Field
    v35 = mul Field 5, v34
    constrain v33 == v35
    v37 = add v2, u32 2
    enable_side_effects v25
    v38 = cast v27 as u32
    v39 = cast v30 as u32
    v40 = unchecked_mul v38, v28
    v41 = unchecked_mul v39, v37
    v42 = unchecked_add v40, v41
    enable_side_effects u1 1
    v43 = cast v24 as u32
    v44 = cast v25 as u32
    v45 = unchecked_mul v43, v2
    v46 = unchecked_mul v44, v42
    v47 = unchecked_add v45, v46
    call f1(u1 1, v47)
    return
}
brillig(inline) impure fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Mem2Reg (3):
acir(inline) impure fn main f0 {
  b0(v0: u32):
    v2 = sub v0, u32 1
    v4 = eq v2, u32 0
    enable_side_effects v4
    v5 = not v4
    enable_side_effects v5
    v6 = eq v2, u32 1
    v7 = unchecked_mul v5, v6
    enable_side_effects v7
    v8 = not v6
    v9 = unchecked_mul v5, v8
    enable_side_effects v5
    v10 = cast v7 as Field
    v11 = cast v9 as Field
    v13 = mul v10, Field 4
    v15 = mul v11, Field 5
    v16 = add v13, v15
    enable_side_effects u1 1
    v18 = cast v4 as Field
    v19 = cast v5 as Field
    v21 = mul v18, Field 3
    v22 = mul v19, v16
    v23 = add v21, v22
    v24 = eq v23, Field 3
    enable_side_effects v24
    v25 = not v24
    enable_side_effects v25
    v26 = eq v23, Field 4
    v27 = unchecked_mul v25, v26
    enable_side_effects v27
    v28 = add v2, u32 1
    v29 = not v26
    v30 = unchecked_mul v25, v29
    enable_side_effects v30
    v31 = cast v30 as Field
    v32 = cast v30 as Field
    v33 = mul v23, v32
    v34 = cast v30 as Field
    v35 = mul Field 5, v34
    constrain v33 == v35
    v37 = add v2, u32 2
    enable_side_effects v25
    v38 = cast v27 as u32
    v39 = cast v30 as u32
    v40 = unchecked_mul v38, v28
    v41 = unchecked_mul v39, v37
    v42 = unchecked_add v40, v41
    enable_side_effects u1 1
    v43 = cast v24 as u32
    v44 = cast v25 as u32
    v45 = unchecked_mul v43, v2
    v46 = unchecked_mul v44, v42
    v47 = unchecked_add v45, v46
    call f1(u1 1, v47)
    return
}
brillig(inline) impure fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Inlining (2):
acir(inline) impure fn main f0 {
  b0(v0: u32):
    v2 = sub v0, u32 1
    v4 = eq v2, u32 0
    enable_side_effects v4
    v5 = not v4
    enable_side_effects v5
    v6 = eq v2, u32 1
    v7 = unchecked_mul v5, v6
    enable_side_effects v7
    v8 = not v6
    v9 = unchecked_mul v5, v8
    enable_side_effects v5
    v10 = cast v7 as Field
    v11 = cast v9 as Field
    v13 = mul v10, Field 4
    v15 = mul v11, Field 5
    v16 = add v13, v15
    enable_side_effects u1 1
    v18 = cast v4 as Field
    v19 = cast v5 as Field
    v21 = mul v18, Field 3
    v22 = mul v19, v16
    v23 = add v21, v22
    v24 = eq v23, Field 3
    enable_side_effects v24
    v25 = not v24
    enable_side_effects v25
    v26 = eq v23, Field 4
    v27 = unchecked_mul v25, v26
    enable_side_effects v27
    v28 = add v2, u32 1
    v29 = not v26
    v30 = unchecked_mul v25, v29
    enable_side_effects v30
    v31 = cast v30 as Field
    v32 = cast v30 as Field
    v33 = mul v23, v32
    v34 = cast v30 as Field
    v35 = mul Field 5, v34
    constrain v33 == v35
    v37 = add v2, u32 2
    enable_side_effects v25
    v38 = cast v27 as u32
    v39 = cast v30 as u32
    v40 = unchecked_mul v38, v28
    v41 = unchecked_mul v39, v37
    v42 = unchecked_add v40, v41
    enable_side_effects u1 1
    v43 = cast v24 as u32
    v44 = cast v25 as u32
    v45 = unchecked_mul v43, v2
    v46 = unchecked_mul v44, v42
    v47 = unchecked_add v45, v46
    call f1(u1 1, v47)
    return
}
brillig(inline) impure fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Remove IfElse (1):
acir(inline) impure fn main f0 {
  b0(v0: u32):
    v2 = sub v0, u32 1
    v4 = eq v2, u32 0
    enable_side_effects v4
    v5 = not v4
    enable_side_effects v5
    v6 = eq v2, u32 1
    v7 = unchecked_mul v5, v6
    enable_side_effects v7
    v8 = not v6
    v9 = unchecked_mul v5, v8
    enable_side_effects v5
    v10 = cast v7 as Field
    v11 = cast v9 as Field
    v13 = mul v10, Field 4
    v15 = mul v11, Field 5
    v16 = add v13, v15
    enable_side_effects u1 1
    v18 = cast v4 as Field
    v19 = cast v5 as Field
    v21 = mul v18, Field 3
    v22 = mul v19, v16
    v23 = add v21, v22
    v24 = eq v23, Field 3
    enable_side_effects v24
    v25 = not v24
    enable_side_effects v25
    v26 = eq v23, Field 4
    v27 = unchecked_mul v25, v26
    enable_side_effects v27
    v28 = add v2, u32 1
    v29 = not v26
    v30 = unchecked_mul v25, v29
    enable_side_effects v30
    v31 = cast v30 as Field
    v32 = cast v30 as Field
    v33 = mul v23, v32
    v34 = cast v30 as Field
    v35 = mul Field 5, v34
    constrain v33 == v35
    v37 = add v2, u32 2
    enable_side_effects v25
    v38 = cast v27 as u32
    v39 = cast v30 as u32
    v40 = unchecked_mul v38, v28
    v41 = unchecked_mul v39, v37
    v42 = unchecked_add v40, v41
    enable_side_effects u1 1
    v43 = cast v24 as u32
    v44 = cast v25 as u32
    v45 = unchecked_mul v43, v2
    v46 = unchecked_mul v44, v42
    v47 = unchecked_add v45, v46
    call f1(u1 1, v47)
    return
}
brillig(inline) impure fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Purity Analysis (2):
acir(inline) impure fn main f0 {
  b0(v0: u32):
    v2 = sub v0, u32 1
    v4 = eq v2, u32 0
    enable_side_effects v4
    v5 = not v4
    enable_side_effects v5
    v6 = eq v2, u32 1
    v7 = unchecked_mul v5, v6
    enable_side_effects v7
    v8 = not v6
    v9 = unchecked_mul v5, v8
    enable_side_effects v5
    v10 = cast v7 as Field
    v11 = cast v9 as Field
    v13 = mul v10, Field 4
    v15 = mul v11, Field 5
    v16 = add v13, v15
    enable_side_effects u1 1
    v18 = cast v4 as Field
    v19 = cast v5 as Field
    v21 = mul v18, Field 3
    v22 = mul v19, v16
    v23 = add v21, v22
    v24 = eq v23, Field 3
    enable_side_effects v24
    v25 = not v24
    enable_side_effects v25
    v26 = eq v23, Field 4
    v27 = unchecked_mul v25, v26
    enable_side_effects v27
    v28 = add v2, u32 1
    v29 = not v26
    v30 = unchecked_mul v25, v29
    enable_side_effects v30
    v31 = cast v30 as Field
    v32 = cast v30 as Field
    v33 = mul v23, v32
    v34 = cast v30 as Field
    v35 = mul Field 5, v34
    constrain v33 == v35
    v37 = add v2, u32 2
    enable_side_effects v25
    v38 = cast v27 as u32
    v39 = cast v30 as u32
    v40 = unchecked_mul v38, v28
    v41 = unchecked_mul v39, v37
    v42 = unchecked_add v40, v41
    enable_side_effects u1 1
    v43 = cast v24 as u32
    v44 = cast v25 as u32
    v45 = unchecked_mul v43, v2
    v46 = unchecked_mul v44, v42
    v47 = unchecked_add v45, v46
    call f1(u1 1, v47)
    return
}
brillig(inline) impure fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Constant Folding (1):
acir(inline) impure fn main f0 {
  b0(v0: u32):
    v2 = sub v0, u32 1
    v4 = eq v2, u32 0
    enable_side_effects v4
    v5 = not v4
    enable_side_effects v5
    v6 = eq v2, u32 1
    v7 = unchecked_mul v5, v6
    enable_side_effects v7
    v8 = not v6
    v9 = unchecked_mul v5, v8
    enable_side_effects v5
    v10 = cast v7 as Field
    v11 = cast v9 as Field
    v13 = mul v10, Field 4
    v15 = mul v11, Field 5
    v16 = add v13, v15
    enable_side_effects u1 1
    v18 = cast v4 as Field
    v19 = cast v5 as Field
    v21 = mul v18, Field 3
    v22 = mul v19, v16
    v23 = add v21, v22
    v24 = eq v23, Field 3
    enable_side_effects v24
    v25 = not v24
    enable_side_effects v25
    v26 = eq v23, Field 4
    v27 = unchecked_mul v25, v26
    enable_side_effects v27
    v28 = add v2, u32 1
    v29 = not v26
    v30 = unchecked_mul v25, v29
    enable_side_effects v30
    v31 = cast v30 as Field
    v32 = mul v23, v31
    v33 = mul Field 5, v31
    constrain v32 == v33
    v35 = add v2, u32 2
    enable_side_effects v25
    v36 = cast v27 as u32
    v37 = cast v30 as u32
    v38 = unchecked_mul v36, v28
    v39 = unchecked_mul v37, v35
    v40 = unchecked_add v38, v39
    enable_side_effects u1 1
    v41 = cast v24 as u32
    v42 = cast v25 as u32
    v43 = unchecked_mul v41, v2
    v44 = unchecked_mul v42, v40
    v45 = unchecked_add v43, v44
    call f1(u1 1, v45)
    return
}
brillig(inline) impure fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Simplify conditionals for unconstrained (1):
acir(inline) impure fn main f0 {
  b0(v0: u32):
    v2 = sub v0, u32 1
    v4 = eq v2, u32 0
    enable_side_effects v4
    v5 = not v4
    enable_side_effects v5
    v6 = eq v2, u32 1
    v7 = unchecked_mul v5, v6
    enable_side_effects v7
    v8 = not v6
    v9 = unchecked_mul v5, v8
    enable_side_effects v5
    v10 = cast v7 as Field
    v11 = cast v9 as Field
    v13 = mul v10, Field 4
    v15 = mul v11, Field 5
    v16 = add v13, v15
    enable_side_effects u1 1
    v18 = cast v4 as Field
    v19 = cast v5 as Field
    v21 = mul v18, Field 3
    v22 = mul v19, v16
    v23 = add v21, v22
    v24 = eq v23, Field 3
    enable_side_effects v24
    v25 = not v24
    enable_side_effects v25
    v26 = eq v23, Field 4
    v27 = unchecked_mul v25, v26
    enable_side_effects v27
    v28 = add v2, u32 1
    v29 = not v26
    v30 = unchecked_mul v25, v29
    enable_side_effects v30
    v31 = cast v30 as Field
    v32 = mul v23, v31
    v33 = mul Field 5, v31
    constrain v32 == v33
    v35 = add v2, u32 2
    enable_side_effects v25
    v36 = cast v27 as u32
    v37 = cast v30 as u32
    v38 = unchecked_mul v36, v28
    v39 = unchecked_mul v37, v35
    v40 = unchecked_add v38, v39
    enable_side_effects u1 1
    v41 = cast v24 as u32
    v42 = cast v25 as u32
    v43 = unchecked_mul v41, v2
    v44 = unchecked_mul v42, v40
    v45 = unchecked_add v43, v44
    call f1(u1 1, v45)
    return
}
brillig(inline) impure fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After EnableSideEffectsIf removal (1):
acir(inline) impure fn main f0 {
  b0(v0: u32):
    v2 = sub v0, u32 1
    v4 = eq v2, u32 0
    v5 = not v4
    v6 = eq v2, u32 1
    v7 = unchecked_mul v5, v6
    v8 = not v6
    v9 = unchecked_mul v5, v8
    v10 = cast v7 as Field
    v11 = cast v9 as Field
    v13 = mul v10, Field 4
    v15 = mul v11, Field 5
    v16 = add v13, v15
    enable_side_effects u1 1
    v18 = cast v4 as Field
    v19 = cast v5 as Field
    v21 = mul v18, Field 3
    v22 = mul v19, v16
    v23 = add v21, v22
    v24 = eq v23, Field 3
    v25 = not v24
    v26 = eq v23, Field 4
    v27 = unchecked_mul v25, v26
    enable_side_effects v27
    v28 = add v2, u32 1
    v29 = not v26
    v30 = unchecked_mul v25, v29
    v31 = cast v30 as Field
    v32 = mul v23, v31
    v33 = mul Field 5, v31
    constrain v32 == v33
    enable_side_effects v30
    v35 = add v2, u32 2
    v36 = cast v27 as u32
    v37 = cast v30 as u32
    v38 = unchecked_mul v36, v28
    v39 = unchecked_mul v37, v35
    v40 = unchecked_add v38, v39
    enable_side_effects u1 1
    v41 = cast v24 as u32
    v42 = cast v25 as u32
    v43 = unchecked_mul v41, v2
    v44 = unchecked_mul v42, v40
    v45 = unchecked_add v43, v44
    call f1(u1 1, v45)
    return
}
brillig(inline) impure fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Constraint Folding (1):
acir(inline) impure fn main f0 {
  b0(v0: u32):
    v2 = sub v0, u32 1
    v4 = eq v2, u32 0
    v5 = not v4
    v6 = eq v2, u32 1
    v7 = unchecked_mul v5, v6
    v8 = not v6
    v9 = unchecked_mul v5, v8
    v10 = cast v7 as Field
    v11 = cast v9 as Field
    v13 = mul v10, Field 4
    v15 = mul v11, Field 5
    v16 = add v13, v15
    enable_side_effects u1 1
    v18 = cast v4 as Field
    v19 = cast v5 as Field
    v21 = mul v18, Field 3
    v22 = mul v19, v16
    v23 = add v21, v22
    v24 = eq v23, Field 3
    v25 = not v24
    v26 = eq v23, Field 4
    v27 = unchecked_mul v25, v26
    enable_side_effects v27
    v28 = add v2, u32 1
    v29 = not v26
    v30 = unchecked_mul v25, v29
    v31 = cast v30 as Field
    v32 = mul v23, v31
    v33 = mul Field 5, v31
    constrain v32 == v33
    enable_side_effects v30
    v35 = add v2, u32 2
    v36 = cast v27 as u32
    v37 = cast v30 as u32
    v38 = unchecked_mul v36, v28
    v39 = unchecked_mul v37, v35
    v40 = unchecked_add v38, v39
    enable_side_effects u1 1
    v41 = cast v24 as u32
    v42 = cast v25 as u32
    v43 = unchecked_mul v41, v2
    v44 = unchecked_mul v42, v40
    v45 = unchecked_add v43, v44
    call f1(u1 1, v45)
    return
}
brillig(inline) impure fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Unrolling (2):
acir(inline) impure fn main f0 {
  b0(v0: u32):
    v2 = sub v0, u32 1
    v4 = eq v2, u32 0
    v5 = not v4
    v6 = eq v2, u32 1
    v7 = unchecked_mul v5, v6
    v8 = not v6
    v9 = unchecked_mul v5, v8
    v10 = cast v7 as Field
    v11 = cast v9 as Field
    v13 = mul v10, Field 4
    v15 = mul v11, Field 5
    v16 = add v13, v15
    enable_side_effects u1 1
    v18 = cast v4 as Field
    v19 = cast v5 as Field
    v21 = mul v18, Field 3
    v22 = mul v19, v16
    v23 = add v21, v22
    v24 = eq v23, Field 3
    v25 = not v24
    v26 = eq v23, Field 4
    v27 = unchecked_mul v25, v26
    enable_side_effects v27
    v28 = add v2, u32 1
    v29 = not v26
    v30 = unchecked_mul v25, v29
    v31 = cast v30 as Field
    v32 = mul v23, v31
    v33 = mul Field 5, v31
    constrain v32 == v33
    enable_side_effects v30
    v35 = add v2, u32 2
    v36 = cast v27 as u32
    v37 = cast v30 as u32
    v38 = unchecked_mul v36, v28
    v39 = unchecked_mul v37, v35
    v40 = unchecked_add v38, v39
    enable_side_effects u1 1
    v41 = cast v24 as u32
    v42 = cast v25 as u32
    v43 = unchecked_mul v41, v2
    v44 = unchecked_mul v42, v40
    v45 = unchecked_add v43, v44
    call f1(u1 1, v45)
    return
}
brillig(inline) impure fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Adding constrain not equal (1):
acir(inline) impure fn main f0 {
  b0(v0: u32):
    v2 = sub v0, u32 1
    v4 = eq v2, u32 0
    v5 = not v4
    v6 = eq v2, u32 1
    v7 = unchecked_mul v5, v6
    v8 = not v6
    v9 = unchecked_mul v5, v8
    v10 = cast v7 as Field
    v11 = cast v9 as Field
    v13 = mul v10, Field 4
    v15 = mul v11, Field 5
    v16 = add v13, v15
    enable_side_effects u1 1
    v18 = cast v4 as Field
    v19 = cast v5 as Field
    v21 = mul v18, Field 3
    v22 = mul v19, v16
    v23 = add v21, v22
    v24 = eq v23, Field 3
    v25 = not v24
    v26 = eq v23, Field 4
    v27 = unchecked_mul v25, v26
    enable_side_effects v27
    v28 = add v2, u32 1
    v29 = not v26
    v30 = unchecked_mul v25, v29
    v31 = cast v30 as Field
    v32 = mul v23, v31
    v33 = mul Field 5, v31
    constrain v32 == v33
    enable_side_effects v30
    v35 = add v2, u32 2
    v36 = cast v27 as u32
    v37 = cast v30 as u32
    v38 = unchecked_mul v36, v28
    v39 = unchecked_mul v37, v35
    v40 = unchecked_add v38, v39
    enable_side_effects u1 1
    v41 = cast v24 as u32
    v42 = cast v25 as u32
    v43 = unchecked_mul v41, v2
    v44 = unchecked_mul v42, v40
    v45 = unchecked_add v43, v44
    call f1(u1 1, v45)
    return
}
brillig(inline) impure fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Check u128 mul overflow (1):
acir(inline) impure fn main f0 {
  b0(v0: u32):
    v2 = sub v0, u32 1
    v4 = eq v2, u32 0
    v5 = not v4
    v6 = eq v2, u32 1
    v7 = unchecked_mul v5, v6
    v8 = not v6
    v9 = unchecked_mul v5, v8
    v10 = cast v7 as Field
    v11 = cast v9 as Field
    v13 = mul v10, Field 4
    v15 = mul v11, Field 5
    v16 = add v13, v15
    enable_side_effects u1 1
    v18 = cast v4 as Field
    v19 = cast v5 as Field
    v21 = mul v18, Field 3
    v22 = mul v19, v16
    v23 = add v21, v22
    v24 = eq v23, Field 3
    v25 = not v24
    v26 = eq v23, Field 4
    v27 = unchecked_mul v25, v26
    enable_side_effects v27
    v28 = add v2, u32 1
    v29 = not v26
    v30 = unchecked_mul v25, v29
    v31 = cast v30 as Field
    v32 = mul v23, v31
    v33 = mul Field 5, v31
    constrain v32 == v33
    enable_side_effects v30
    v35 = add v2, u32 2
    v36 = cast v27 as u32
    v37 = cast v30 as u32
    v38 = unchecked_mul v36, v28
    v39 = unchecked_mul v37, v35
    v40 = unchecked_add v38, v39
    enable_side_effects u1 1
    v41 = cast v24 as u32
    v42 = cast v25 as u32
    v43 = unchecked_mul v41, v2
    v44 = unchecked_mul v42, v40
    v45 = unchecked_add v43, v44
    call f1(u1 1, v45)
    return
}
brillig(inline) impure fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Dead Instruction Elimination (1):
acir(inline) impure fn main f0 {
  b0(v0: u32):
    v2 = sub v0, u32 1
    v4 = eq v2, u32 0
    v5 = not v4
    v6 = eq v2, u32 1
    v7 = unchecked_mul v5, v6
    v8 = not v6
    v9 = unchecked_mul v5, v8
    v10 = cast v7 as Field
    v11 = cast v9 as Field
    v13 = mul v10, Field 4
    v15 = mul v11, Field 5
    v16 = add v13, v15
    enable_side_effects u1 1
    v18 = cast v4 as Field
    v19 = cast v5 as Field
    v21 = mul v18, Field 3
    v22 = mul v19, v16
    v23 = add v21, v22
    v24 = eq v23, Field 3
    v25 = not v24
    v26 = eq v23, Field 4
    v27 = unchecked_mul v25, v26
    enable_side_effects v27
    v28 = add v2, u32 1
    v29 = not v26
    v30 = unchecked_mul v25, v29
    v31 = cast v30 as Field
    v32 = mul v23, v31
    v33 = mul Field 5, v31
    constrain v32 == v33
    enable_side_effects v30
    v35 = add v2, u32 2
    v36 = cast v27 as u32
    v37 = cast v30 as u32
    v38 = unchecked_mul v36, v28
    v39 = unchecked_mul v37, v35
    v40 = unchecked_add v38, v39
    enable_side_effects u1 1
    v41 = cast v24 as u32
    v42 = cast v25 as u32
    v43 = unchecked_mul v41, v2
    v44 = unchecked_mul v42, v40
    v45 = unchecked_add v43, v44
    call f1(u1 1, v45)
    return
}
brillig(inline) impure fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Simplifying (3):
acir(inline) impure fn main f0 {
  b0(v0: u32):
    v2 = sub v0, u32 1
    v4 = eq v2, u32 0
    v5 = not v4
    v6 = eq v2, u32 1
    v7 = unchecked_mul v5, v6
    v8 = not v6
    v9 = unchecked_mul v5, v8
    v10 = cast v7 as Field
    v11 = cast v9 as Field
    v13 = mul v10, Field 4
    v15 = mul v11, Field 5
    v16 = add v13, v15
    enable_side_effects u1 1
    v18 = cast v4 as Field
    v19 = cast v5 as Field
    v21 = mul v18, Field 3
    v22 = mul v19, v16
    v23 = add v21, v22
    v24 = eq v23, Field 3
    v25 = not v24
    v26 = eq v23, Field 4
    v27 = unchecked_mul v25, v26
    enable_side_effects v27
    v28 = add v2, u32 1
    v29 = not v26
    v30 = unchecked_mul v25, v29
    v31 = cast v30 as Field
    v32 = mul v23, v31
    v33 = mul Field 5, v31
    constrain v32 == v33
    enable_side_effects v30
    v35 = add v2, u32 2
    v36 = cast v27 as u32
    v37 = cast v30 as u32
    v38 = unchecked_mul v36, v28
    v39 = unchecked_mul v37, v35
    v40 = unchecked_add v38, v39
    enable_side_effects u1 1
    v41 = cast v24 as u32
    v42 = cast v25 as u32
    v43 = unchecked_mul v41, v2
    v44 = unchecked_mul v42, v40
    v45 = unchecked_add v43, v44
    call f1(u1 1, v45)
    return
}
brillig(inline) impure fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Mem2Reg (4):
acir(inline) impure fn main f0 {
  b0(v0: u32):
    v2 = sub v0, u32 1
    v4 = eq v2, u32 0
    v5 = not v4
    v6 = eq v2, u32 1
    v7 = unchecked_mul v5, v6
    v8 = not v6
    v9 = unchecked_mul v5, v8
    v10 = cast v7 as Field
    v11 = cast v9 as Field
    v13 = mul v10, Field 4
    v15 = mul v11, Field 5
    v16 = add v13, v15
    enable_side_effects u1 1
    v18 = cast v4 as Field
    v19 = cast v5 as Field
    v21 = mul v18, Field 3
    v22 = mul v19, v16
    v23 = add v21, v22
    v24 = eq v23, Field 3
    v25 = not v24
    v26 = eq v23, Field 4
    v27 = unchecked_mul v25, v26
    enable_side_effects v27
    v28 = add v2, u32 1
    v29 = not v26
    v30 = unchecked_mul v25, v29
    v31 = cast v30 as Field
    v32 = mul v23, v31
    v33 = mul Field 5, v31
    constrain v32 == v33
    enable_side_effects v30
    v35 = add v2, u32 2
    v36 = cast v27 as u32
    v37 = cast v30 as u32
    v38 = unchecked_mul v36, v28
    v39 = unchecked_mul v37, v35
    v40 = unchecked_add v38, v39
    enable_side_effects u1 1
    v41 = cast v24 as u32
    v42 = cast v25 as u32
    v43 = unchecked_mul v41, v2
    v44 = unchecked_mul v42, v40
    v45 = unchecked_add v43, v44
    call f1(u1 1, v45)
    return
}
brillig(inline) impure fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Array Set Optimizations (1):
acir(inline) impure fn main f0 {
  b0(v0: u32):
    v2 = sub v0, u32 1
    v4 = eq v2, u32 0
    v5 = not v4
    v6 = eq v2, u32 1
    v7 = unchecked_mul v5, v6
    v8 = not v6
    v9 = unchecked_mul v5, v8
    v10 = cast v7 as Field
    v11 = cast v9 as Field
    v13 = mul v10, Field 4
    v15 = mul v11, Field 5
    v16 = add v13, v15
    enable_side_effects u1 1
    v18 = cast v4 as Field
    v19 = cast v5 as Field
    v21 = mul v18, Field 3
    v22 = mul v19, v16
    v23 = add v21, v22
    v24 = eq v23, Field 3
    v25 = not v24
    v26 = eq v23, Field 4
    v27 = unchecked_mul v25, v26
    enable_side_effects v27
    v28 = add v2, u32 1
    v29 = not v26
    v30 = unchecked_mul v25, v29
    v31 = cast v30 as Field
    v32 = mul v23, v31
    v33 = mul Field 5, v31
    constrain v32 == v33
    enable_side_effects v30
    v35 = add v2, u32 2
    v36 = cast v27 as u32
    v37 = cast v30 as u32
    v38 = unchecked_mul v36, v28
    v39 = unchecked_mul v37, v35
    v40 = unchecked_add v38, v39
    enable_side_effects u1 1
    v41 = cast v24 as u32
    v42 = cast v25 as u32
    v43 = unchecked_mul v41, v2
    v44 = unchecked_mul v42, v40
    v45 = unchecked_add v43, v44
    call f1(u1 1, v45)
    return
}
brillig(inline) impure fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Brillig Entry Point Analysis (1):
acir(inline) impure fn main f0 {
  b0(v0: u32):
    v2 = sub v0, u32 1
    v4 = eq v2, u32 0
    v5 = not v4
    v6 = eq v2, u32 1
    v7 = unchecked_mul v5, v6
    v8 = not v6
    v9 = unchecked_mul v5, v8
    v10 = cast v7 as Field
    v11 = cast v9 as Field
    v13 = mul v10, Field 4
    v15 = mul v11, Field 5
    v16 = add v13, v15
    enable_side_effects u1 1
    v18 = cast v4 as Field
    v19 = cast v5 as Field
    v21 = mul v18, Field 3
    v22 = mul v19, v16
    v23 = add v21, v22
    v24 = eq v23, Field 3
    v25 = not v24
    v26 = eq v23, Field 4
    v27 = unchecked_mul v25, v26
    enable_side_effects v27
    v28 = add v2, u32 1
    v29 = not v26
    v30 = unchecked_mul v25, v29
    v31 = cast v30 as Field
    v32 = mul v23, v31
    v33 = mul Field 5, v31
    constrain v32 == v33
    enable_side_effects v30
    v35 = add v2, u32 2
    v36 = cast v27 as u32
    v37 = cast v30 as u32
    v38 = unchecked_mul v36, v28
    v39 = unchecked_mul v37, v35
    v40 = unchecked_add v38, v39
    enable_side_effects u1 1
    v41 = cast v24 as u32
    v42 = cast v25 as u32
    v43 = unchecked_mul v41, v2
    v44 = unchecked_mul v42, v40
    v45 = unchecked_add v43, v44
    call f1(u1 1, v45)
    return
}
brillig(inline) impure fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Removing Unreachable Functions (3):
acir(inline) impure fn main f0 {
  b0(v0: u32):
    v2 = sub v0, u32 1
    v4 = eq v2, u32 0
    v5 = not v4
    v6 = eq v2, u32 1
    v7 = unchecked_mul v5, v6
    v8 = not v6
    v9 = unchecked_mul v5, v8
    v10 = cast v7 as Field
    v11 = cast v9 as Field
    v13 = mul v10, Field 4
    v15 = mul v11, Field 5
    v16 = add v13, v15
    enable_side_effects u1 1
    v18 = cast v4 as Field
    v19 = cast v5 as Field
    v21 = mul v18, Field 3
    v22 = mul v19, v16
    v23 = add v21, v22
    v24 = eq v23, Field 3
    v25 = not v24
    v26 = eq v23, Field 4
    v27 = unchecked_mul v25, v26
    enable_side_effects v27
    v28 = add v2, u32 1
    v29 = not v26
    v30 = unchecked_mul v25, v29
    v31 = cast v30 as Field
    v32 = mul v23, v31
    v33 = mul Field 5, v31
    constrain v32 == v33
    enable_side_effects v30
    v35 = add v2, u32 2
    v36 = cast v27 as u32
    v37 = cast v30 as u32
    v38 = unchecked_mul v36, v28
    v39 = unchecked_mul v37, v35
    v40 = unchecked_add v38, v39
    enable_side_effects u1 1
    v41 = cast v24 as u32
    v42 = cast v25 as u32
    v43 = unchecked_mul v41, v2
    v44 = unchecked_mul v42, v40
    v45 = unchecked_add v43, v44
    call f1(u1 1, v45)
    return
}
brillig(inline) impure fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Removing Truncate after RangeCheck (1):
acir(inline) impure fn main f0 {
  b0(v0: u32):
    v2 = sub v0, u32 1
    v4 = eq v2, u32 0
    v5 = not v4
    v6 = eq v2, u32 1
    v7 = unchecked_mul v5, v6
    v8 = not v6
    v9 = unchecked_mul v5, v8
    v10 = cast v7 as Field
    v11 = cast v9 as Field
    v13 = mul v10, Field 4
    v15 = mul v11, Field 5
    v16 = add v13, v15
    enable_side_effects u1 1
    v18 = cast v4 as Field
    v19 = cast v5 as Field
    v21 = mul v18, Field 3
    v22 = mul v19, v16
    v23 = add v21, v22
    v24 = eq v23, Field 3
    v25 = not v24
    v26 = eq v23, Field 4
    v27 = unchecked_mul v25, v26
    enable_side_effects v27
    v28 = add v2, u32 1
    v29 = not v26
    v30 = unchecked_mul v25, v29
    v31 = cast v30 as Field
    v32 = mul v23, v31
    v33 = mul Field 5, v31
    constrain v32 == v33
    enable_side_effects v30
    v35 = add v2, u32 2
    v36 = cast v27 as u32
    v37 = cast v30 as u32
    v38 = unchecked_mul v36, v28
    v39 = unchecked_mul v37, v35
    v40 = unchecked_add v38, v39
    enable_side_effects u1 1
    v41 = cast v24 as u32
    v42 = cast v25 as u32
    v43 = unchecked_mul v41, v2
    v44 = unchecked_mul v42, v40
    v45 = unchecked_add v43, v44
    call f1(u1 1, v45)
    return
}
brillig(inline) impure fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Brillig Array Get and Set Optimizations (1):
acir(inline) impure fn main f0 {
  b0(v0: u32):
    v2 = sub v0, u32 1
    v4 = eq v2, u32 0
    v5 = not v4
    v6 = eq v2, u32 1
    v7 = unchecked_mul v5, v6
    v8 = not v6
    v9 = unchecked_mul v5, v8
    v10 = cast v7 as Field
    v11 = cast v9 as Field
    v13 = mul v10, Field 4
    v15 = mul v11, Field 5
    v16 = add v13, v15
    enable_side_effects u1 1
    v18 = cast v4 as Field
    v19 = cast v5 as Field
    v21 = mul v18, Field 3
    v22 = mul v19, v16
    v23 = add v21, v22
    v24 = eq v23, Field 3
    v25 = not v24
    v26 = eq v23, Field 4
    v27 = unchecked_mul v25, v26
    enable_side_effects v27
    v28 = add v2, u32 1
    v29 = not v26
    v30 = unchecked_mul v25, v29
    v31 = cast v30 as Field
    v32 = mul v23, v31
    v33 = mul Field 5, v31
    constrain v32 == v33
    enable_side_effects v30
    v35 = add v2, u32 2
    v36 = cast v27 as u32
    v37 = cast v30 as u32
    v38 = unchecked_mul v36, v28
    v39 = unchecked_mul v37, v35
    v40 = unchecked_add v38, v39
    enable_side_effects u1 1
    v41 = cast v24 as u32
    v42 = cast v25 as u32
    v43 = unchecked_mul v41, v2
    v44 = unchecked_mul v42, v40
    v45 = unchecked_add v43, v44
    call f1(u1 1, v45)
    return
}
brillig(inline) impure fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Dead Instruction Elimination (2):
acir(inline) impure fn main f0 {
  b0(v0: u32):
    v2 = sub v0, u32 1
    v4 = eq v2, u32 0
    v5 = not v4
    v6 = eq v2, u32 1
    v7 = unchecked_mul v5, v6
    v8 = not v6
    v9 = unchecked_mul v5, v8
    v10 = cast v7 as Field
    v11 = cast v9 as Field
    v13 = mul v10, Field 4
    v15 = mul v11, Field 5
    v16 = add v13, v15
    enable_side_effects u1 1
    v18 = cast v4 as Field
    v19 = cast v5 as Field
    v21 = mul v18, Field 3
    v22 = mul v19, v16
    v23 = add v21, v22
    v24 = eq v23, Field 3
    v25 = not v24
    v26 = eq v23, Field 4
    v27 = unchecked_mul v25, v26
    enable_side_effects v27
    v28 = add v2, u32 1
    v29 = not v26
    v30 = unchecked_mul v25, v29
    v31 = cast v30 as Field
    v32 = mul v23, v31
    v33 = mul Field 5, v31
    constrain v32 == v33
    enable_side_effects v30
    v35 = add v2, u32 2
    v36 = cast v27 as u32
    v37 = cast v30 as u32
    v38 = unchecked_mul v36, v28
    v39 = unchecked_mul v37, v35
    v40 = unchecked_add v38, v39
    enable_side_effects u1 1
    v41 = cast v24 as u32
    v42 = cast v25 as u32
    v43 = unchecked_mul v41, v2
    v44 = unchecked_mul v42, v40
    v45 = unchecked_add v43, v44
    call f1(u1 1, v45)
    return
}
brillig(inline) impure fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Removing Unreachable Functions (4):
acir(inline) impure fn main f0 {
  b0(v0: u32):
    v2 = sub v0, u32 1
    v4 = eq v2, u32 0
    v5 = not v4
    v6 = eq v2, u32 1
    v7 = unchecked_mul v5, v6
    v8 = not v6
    v9 = unchecked_mul v5, v8
    v10 = cast v7 as Field
    v11 = cast v9 as Field
    v13 = mul v10, Field 4
    v15 = mul v11, Field 5
    v16 = add v13, v15
    enable_side_effects u1 1
    v18 = cast v4 as Field
    v19 = cast v5 as Field
    v21 = mul v18, Field 3
    v22 = mul v19, v16
    v23 = add v21, v22
    v24 = eq v23, Field 3
    v25 = not v24
    v26 = eq v23, Field 4
    v27 = unchecked_mul v25, v26
    enable_side_effects v27
    v28 = add v2, u32 1
    v29 = not v26
    v30 = unchecked_mul v25, v29
    v31 = cast v30 as Field
    v32 = mul v23, v31
    v33 = mul Field 5, v31
    constrain v32 == v33
    enable_side_effects v30
    v35 = add v2, u32 2
    v36 = cast v27 as u32
    v37 = cast v30 as u32
    v38 = unchecked_mul v36, v28
    v39 = unchecked_mul v37, v35
    v40 = unchecked_add v38, v39
    enable_side_effects u1 1
    v41 = cast v24 as u32
    v42 = cast v25 as u32
    v43 = unchecked_mul v41, v2
    v44 = unchecked_mul v42, v40
    v45 = unchecked_add v43, v44
    call f1(u1 1, v45)
    return
}
brillig(inline) impure fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Checked to unchecked (1):
acir(inline) impure fn main f0 {
  b0(v0: u32):
    v2 = sub v0, u32 1
    v4 = eq v2, u32 0
    v5 = not v4
    v6 = eq v2, u32 1
    v7 = unchecked_mul v5, v6
    v8 = not v6
    v9 = unchecked_mul v5, v8
    v10 = cast v7 as Field
    v11 = cast v9 as Field
    v13 = mul v10, Field 4
    v15 = mul v11, Field 5
    v16 = add v13, v15
    enable_side_effects u1 1
    v18 = cast v4 as Field
    v19 = cast v5 as Field
    v21 = mul v18, Field 3
    v22 = mul v19, v16
    v23 = add v21, v22
    v24 = eq v23, Field 3
    v25 = not v24
    v26 = eq v23, Field 4
    v27 = unchecked_mul v25, v26
    enable_side_effects v27
    v28 = add v2, u32 1
    v29 = not v26
    v30 = unchecked_mul v25, v29
    v31 = cast v30 as Field
    v32 = mul v23, v31
    v33 = mul Field 5, v31
    constrain v32 == v33
    enable_side_effects v30
    v35 = add v2, u32 2
    v36 = cast v27 as u32
    v37 = cast v30 as u32
    v38 = unchecked_mul v36, v28
    v39 = unchecked_mul v37, v35
    v40 = unchecked_add v38, v39
    enable_side_effects u1 1
    v41 = cast v24 as u32
    v42 = cast v25 as u32
    v43 = unchecked_mul v41, v2
    v44 = unchecked_mul v42, v40
    v45 = unchecked_add v43, v44
    call f1(u1 1, v45)
    return
}
brillig(inline) impure fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Inlining Brillig Calls (1):
acir(inline) impure fn main f0 {
  b0(v0: u32):
    v2 = sub v0, u32 1
    v4 = eq v2, u32 0
    v5 = not v4
    v6 = eq v2, u32 1
    v7 = unchecked_mul v5, v6
    v8 = not v6
    v9 = unchecked_mul v5, v8
    v10 = cast v7 as Field
    v11 = cast v9 as Field
    v13 = mul v10, Field 4
    v15 = mul v11, Field 5
    v16 = add v13, v15
    enable_side_effects u1 1
    v18 = cast v4 as Field
    v19 = cast v5 as Field
    v21 = mul v18, Field 3
    v22 = mul v19, v16
    v23 = add v21, v22
    v24 = eq v23, Field 3
    v25 = not v24
    v26 = eq v23, Field 4
    v27 = unchecked_mul v25, v26
    enable_side_effects v27
    v28 = add v2, u32 1
    v29 = not v26
    v30 = unchecked_mul v25, v29
    v31 = cast v30 as Field
    v32 = mul v23, v31
    v33 = mul Field 5, v31
    constrain v32 == v33
    enable_side_effects v30
    v35 = add v2, u32 2
    v36 = cast v27 as u32
    v37 = cast v30 as u32
    v38 = unchecked_mul v36, v28
    v39 = unchecked_mul v37, v35
    v40 = unchecked_add v38, v39
    enable_side_effects u1 1
    v41 = cast v24 as u32
    v42 = cast v25 as u32
    v43 = unchecked_mul v41, v2
    v44 = unchecked_mul v42, v40
    v45 = unchecked_add v43, v44
    call f1(u1 1, v45)
    return
}
brillig(inline) impure fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Removing Unreachable Functions (5):
acir(inline) impure fn main f0 {
  b0(v0: u32):
    v2 = sub v0, u32 1
    v4 = eq v2, u32 0
    v5 = not v4
    v6 = eq v2, u32 1
    v7 = unchecked_mul v5, v6
    v8 = not v6
    v9 = unchecked_mul v5, v8
    v10 = cast v7 as Field
    v11 = cast v9 as Field
    v13 = mul v10, Field 4
    v15 = mul v11, Field 5
    v16 = add v13, v15
    enable_side_effects u1 1
    v18 = cast v4 as Field
    v19 = cast v5 as Field
    v21 = mul v18, Field 3
    v22 = mul v19, v16
    v23 = add v21, v22
    v24 = eq v23, Field 3
    v25 = not v24
    v26 = eq v23, Field 4
    v27 = unchecked_mul v25, v26
    enable_side_effects v27
    v28 = add v2, u32 1
    v29 = not v26
    v30 = unchecked_mul v25, v29
    v31 = cast v30 as Field
    v32 = mul v23, v31
    v33 = mul Field 5, v31
    constrain v32 == v33
    enable_side_effects v30
    v35 = add v2, u32 2
    v36 = cast v27 as u32
    v37 = cast v30 as u32
    v38 = unchecked_mul v36, v28
    v39 = unchecked_mul v37, v35
    v40 = unchecked_add v38, v39
    enable_side_effects u1 1
    v41 = cast v24 as u32
    v42 = cast v25 as u32
    v43 = unchecked_mul v41, v2
    v44 = unchecked_mul v42, v40
    v45 = unchecked_add v43, v44
    call f1(u1 1, v45)
    return
}
brillig(inline) impure fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

After Dead Instruction Elimination (3):
acir(inline) impure fn main f0 {
  b0(v0: u32):
    v2 = sub v0, u32 1
    v4 = eq v2, u32 0
    v5 = not v4
    v6 = eq v2, u32 1
    v7 = unchecked_mul v5, v6
    v8 = not v6
    v9 = unchecked_mul v5, v8
    v10 = cast v7 as Field
    v11 = cast v9 as Field
    v13 = mul v10, Field 4
    v15 = mul v11, Field 5
    v16 = add v13, v15
    enable_side_effects u1 1
    v18 = cast v4 as Field
    v19 = cast v5 as Field
    v21 = mul v18, Field 3
    v22 = mul v19, v16
    v23 = add v21, v22
    v24 = eq v23, Field 3
    v25 = not v24
    v26 = eq v23, Field 4
    v27 = unchecked_mul v25, v26
    enable_side_effects v27
    v28 = add v2, u32 1
    v29 = not v26
    v30 = unchecked_mul v25, v29
    v31 = cast v30 as Field
    v32 = mul v23, v31
    v33 = mul Field 5, v31
    constrain v32 == v33
    enable_side_effects v30
    v35 = add v2, u32 2
    v36 = cast v27 as u32
    v37 = cast v30 as u32
    v38 = unchecked_mul v36, v28
    v39 = unchecked_mul v37, v35
    v40 = unchecked_add v38, v39
    enable_side_effects u1 1
    v41 = cast v24 as u32
    v42 = cast v25 as u32
    v43 = unchecked_mul v41, v2
    v44 = unchecked_mul v42, v40
    v45 = unchecked_add v43, v44
    call f1(u1 1, v45)
    return
}
brillig(inline) impure fn print_unconstrained f1 {
  b0(v0: u1, v1: u32):
    v21 = make_array b"{\"kind\":\"unsignedinteger\",\"width\":32}"
    call print(v0, v1, v21, u1 0)
    return
}

0
[lambda_from_dynamic_if] Circuit witness successfully solved
[lambda_from_dynamic_if] Witness saved to target/lambda_from_dynamic_if.gz
