// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: acir/circuit.proto
// Protobuf C++ Version: 5.29.3

#ifndef acir_2fcircuit_2eproto_2epb_2eh
#define acir_2fcircuit_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "acir/native.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_acir_2fcircuit_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_acir_2fcircuit_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_acir_2fcircuit_2eproto;
namespace acvm {
namespace acir {
namespace circuit {
class AssertMessage;
struct AssertMessageDefaultTypeInternal;
extern AssertMessageDefaultTypeInternal _AssertMessage_default_instance_;
class AssertionPayload;
struct AssertionPayloadDefaultTypeInternal;
extern AssertionPayloadDefaultTypeInternal _AssertionPayload_default_instance_;
class BlackBoxFuncCall;
struct BlackBoxFuncCallDefaultTypeInternal;
extern BlackBoxFuncCallDefaultTypeInternal _BlackBoxFuncCall_default_instance_;
class BlackBoxFuncCall_AES128Encrypt;
struct BlackBoxFuncCall_AES128EncryptDefaultTypeInternal;
extern BlackBoxFuncCall_AES128EncryptDefaultTypeInternal _BlackBoxFuncCall_AES128Encrypt_default_instance_;
class BlackBoxFuncCall_AND;
struct BlackBoxFuncCall_ANDDefaultTypeInternal;
extern BlackBoxFuncCall_ANDDefaultTypeInternal _BlackBoxFuncCall_AND_default_instance_;
class BlackBoxFuncCall_BigIntAdd;
struct BlackBoxFuncCall_BigIntAddDefaultTypeInternal;
extern BlackBoxFuncCall_BigIntAddDefaultTypeInternal _BlackBoxFuncCall_BigIntAdd_default_instance_;
class BlackBoxFuncCall_BigIntDiv;
struct BlackBoxFuncCall_BigIntDivDefaultTypeInternal;
extern BlackBoxFuncCall_BigIntDivDefaultTypeInternal _BlackBoxFuncCall_BigIntDiv_default_instance_;
class BlackBoxFuncCall_BigIntFromLeBytes;
struct BlackBoxFuncCall_BigIntFromLeBytesDefaultTypeInternal;
extern BlackBoxFuncCall_BigIntFromLeBytesDefaultTypeInternal _BlackBoxFuncCall_BigIntFromLeBytes_default_instance_;
class BlackBoxFuncCall_BigIntMul;
struct BlackBoxFuncCall_BigIntMulDefaultTypeInternal;
extern BlackBoxFuncCall_BigIntMulDefaultTypeInternal _BlackBoxFuncCall_BigIntMul_default_instance_;
class BlackBoxFuncCall_BigIntSub;
struct BlackBoxFuncCall_BigIntSubDefaultTypeInternal;
extern BlackBoxFuncCall_BigIntSubDefaultTypeInternal _BlackBoxFuncCall_BigIntSub_default_instance_;
class BlackBoxFuncCall_BigIntToLeBytes;
struct BlackBoxFuncCall_BigIntToLeBytesDefaultTypeInternal;
extern BlackBoxFuncCall_BigIntToLeBytesDefaultTypeInternal _BlackBoxFuncCall_BigIntToLeBytes_default_instance_;
class BlackBoxFuncCall_Blake2s;
struct BlackBoxFuncCall_Blake2sDefaultTypeInternal;
extern BlackBoxFuncCall_Blake2sDefaultTypeInternal _BlackBoxFuncCall_Blake2s_default_instance_;
class BlackBoxFuncCall_Blake3;
struct BlackBoxFuncCall_Blake3DefaultTypeInternal;
extern BlackBoxFuncCall_Blake3DefaultTypeInternal _BlackBoxFuncCall_Blake3_default_instance_;
class BlackBoxFuncCall_EcdsaSecp256k1;
struct BlackBoxFuncCall_EcdsaSecp256k1DefaultTypeInternal;
extern BlackBoxFuncCall_EcdsaSecp256k1DefaultTypeInternal _BlackBoxFuncCall_EcdsaSecp256k1_default_instance_;
class BlackBoxFuncCall_EcdsaSecp256r1;
struct BlackBoxFuncCall_EcdsaSecp256r1DefaultTypeInternal;
extern BlackBoxFuncCall_EcdsaSecp256r1DefaultTypeInternal _BlackBoxFuncCall_EcdsaSecp256r1_default_instance_;
class BlackBoxFuncCall_EmbeddedCurveAdd;
struct BlackBoxFuncCall_EmbeddedCurveAddDefaultTypeInternal;
extern BlackBoxFuncCall_EmbeddedCurveAddDefaultTypeInternal _BlackBoxFuncCall_EmbeddedCurveAdd_default_instance_;
class BlackBoxFuncCall_Keccakf1600;
struct BlackBoxFuncCall_Keccakf1600DefaultTypeInternal;
extern BlackBoxFuncCall_Keccakf1600DefaultTypeInternal _BlackBoxFuncCall_Keccakf1600_default_instance_;
class BlackBoxFuncCall_MultiScalarMul;
struct BlackBoxFuncCall_MultiScalarMulDefaultTypeInternal;
extern BlackBoxFuncCall_MultiScalarMulDefaultTypeInternal _BlackBoxFuncCall_MultiScalarMul_default_instance_;
class BlackBoxFuncCall_Poseidon2Permutation;
struct BlackBoxFuncCall_Poseidon2PermutationDefaultTypeInternal;
extern BlackBoxFuncCall_Poseidon2PermutationDefaultTypeInternal _BlackBoxFuncCall_Poseidon2Permutation_default_instance_;
class BlackBoxFuncCall_RANGE;
struct BlackBoxFuncCall_RANGEDefaultTypeInternal;
extern BlackBoxFuncCall_RANGEDefaultTypeInternal _BlackBoxFuncCall_RANGE_default_instance_;
class BlackBoxFuncCall_RecursiveAggregation;
struct BlackBoxFuncCall_RecursiveAggregationDefaultTypeInternal;
extern BlackBoxFuncCall_RecursiveAggregationDefaultTypeInternal _BlackBoxFuncCall_RecursiveAggregation_default_instance_;
class BlackBoxFuncCall_Sha256Compression;
struct BlackBoxFuncCall_Sha256CompressionDefaultTypeInternal;
extern BlackBoxFuncCall_Sha256CompressionDefaultTypeInternal _BlackBoxFuncCall_Sha256Compression_default_instance_;
class BlackBoxFuncCall_XOR;
struct BlackBoxFuncCall_XORDefaultTypeInternal;
extern BlackBoxFuncCall_XORDefaultTypeInternal _BlackBoxFuncCall_XOR_default_instance_;
class BlockType;
struct BlockTypeDefaultTypeInternal;
extern BlockTypeDefaultTypeInternal _BlockType_default_instance_;
class BlockType_CallData;
struct BlockType_CallDataDefaultTypeInternal;
extern BlockType_CallDataDefaultTypeInternal _BlockType_CallData_default_instance_;
class BlockType_Memory;
struct BlockType_MemoryDefaultTypeInternal;
extern BlockType_MemoryDefaultTypeInternal _BlockType_Memory_default_instance_;
class BlockType_ReturnData;
struct BlockType_ReturnDataDefaultTypeInternal;
extern BlockType_ReturnDataDefaultTypeInternal _BlockType_ReturnData_default_instance_;
class BrilligInputs;
struct BrilligInputsDefaultTypeInternal;
extern BrilligInputsDefaultTypeInternal _BrilligInputs_default_instance_;
class BrilligInputs_Array;
struct BrilligInputs_ArrayDefaultTypeInternal;
extern BrilligInputs_ArrayDefaultTypeInternal _BrilligInputs_Array_default_instance_;
class BrilligOutputs;
struct BrilligOutputsDefaultTypeInternal;
extern BrilligOutputsDefaultTypeInternal _BrilligOutputs_default_instance_;
class BrilligOutputs_Array;
struct BrilligOutputs_ArrayDefaultTypeInternal;
extern BrilligOutputs_ArrayDefaultTypeInternal _BrilligOutputs_Array_default_instance_;
class Circuit;
struct CircuitDefaultTypeInternal;
extern CircuitDefaultTypeInternal _Circuit_default_instance_;
class ConstantOrWitnessEnum;
struct ConstantOrWitnessEnumDefaultTypeInternal;
extern ConstantOrWitnessEnumDefaultTypeInternal _ConstantOrWitnessEnum_default_instance_;
class ExpressionOrMemory;
struct ExpressionOrMemoryDefaultTypeInternal;
extern ExpressionOrMemoryDefaultTypeInternal _ExpressionOrMemory_default_instance_;
class ExpressionWidth;
struct ExpressionWidthDefaultTypeInternal;
extern ExpressionWidthDefaultTypeInternal _ExpressionWidth_default_instance_;
class ExpressionWidth_Bounded;
struct ExpressionWidth_BoundedDefaultTypeInternal;
extern ExpressionWidth_BoundedDefaultTypeInternal _ExpressionWidth_Bounded_default_instance_;
class ExpressionWidth_Unbounded;
struct ExpressionWidth_UnboundedDefaultTypeInternal;
extern ExpressionWidth_UnboundedDefaultTypeInternal _ExpressionWidth_Unbounded_default_instance_;
class FunctionInput;
struct FunctionInputDefaultTypeInternal;
extern FunctionInputDefaultTypeInternal _FunctionInput_default_instance_;
class MemOp;
struct MemOpDefaultTypeInternal;
extern MemOpDefaultTypeInternal _MemOp_default_instance_;
class Opcode;
struct OpcodeDefaultTypeInternal;
extern OpcodeDefaultTypeInternal _Opcode_default_instance_;
class OpcodeLocation;
struct OpcodeLocationDefaultTypeInternal;
extern OpcodeLocationDefaultTypeInternal _OpcodeLocation_default_instance_;
class OpcodeLocation_BrilligLocation;
struct OpcodeLocation_BrilligLocationDefaultTypeInternal;
extern OpcodeLocation_BrilligLocationDefaultTypeInternal _OpcodeLocation_BrilligLocation_default_instance_;
class Opcode_BrilligCall;
struct Opcode_BrilligCallDefaultTypeInternal;
extern Opcode_BrilligCallDefaultTypeInternal _Opcode_BrilligCall_default_instance_;
class Opcode_Call;
struct Opcode_CallDefaultTypeInternal;
extern Opcode_CallDefaultTypeInternal _Opcode_Call_default_instance_;
class Opcode_MemoryInit;
struct Opcode_MemoryInitDefaultTypeInternal;
extern Opcode_MemoryInitDefaultTypeInternal _Opcode_MemoryInit_default_instance_;
class Opcode_MemoryOp;
struct Opcode_MemoryOpDefaultTypeInternal;
extern Opcode_MemoryOpDefaultTypeInternal _Opcode_MemoryOp_default_instance_;
}  // namespace circuit
}  // namespace acir
}  // namespace acvm
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace acvm {
namespace acir {
namespace circuit {

// ===================================================================


// -------------------------------------------------------------------

class OpcodeLocation_BrilligLocation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.OpcodeLocation.BrilligLocation) */ {
 public:
  inline OpcodeLocation_BrilligLocation() : OpcodeLocation_BrilligLocation(nullptr) {}
  ~OpcodeLocation_BrilligLocation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(OpcodeLocation_BrilligLocation* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(OpcodeLocation_BrilligLocation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OpcodeLocation_BrilligLocation(
      ::google::protobuf::internal::ConstantInitialized);

  inline OpcodeLocation_BrilligLocation(const OpcodeLocation_BrilligLocation& from) : OpcodeLocation_BrilligLocation(nullptr, from) {}
  inline OpcodeLocation_BrilligLocation(OpcodeLocation_BrilligLocation&& from) noexcept
      : OpcodeLocation_BrilligLocation(nullptr, std::move(from)) {}
  inline OpcodeLocation_BrilligLocation& operator=(const OpcodeLocation_BrilligLocation& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpcodeLocation_BrilligLocation& operator=(OpcodeLocation_BrilligLocation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpcodeLocation_BrilligLocation& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpcodeLocation_BrilligLocation* internal_default_instance() {
    return reinterpret_cast<const OpcodeLocation_BrilligLocation*>(
        &_OpcodeLocation_BrilligLocation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(OpcodeLocation_BrilligLocation& a, OpcodeLocation_BrilligLocation& b) { a.Swap(&b); }
  inline void Swap(OpcodeLocation_BrilligLocation* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpcodeLocation_BrilligLocation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpcodeLocation_BrilligLocation* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<OpcodeLocation_BrilligLocation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OpcodeLocation_BrilligLocation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OpcodeLocation_BrilligLocation& from) { OpcodeLocation_BrilligLocation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(OpcodeLocation_BrilligLocation* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.OpcodeLocation.BrilligLocation"; }

 protected:
  explicit OpcodeLocation_BrilligLocation(::google::protobuf::Arena* arena);
  OpcodeLocation_BrilligLocation(::google::protobuf::Arena* arena, const OpcodeLocation_BrilligLocation& from);
  OpcodeLocation_BrilligLocation(::google::protobuf::Arena* arena, OpcodeLocation_BrilligLocation&& from) noexcept
      : OpcodeLocation_BrilligLocation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAcirIndexFieldNumber = 1,
    kBrilligIndexFieldNumber = 2,
  };
  // uint64 acir_index = 1;
  void clear_acir_index() ;
  ::uint64_t acir_index() const;
  void set_acir_index(::uint64_t value);

  private:
  ::uint64_t _internal_acir_index() const;
  void _internal_set_acir_index(::uint64_t value);

  public:
  // uint64 brillig_index = 2;
  void clear_brillig_index() ;
  ::uint64_t brillig_index() const;
  void set_brillig_index(::uint64_t value);

  private:
  ::uint64_t _internal_brillig_index() const;
  void _internal_set_brillig_index(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.OpcodeLocation.BrilligLocation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const OpcodeLocation_BrilligLocation& from_msg);
    ::uint64_t acir_index_;
    ::uint64_t brillig_index_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class ExpressionWidth_Unbounded final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.ExpressionWidth.Unbounded) */ {
 public:
  inline ExpressionWidth_Unbounded() : ExpressionWidth_Unbounded(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ExpressionWidth_Unbounded* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ExpressionWidth_Unbounded));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExpressionWidth_Unbounded(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExpressionWidth_Unbounded(const ExpressionWidth_Unbounded& from) : ExpressionWidth_Unbounded(nullptr, from) {}
  inline ExpressionWidth_Unbounded(ExpressionWidth_Unbounded&& from) noexcept
      : ExpressionWidth_Unbounded(nullptr, std::move(from)) {}
  inline ExpressionWidth_Unbounded& operator=(const ExpressionWidth_Unbounded& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExpressionWidth_Unbounded& operator=(ExpressionWidth_Unbounded&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExpressionWidth_Unbounded& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExpressionWidth_Unbounded* internal_default_instance() {
    return reinterpret_cast<const ExpressionWidth_Unbounded*>(
        &_ExpressionWidth_Unbounded_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(ExpressionWidth_Unbounded& a, ExpressionWidth_Unbounded& b) { a.Swap(&b); }
  inline void Swap(ExpressionWidth_Unbounded* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExpressionWidth_Unbounded* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExpressionWidth_Unbounded* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ExpressionWidth_Unbounded>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ExpressionWidth_Unbounded& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ExpressionWidth_Unbounded& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.ExpressionWidth.Unbounded"; }

 protected:
  explicit ExpressionWidth_Unbounded(::google::protobuf::Arena* arena);
  ExpressionWidth_Unbounded(::google::protobuf::Arena* arena, const ExpressionWidth_Unbounded& from);
  ExpressionWidth_Unbounded(::google::protobuf::Arena* arena, ExpressionWidth_Unbounded&& from) noexcept
      : ExpressionWidth_Unbounded(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.ExpressionWidth.Unbounded)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ExpressionWidth_Unbounded& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class ExpressionWidth_Bounded final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.ExpressionWidth.Bounded) */ {
 public:
  inline ExpressionWidth_Bounded() : ExpressionWidth_Bounded(nullptr) {}
  ~ExpressionWidth_Bounded() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ExpressionWidth_Bounded* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ExpressionWidth_Bounded));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExpressionWidth_Bounded(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExpressionWidth_Bounded(const ExpressionWidth_Bounded& from) : ExpressionWidth_Bounded(nullptr, from) {}
  inline ExpressionWidth_Bounded(ExpressionWidth_Bounded&& from) noexcept
      : ExpressionWidth_Bounded(nullptr, std::move(from)) {}
  inline ExpressionWidth_Bounded& operator=(const ExpressionWidth_Bounded& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExpressionWidth_Bounded& operator=(ExpressionWidth_Bounded&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExpressionWidth_Bounded& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExpressionWidth_Bounded* internal_default_instance() {
    return reinterpret_cast<const ExpressionWidth_Bounded*>(
        &_ExpressionWidth_Bounded_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(ExpressionWidth_Bounded& a, ExpressionWidth_Bounded& b) { a.Swap(&b); }
  inline void Swap(ExpressionWidth_Bounded* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExpressionWidth_Bounded* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExpressionWidth_Bounded* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ExpressionWidth_Bounded>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExpressionWidth_Bounded& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExpressionWidth_Bounded& from) { ExpressionWidth_Bounded::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ExpressionWidth_Bounded* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.ExpressionWidth.Bounded"; }

 protected:
  explicit ExpressionWidth_Bounded(::google::protobuf::Arena* arena);
  ExpressionWidth_Bounded(::google::protobuf::Arena* arena, const ExpressionWidth_Bounded& from);
  ExpressionWidth_Bounded(::google::protobuf::Arena* arena, ExpressionWidth_Bounded&& from) noexcept
      : ExpressionWidth_Bounded(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWidthFieldNumber = 1,
  };
  // uint64 width = 1;
  void clear_width() ;
  ::uint64_t width() const;
  void set_width(::uint64_t value);

  private:
  ::uint64_t _internal_width() const;
  void _internal_set_width(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.ExpressionWidth.Bounded)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ExpressionWidth_Bounded& from_msg);
    ::uint64_t width_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class BlockType_ReturnData final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.BlockType.ReturnData) */ {
 public:
  inline BlockType_ReturnData() : BlockType_ReturnData(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlockType_ReturnData* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlockType_ReturnData));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlockType_ReturnData(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlockType_ReturnData(const BlockType_ReturnData& from) : BlockType_ReturnData(nullptr, from) {}
  inline BlockType_ReturnData(BlockType_ReturnData&& from) noexcept
      : BlockType_ReturnData(nullptr, std::move(from)) {}
  inline BlockType_ReturnData& operator=(const BlockType_ReturnData& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockType_ReturnData& operator=(BlockType_ReturnData&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockType_ReturnData& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockType_ReturnData* internal_default_instance() {
    return reinterpret_cast<const BlockType_ReturnData*>(
        &_BlockType_ReturnData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 40;
  friend void swap(BlockType_ReturnData& a, BlockType_ReturnData& b) { a.Swap(&b); }
  inline void Swap(BlockType_ReturnData* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockType_ReturnData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockType_ReturnData* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<BlockType_ReturnData>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const BlockType_ReturnData& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const BlockType_ReturnData& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.BlockType.ReturnData"; }

 protected:
  explicit BlockType_ReturnData(::google::protobuf::Arena* arena);
  BlockType_ReturnData(::google::protobuf::Arena* arena, const BlockType_ReturnData& from);
  BlockType_ReturnData(::google::protobuf::Arena* arena, BlockType_ReturnData&& from) noexcept
      : BlockType_ReturnData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.BlockType.ReturnData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BlockType_ReturnData& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class BlockType_Memory final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.BlockType.Memory) */ {
 public:
  inline BlockType_Memory() : BlockType_Memory(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlockType_Memory* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlockType_Memory));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlockType_Memory(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlockType_Memory(const BlockType_Memory& from) : BlockType_Memory(nullptr, from) {}
  inline BlockType_Memory(BlockType_Memory&& from) noexcept
      : BlockType_Memory(nullptr, std::move(from)) {}
  inline BlockType_Memory& operator=(const BlockType_Memory& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockType_Memory& operator=(BlockType_Memory&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockType_Memory& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockType_Memory* internal_default_instance() {
    return reinterpret_cast<const BlockType_Memory*>(
        &_BlockType_Memory_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 38;
  friend void swap(BlockType_Memory& a, BlockType_Memory& b) { a.Swap(&b); }
  inline void Swap(BlockType_Memory* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockType_Memory* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockType_Memory* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<BlockType_Memory>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const BlockType_Memory& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const BlockType_Memory& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.BlockType.Memory"; }

 protected:
  explicit BlockType_Memory(::google::protobuf::Arena* arena);
  BlockType_Memory(::google::protobuf::Arena* arena, const BlockType_Memory& from);
  BlockType_Memory(::google::protobuf::Arena* arena, BlockType_Memory&& from) noexcept
      : BlockType_Memory(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.BlockType.Memory)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BlockType_Memory& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class BlockType_CallData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.BlockType.CallData) */ {
 public:
  inline BlockType_CallData() : BlockType_CallData(nullptr) {}
  ~BlockType_CallData() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlockType_CallData* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlockType_CallData));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlockType_CallData(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlockType_CallData(const BlockType_CallData& from) : BlockType_CallData(nullptr, from) {}
  inline BlockType_CallData(BlockType_CallData&& from) noexcept
      : BlockType_CallData(nullptr, std::move(from)) {}
  inline BlockType_CallData& operator=(const BlockType_CallData& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockType_CallData& operator=(BlockType_CallData&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockType_CallData& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockType_CallData* internal_default_instance() {
    return reinterpret_cast<const BlockType_CallData*>(
        &_BlockType_CallData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 39;
  friend void swap(BlockType_CallData& a, BlockType_CallData& b) { a.Swap(&b); }
  inline void Swap(BlockType_CallData* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockType_CallData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockType_CallData* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BlockType_CallData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlockType_CallData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlockType_CallData& from) { BlockType_CallData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BlockType_CallData* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.BlockType.CallData"; }

 protected:
  explicit BlockType_CallData(::google::protobuf::Arena* arena);
  BlockType_CallData(::google::protobuf::Arena* arena, const BlockType_CallData& from);
  BlockType_CallData(::google::protobuf::Arena* arena, BlockType_CallData&& from) noexcept
      : BlockType_CallData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
  };
  // uint32 value = 1;
  void clear_value() ;
  ::uint32_t value() const;
  void set_value(::uint32_t value);

  private:
  ::uint32_t _internal_value() const;
  void _internal_set_value(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.BlockType.CallData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BlockType_CallData& from_msg);
    ::uint32_t value_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class BlackBoxFuncCall_BigIntSub final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.BlackBoxFuncCall.BigIntSub) */ {
 public:
  inline BlackBoxFuncCall_BigIntSub() : BlackBoxFuncCall_BigIntSub(nullptr) {}
  ~BlackBoxFuncCall_BigIntSub() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlackBoxFuncCall_BigIntSub* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlackBoxFuncCall_BigIntSub));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlackBoxFuncCall_BigIntSub(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlackBoxFuncCall_BigIntSub(const BlackBoxFuncCall_BigIntSub& from) : BlackBoxFuncCall_BigIntSub(nullptr, from) {}
  inline BlackBoxFuncCall_BigIntSub(BlackBoxFuncCall_BigIntSub&& from) noexcept
      : BlackBoxFuncCall_BigIntSub(nullptr, std::move(from)) {}
  inline BlackBoxFuncCall_BigIntSub& operator=(const BlackBoxFuncCall_BigIntSub& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlackBoxFuncCall_BigIntSub& operator=(BlackBoxFuncCall_BigIntSub&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlackBoxFuncCall_BigIntSub& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlackBoxFuncCall_BigIntSub* internal_default_instance() {
    return reinterpret_cast<const BlackBoxFuncCall_BigIntSub*>(
        &_BlackBoxFuncCall_BigIntSub_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(BlackBoxFuncCall_BigIntSub& a, BlackBoxFuncCall_BigIntSub& b) { a.Swap(&b); }
  inline void Swap(BlackBoxFuncCall_BigIntSub* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlackBoxFuncCall_BigIntSub* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlackBoxFuncCall_BigIntSub* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BlackBoxFuncCall_BigIntSub>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlackBoxFuncCall_BigIntSub& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlackBoxFuncCall_BigIntSub& from) { BlackBoxFuncCall_BigIntSub::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BlackBoxFuncCall_BigIntSub* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.BlackBoxFuncCall.BigIntSub"; }

 protected:
  explicit BlackBoxFuncCall_BigIntSub(::google::protobuf::Arena* arena);
  BlackBoxFuncCall_BigIntSub(::google::protobuf::Arena* arena, const BlackBoxFuncCall_BigIntSub& from);
  BlackBoxFuncCall_BigIntSub(::google::protobuf::Arena* arena, BlackBoxFuncCall_BigIntSub&& from) noexcept
      : BlackBoxFuncCall_BigIntSub(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLhsFieldNumber = 1,
    kRhsFieldNumber = 2,
    kOutputFieldNumber = 3,
  };
  // uint32 lhs = 1;
  void clear_lhs() ;
  ::uint32_t lhs() const;
  void set_lhs(::uint32_t value);

  private:
  ::uint32_t _internal_lhs() const;
  void _internal_set_lhs(::uint32_t value);

  public:
  // uint32 rhs = 2;
  void clear_rhs() ;
  ::uint32_t rhs() const;
  void set_rhs(::uint32_t value);

  private:
  ::uint32_t _internal_rhs() const;
  void _internal_set_rhs(::uint32_t value);

  public:
  // uint32 output = 3;
  void clear_output() ;
  ::uint32_t output() const;
  void set_output(::uint32_t value);

  private:
  ::uint32_t _internal_output() const;
  void _internal_set_output(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.BlackBoxFuncCall.BigIntSub)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BlackBoxFuncCall_BigIntSub& from_msg);
    ::uint32_t lhs_;
    ::uint32_t rhs_;
    ::uint32_t output_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class BlackBoxFuncCall_BigIntMul final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.BlackBoxFuncCall.BigIntMul) */ {
 public:
  inline BlackBoxFuncCall_BigIntMul() : BlackBoxFuncCall_BigIntMul(nullptr) {}
  ~BlackBoxFuncCall_BigIntMul() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlackBoxFuncCall_BigIntMul* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlackBoxFuncCall_BigIntMul));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlackBoxFuncCall_BigIntMul(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlackBoxFuncCall_BigIntMul(const BlackBoxFuncCall_BigIntMul& from) : BlackBoxFuncCall_BigIntMul(nullptr, from) {}
  inline BlackBoxFuncCall_BigIntMul(BlackBoxFuncCall_BigIntMul&& from) noexcept
      : BlackBoxFuncCall_BigIntMul(nullptr, std::move(from)) {}
  inline BlackBoxFuncCall_BigIntMul& operator=(const BlackBoxFuncCall_BigIntMul& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlackBoxFuncCall_BigIntMul& operator=(BlackBoxFuncCall_BigIntMul&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlackBoxFuncCall_BigIntMul& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlackBoxFuncCall_BigIntMul* internal_default_instance() {
    return reinterpret_cast<const BlackBoxFuncCall_BigIntMul*>(
        &_BlackBoxFuncCall_BigIntMul_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 28;
  friend void swap(BlackBoxFuncCall_BigIntMul& a, BlackBoxFuncCall_BigIntMul& b) { a.Swap(&b); }
  inline void Swap(BlackBoxFuncCall_BigIntMul* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlackBoxFuncCall_BigIntMul* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlackBoxFuncCall_BigIntMul* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BlackBoxFuncCall_BigIntMul>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlackBoxFuncCall_BigIntMul& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlackBoxFuncCall_BigIntMul& from) { BlackBoxFuncCall_BigIntMul::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BlackBoxFuncCall_BigIntMul* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.BlackBoxFuncCall.BigIntMul"; }

 protected:
  explicit BlackBoxFuncCall_BigIntMul(::google::protobuf::Arena* arena);
  BlackBoxFuncCall_BigIntMul(::google::protobuf::Arena* arena, const BlackBoxFuncCall_BigIntMul& from);
  BlackBoxFuncCall_BigIntMul(::google::protobuf::Arena* arena, BlackBoxFuncCall_BigIntMul&& from) noexcept
      : BlackBoxFuncCall_BigIntMul(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLhsFieldNumber = 1,
    kRhsFieldNumber = 2,
    kOutputFieldNumber = 3,
  };
  // uint32 lhs = 1;
  void clear_lhs() ;
  ::uint32_t lhs() const;
  void set_lhs(::uint32_t value);

  private:
  ::uint32_t _internal_lhs() const;
  void _internal_set_lhs(::uint32_t value);

  public:
  // uint32 rhs = 2;
  void clear_rhs() ;
  ::uint32_t rhs() const;
  void set_rhs(::uint32_t value);

  private:
  ::uint32_t _internal_rhs() const;
  void _internal_set_rhs(::uint32_t value);

  public:
  // uint32 output = 3;
  void clear_output() ;
  ::uint32_t output() const;
  void set_output(::uint32_t value);

  private:
  ::uint32_t _internal_output() const;
  void _internal_set_output(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.BlackBoxFuncCall.BigIntMul)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BlackBoxFuncCall_BigIntMul& from_msg);
    ::uint32_t lhs_;
    ::uint32_t rhs_;
    ::uint32_t output_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class BlackBoxFuncCall_BigIntDiv final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.BlackBoxFuncCall.BigIntDiv) */ {
 public:
  inline BlackBoxFuncCall_BigIntDiv() : BlackBoxFuncCall_BigIntDiv(nullptr) {}
  ~BlackBoxFuncCall_BigIntDiv() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlackBoxFuncCall_BigIntDiv* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlackBoxFuncCall_BigIntDiv));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlackBoxFuncCall_BigIntDiv(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlackBoxFuncCall_BigIntDiv(const BlackBoxFuncCall_BigIntDiv& from) : BlackBoxFuncCall_BigIntDiv(nullptr, from) {}
  inline BlackBoxFuncCall_BigIntDiv(BlackBoxFuncCall_BigIntDiv&& from) noexcept
      : BlackBoxFuncCall_BigIntDiv(nullptr, std::move(from)) {}
  inline BlackBoxFuncCall_BigIntDiv& operator=(const BlackBoxFuncCall_BigIntDiv& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlackBoxFuncCall_BigIntDiv& operator=(BlackBoxFuncCall_BigIntDiv&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlackBoxFuncCall_BigIntDiv& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlackBoxFuncCall_BigIntDiv* internal_default_instance() {
    return reinterpret_cast<const BlackBoxFuncCall_BigIntDiv*>(
        &_BlackBoxFuncCall_BigIntDiv_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 29;
  friend void swap(BlackBoxFuncCall_BigIntDiv& a, BlackBoxFuncCall_BigIntDiv& b) { a.Swap(&b); }
  inline void Swap(BlackBoxFuncCall_BigIntDiv* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlackBoxFuncCall_BigIntDiv* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlackBoxFuncCall_BigIntDiv* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BlackBoxFuncCall_BigIntDiv>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlackBoxFuncCall_BigIntDiv& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlackBoxFuncCall_BigIntDiv& from) { BlackBoxFuncCall_BigIntDiv::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BlackBoxFuncCall_BigIntDiv* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.BlackBoxFuncCall.BigIntDiv"; }

 protected:
  explicit BlackBoxFuncCall_BigIntDiv(::google::protobuf::Arena* arena);
  BlackBoxFuncCall_BigIntDiv(::google::protobuf::Arena* arena, const BlackBoxFuncCall_BigIntDiv& from);
  BlackBoxFuncCall_BigIntDiv(::google::protobuf::Arena* arena, BlackBoxFuncCall_BigIntDiv&& from) noexcept
      : BlackBoxFuncCall_BigIntDiv(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLhsFieldNumber = 1,
    kRhsFieldNumber = 2,
    kOutputFieldNumber = 3,
  };
  // uint32 lhs = 1;
  void clear_lhs() ;
  ::uint32_t lhs() const;
  void set_lhs(::uint32_t value);

  private:
  ::uint32_t _internal_lhs() const;
  void _internal_set_lhs(::uint32_t value);

  public:
  // uint32 rhs = 2;
  void clear_rhs() ;
  ::uint32_t rhs() const;
  void set_rhs(::uint32_t value);

  private:
  ::uint32_t _internal_rhs() const;
  void _internal_set_rhs(::uint32_t value);

  public:
  // uint32 output = 3;
  void clear_output() ;
  ::uint32_t output() const;
  void set_output(::uint32_t value);

  private:
  ::uint32_t _internal_output() const;
  void _internal_set_output(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.BlackBoxFuncCall.BigIntDiv)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BlackBoxFuncCall_BigIntDiv& from_msg);
    ::uint32_t lhs_;
    ::uint32_t rhs_;
    ::uint32_t output_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class BlackBoxFuncCall_BigIntAdd final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.BlackBoxFuncCall.BigIntAdd) */ {
 public:
  inline BlackBoxFuncCall_BigIntAdd() : BlackBoxFuncCall_BigIntAdd(nullptr) {}
  ~BlackBoxFuncCall_BigIntAdd() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlackBoxFuncCall_BigIntAdd* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlackBoxFuncCall_BigIntAdd));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlackBoxFuncCall_BigIntAdd(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlackBoxFuncCall_BigIntAdd(const BlackBoxFuncCall_BigIntAdd& from) : BlackBoxFuncCall_BigIntAdd(nullptr, from) {}
  inline BlackBoxFuncCall_BigIntAdd(BlackBoxFuncCall_BigIntAdd&& from) noexcept
      : BlackBoxFuncCall_BigIntAdd(nullptr, std::move(from)) {}
  inline BlackBoxFuncCall_BigIntAdd& operator=(const BlackBoxFuncCall_BigIntAdd& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlackBoxFuncCall_BigIntAdd& operator=(BlackBoxFuncCall_BigIntAdd&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlackBoxFuncCall_BigIntAdd& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlackBoxFuncCall_BigIntAdd* internal_default_instance() {
    return reinterpret_cast<const BlackBoxFuncCall_BigIntAdd*>(
        &_BlackBoxFuncCall_BigIntAdd_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(BlackBoxFuncCall_BigIntAdd& a, BlackBoxFuncCall_BigIntAdd& b) { a.Swap(&b); }
  inline void Swap(BlackBoxFuncCall_BigIntAdd* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlackBoxFuncCall_BigIntAdd* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlackBoxFuncCall_BigIntAdd* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BlackBoxFuncCall_BigIntAdd>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlackBoxFuncCall_BigIntAdd& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlackBoxFuncCall_BigIntAdd& from) { BlackBoxFuncCall_BigIntAdd::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BlackBoxFuncCall_BigIntAdd* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.BlackBoxFuncCall.BigIntAdd"; }

 protected:
  explicit BlackBoxFuncCall_BigIntAdd(::google::protobuf::Arena* arena);
  BlackBoxFuncCall_BigIntAdd(::google::protobuf::Arena* arena, const BlackBoxFuncCall_BigIntAdd& from);
  BlackBoxFuncCall_BigIntAdd(::google::protobuf::Arena* arena, BlackBoxFuncCall_BigIntAdd&& from) noexcept
      : BlackBoxFuncCall_BigIntAdd(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLhsFieldNumber = 1,
    kRhsFieldNumber = 2,
    kOutputFieldNumber = 3,
  };
  // uint32 lhs = 1;
  void clear_lhs() ;
  ::uint32_t lhs() const;
  void set_lhs(::uint32_t value);

  private:
  ::uint32_t _internal_lhs() const;
  void _internal_set_lhs(::uint32_t value);

  public:
  // uint32 rhs = 2;
  void clear_rhs() ;
  ::uint32_t rhs() const;
  void set_rhs(::uint32_t value);

  private:
  ::uint32_t _internal_rhs() const;
  void _internal_set_rhs(::uint32_t value);

  public:
  // uint32 output = 3;
  void clear_output() ;
  ::uint32_t output() const;
  void set_output(::uint32_t value);

  private:
  ::uint32_t _internal_output() const;
  void _internal_set_output(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.BlackBoxFuncCall.BigIntAdd)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BlackBoxFuncCall_BigIntAdd& from_msg);
    ::uint32_t lhs_;
    ::uint32_t rhs_;
    ::uint32_t output_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class OpcodeLocation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.OpcodeLocation) */ {
 public:
  inline OpcodeLocation() : OpcodeLocation(nullptr) {}
  ~OpcodeLocation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(OpcodeLocation* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(OpcodeLocation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OpcodeLocation(
      ::google::protobuf::internal::ConstantInitialized);

  inline OpcodeLocation(const OpcodeLocation& from) : OpcodeLocation(nullptr, from) {}
  inline OpcodeLocation(OpcodeLocation&& from) noexcept
      : OpcodeLocation(nullptr, std::move(from)) {}
  inline OpcodeLocation& operator=(const OpcodeLocation& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpcodeLocation& operator=(OpcodeLocation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpcodeLocation& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kAcir = 1,
    kBrillig = 2,
    VALUE_NOT_SET = 0,
  };
  static inline const OpcodeLocation* internal_default_instance() {
    return reinterpret_cast<const OpcodeLocation*>(
        &_OpcodeLocation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(OpcodeLocation& a, OpcodeLocation& b) { a.Swap(&b); }
  inline void Swap(OpcodeLocation* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpcodeLocation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpcodeLocation* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<OpcodeLocation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OpcodeLocation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OpcodeLocation& from) { OpcodeLocation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(OpcodeLocation* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.OpcodeLocation"; }

 protected:
  explicit OpcodeLocation(::google::protobuf::Arena* arena);
  OpcodeLocation(::google::protobuf::Arena* arena, const OpcodeLocation& from);
  OpcodeLocation(::google::protobuf::Arena* arena, OpcodeLocation&& from) noexcept
      : OpcodeLocation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using BrilligLocation = OpcodeLocation_BrilligLocation;

  // accessors -------------------------------------------------------
  enum : int {
    kAcirFieldNumber = 1,
    kBrilligFieldNumber = 2,
  };
  // uint64 acir = 1;
  bool has_acir() const;
  void clear_acir() ;
  ::uint64_t acir() const;
  void set_acir(::uint64_t value);

  private:
  ::uint64_t _internal_acir() const;
  void _internal_set_acir(::uint64_t value);

  public:
  // .acvm.acir.circuit.OpcodeLocation.BrilligLocation brillig = 2;
  bool has_brillig() const;
  private:
  bool _internal_has_brillig() const;

  public:
  void clear_brillig() ;
  const ::acvm::acir::circuit::OpcodeLocation_BrilligLocation& brillig() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::OpcodeLocation_BrilligLocation* release_brillig();
  ::acvm::acir::circuit::OpcodeLocation_BrilligLocation* mutable_brillig();
  void set_allocated_brillig(::acvm::acir::circuit::OpcodeLocation_BrilligLocation* value);
  void unsafe_arena_set_allocated_brillig(::acvm::acir::circuit::OpcodeLocation_BrilligLocation* value);
  ::acvm::acir::circuit::OpcodeLocation_BrilligLocation* unsafe_arena_release_brillig();

  private:
  const ::acvm::acir::circuit::OpcodeLocation_BrilligLocation& _internal_brillig() const;
  ::acvm::acir::circuit::OpcodeLocation_BrilligLocation* _internal_mutable_brillig();

  public:
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.OpcodeLocation)
 private:
  class _Internal;
  void set_has_acir();
  void set_has_brillig();
  inline bool has_value() const;
  inline void clear_has_value();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const OpcodeLocation& from_msg);
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint64_t acir_;
      ::acvm::acir::circuit::OpcodeLocation_BrilligLocation* brillig_;
    } value_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class ExpressionWidth final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.ExpressionWidth) */ {
 public:
  inline ExpressionWidth() : ExpressionWidth(nullptr) {}
  ~ExpressionWidth() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ExpressionWidth* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ExpressionWidth));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExpressionWidth(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExpressionWidth(const ExpressionWidth& from) : ExpressionWidth(nullptr, from) {}
  inline ExpressionWidth(ExpressionWidth&& from) noexcept
      : ExpressionWidth(nullptr, std::move(from)) {}
  inline ExpressionWidth& operator=(const ExpressionWidth& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExpressionWidth& operator=(ExpressionWidth&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExpressionWidth& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kUnbounded = 1,
    kBounded = 2,
    VALUE_NOT_SET = 0,
  };
  static inline const ExpressionWidth* internal_default_instance() {
    return reinterpret_cast<const ExpressionWidth*>(
        &_ExpressionWidth_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(ExpressionWidth& a, ExpressionWidth& b) { a.Swap(&b); }
  inline void Swap(ExpressionWidth* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExpressionWidth* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExpressionWidth* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ExpressionWidth>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExpressionWidth& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExpressionWidth& from) { ExpressionWidth::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ExpressionWidth* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.ExpressionWidth"; }

 protected:
  explicit ExpressionWidth(::google::protobuf::Arena* arena);
  ExpressionWidth(::google::protobuf::Arena* arena, const ExpressionWidth& from);
  ExpressionWidth(::google::protobuf::Arena* arena, ExpressionWidth&& from) noexcept
      : ExpressionWidth(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Unbounded = ExpressionWidth_Unbounded;
  using Bounded = ExpressionWidth_Bounded;

  // accessors -------------------------------------------------------
  enum : int {
    kUnboundedFieldNumber = 1,
    kBoundedFieldNumber = 2,
  };
  // .acvm.acir.circuit.ExpressionWidth.Unbounded unbounded = 1;
  bool has_unbounded() const;
  private:
  bool _internal_has_unbounded() const;

  public:
  void clear_unbounded() ;
  const ::acvm::acir::circuit::ExpressionWidth_Unbounded& unbounded() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::ExpressionWidth_Unbounded* release_unbounded();
  ::acvm::acir::circuit::ExpressionWidth_Unbounded* mutable_unbounded();
  void set_allocated_unbounded(::acvm::acir::circuit::ExpressionWidth_Unbounded* value);
  void unsafe_arena_set_allocated_unbounded(::acvm::acir::circuit::ExpressionWidth_Unbounded* value);
  ::acvm::acir::circuit::ExpressionWidth_Unbounded* unsafe_arena_release_unbounded();

  private:
  const ::acvm::acir::circuit::ExpressionWidth_Unbounded& _internal_unbounded() const;
  ::acvm::acir::circuit::ExpressionWidth_Unbounded* _internal_mutable_unbounded();

  public:
  // .acvm.acir.circuit.ExpressionWidth.Bounded bounded = 2;
  bool has_bounded() const;
  private:
  bool _internal_has_bounded() const;

  public:
  void clear_bounded() ;
  const ::acvm::acir::circuit::ExpressionWidth_Bounded& bounded() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::ExpressionWidth_Bounded* release_bounded();
  ::acvm::acir::circuit::ExpressionWidth_Bounded* mutable_bounded();
  void set_allocated_bounded(::acvm::acir::circuit::ExpressionWidth_Bounded* value);
  void unsafe_arena_set_allocated_bounded(::acvm::acir::circuit::ExpressionWidth_Bounded* value);
  ::acvm::acir::circuit::ExpressionWidth_Bounded* unsafe_arena_release_bounded();

  private:
  const ::acvm::acir::circuit::ExpressionWidth_Bounded& _internal_bounded() const;
  ::acvm::acir::circuit::ExpressionWidth_Bounded* _internal_mutable_bounded();

  public:
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.ExpressionWidth)
 private:
  class _Internal;
  void set_has_unbounded();
  void set_has_bounded();
  inline bool has_value() const;
  inline void clear_has_value();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ExpressionWidth& from_msg);
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::acvm::acir::circuit::ExpressionWidth_Unbounded* unbounded_;
      ::acvm::acir::circuit::ExpressionWidth_Bounded* bounded_;
    } value_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class ConstantOrWitnessEnum final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.ConstantOrWitnessEnum) */ {
 public:
  inline ConstantOrWitnessEnum() : ConstantOrWitnessEnum(nullptr) {}
  ~ConstantOrWitnessEnum() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ConstantOrWitnessEnum* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ConstantOrWitnessEnum));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ConstantOrWitnessEnum(
      ::google::protobuf::internal::ConstantInitialized);

  inline ConstantOrWitnessEnum(const ConstantOrWitnessEnum& from) : ConstantOrWitnessEnum(nullptr, from) {}
  inline ConstantOrWitnessEnum(ConstantOrWitnessEnum&& from) noexcept
      : ConstantOrWitnessEnum(nullptr, std::move(from)) {}
  inline ConstantOrWitnessEnum& operator=(const ConstantOrWitnessEnum& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConstantOrWitnessEnum& operator=(ConstantOrWitnessEnum&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConstantOrWitnessEnum& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kConstant = 1,
    kWitness = 2,
    VALUE_NOT_SET = 0,
  };
  static inline const ConstantOrWitnessEnum* internal_default_instance() {
    return reinterpret_cast<const ConstantOrWitnessEnum*>(
        &_ConstantOrWitnessEnum_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 36;
  friend void swap(ConstantOrWitnessEnum& a, ConstantOrWitnessEnum& b) { a.Swap(&b); }
  inline void Swap(ConstantOrWitnessEnum* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConstantOrWitnessEnum* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConstantOrWitnessEnum* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ConstantOrWitnessEnum>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConstantOrWitnessEnum& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ConstantOrWitnessEnum& from) { ConstantOrWitnessEnum::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ConstantOrWitnessEnum* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.ConstantOrWitnessEnum"; }

 protected:
  explicit ConstantOrWitnessEnum(::google::protobuf::Arena* arena);
  ConstantOrWitnessEnum(::google::protobuf::Arena* arena, const ConstantOrWitnessEnum& from);
  ConstantOrWitnessEnum(::google::protobuf::Arena* arena, ConstantOrWitnessEnum&& from) noexcept
      : ConstantOrWitnessEnum(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kConstantFieldNumber = 1,
    kWitnessFieldNumber = 2,
  };
  // .acvm.acir.native.Field constant = 1;
  bool has_constant() const;
  private:
  bool _internal_has_constant() const;

  public:
  void clear_constant() ;
  const ::acvm::acir::native::Field& constant() const;
  PROTOBUF_NODISCARD ::acvm::acir::native::Field* release_constant();
  ::acvm::acir::native::Field* mutable_constant();
  void set_allocated_constant(::acvm::acir::native::Field* value);
  void unsafe_arena_set_allocated_constant(::acvm::acir::native::Field* value);
  ::acvm::acir::native::Field* unsafe_arena_release_constant();

  private:
  const ::acvm::acir::native::Field& _internal_constant() const;
  ::acvm::acir::native::Field* _internal_mutable_constant();

  public:
  // .acvm.acir.native.Witness witness = 2;
  bool has_witness() const;
  private:
  bool _internal_has_witness() const;

  public:
  void clear_witness() ;
  const ::acvm::acir::native::Witness& witness() const;
  PROTOBUF_NODISCARD ::acvm::acir::native::Witness* release_witness();
  ::acvm::acir::native::Witness* mutable_witness();
  void set_allocated_witness(::acvm::acir::native::Witness* value);
  void unsafe_arena_set_allocated_witness(::acvm::acir::native::Witness* value);
  ::acvm::acir::native::Witness* unsafe_arena_release_witness();

  private:
  const ::acvm::acir::native::Witness& _internal_witness() const;
  ::acvm::acir::native::Witness* _internal_mutable_witness();

  public:
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.ConstantOrWitnessEnum)
 private:
  class _Internal;
  void set_has_constant();
  void set_has_witness();
  inline bool has_value() const;
  inline void clear_has_value();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ConstantOrWitnessEnum& from_msg);
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::acvm::acir::native::Field* constant_;
      ::acvm::acir::native::Witness* witness_;
    } value_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class BrilligOutputs_Array final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.BrilligOutputs.Array) */ {
 public:
  inline BrilligOutputs_Array() : BrilligOutputs_Array(nullptr) {}
  ~BrilligOutputs_Array() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BrilligOutputs_Array* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BrilligOutputs_Array));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BrilligOutputs_Array(
      ::google::protobuf::internal::ConstantInitialized);

  inline BrilligOutputs_Array(const BrilligOutputs_Array& from) : BrilligOutputs_Array(nullptr, from) {}
  inline BrilligOutputs_Array(BrilligOutputs_Array&& from) noexcept
      : BrilligOutputs_Array(nullptr, std::move(from)) {}
  inline BrilligOutputs_Array& operator=(const BrilligOutputs_Array& from) {
    CopyFrom(from);
    return *this;
  }
  inline BrilligOutputs_Array& operator=(BrilligOutputs_Array&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BrilligOutputs_Array& default_instance() {
    return *internal_default_instance();
  }
  static inline const BrilligOutputs_Array* internal_default_instance() {
    return reinterpret_cast<const BrilligOutputs_Array*>(
        &_BrilligOutputs_Array_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 44;
  friend void swap(BrilligOutputs_Array& a, BrilligOutputs_Array& b) { a.Swap(&b); }
  inline void Swap(BrilligOutputs_Array* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BrilligOutputs_Array* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BrilligOutputs_Array* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BrilligOutputs_Array>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BrilligOutputs_Array& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BrilligOutputs_Array& from) { BrilligOutputs_Array::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BrilligOutputs_Array* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.BrilligOutputs.Array"; }

 protected:
  explicit BrilligOutputs_Array(::google::protobuf::Arena* arena);
  BrilligOutputs_Array(::google::protobuf::Arena* arena, const BrilligOutputs_Array& from);
  BrilligOutputs_Array(::google::protobuf::Arena* arena, BrilligOutputs_Array&& from) noexcept
      : BrilligOutputs_Array(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated .acvm.acir.native.Witness values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  ::acvm::acir::native::Witness* mutable_values(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* mutable_values();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& _internal_values() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* _internal_mutable_values();
  public:
  const ::acvm::acir::native::Witness& values(int index) const;
  ::acvm::acir::native::Witness* add_values();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& values() const;
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.BrilligOutputs.Array)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BrilligOutputs_Array& from_msg);
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::native::Witness > values_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class BlockType final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.BlockType) */ {
 public:
  inline BlockType() : BlockType(nullptr) {}
  ~BlockType() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlockType* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlockType));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlockType(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlockType(const BlockType& from) : BlockType(nullptr, from) {}
  inline BlockType(BlockType&& from) noexcept
      : BlockType(nullptr, std::move(from)) {}
  inline BlockType& operator=(const BlockType& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockType& operator=(BlockType&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockType& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kMemory = 1,
    kCallData = 2,
    kReturnData = 3,
    VALUE_NOT_SET = 0,
  };
  static inline const BlockType* internal_default_instance() {
    return reinterpret_cast<const BlockType*>(
        &_BlockType_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 41;
  friend void swap(BlockType& a, BlockType& b) { a.Swap(&b); }
  inline void Swap(BlockType* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockType* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockType* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BlockType>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlockType& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlockType& from) { BlockType::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BlockType* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.BlockType"; }

 protected:
  explicit BlockType(::google::protobuf::Arena* arena);
  BlockType(::google::protobuf::Arena* arena, const BlockType& from);
  BlockType(::google::protobuf::Arena* arena, BlockType&& from) noexcept
      : BlockType(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Memory = BlockType_Memory;
  using CallData = BlockType_CallData;
  using ReturnData = BlockType_ReturnData;

  // accessors -------------------------------------------------------
  enum : int {
    kMemoryFieldNumber = 1,
    kCallDataFieldNumber = 2,
    kReturnDataFieldNumber = 3,
  };
  // .acvm.acir.circuit.BlockType.Memory memory = 1;
  bool has_memory() const;
  private:
  bool _internal_has_memory() const;

  public:
  void clear_memory() ;
  const ::acvm::acir::circuit::BlockType_Memory& memory() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::BlockType_Memory* release_memory();
  ::acvm::acir::circuit::BlockType_Memory* mutable_memory();
  void set_allocated_memory(::acvm::acir::circuit::BlockType_Memory* value);
  void unsafe_arena_set_allocated_memory(::acvm::acir::circuit::BlockType_Memory* value);
  ::acvm::acir::circuit::BlockType_Memory* unsafe_arena_release_memory();

  private:
  const ::acvm::acir::circuit::BlockType_Memory& _internal_memory() const;
  ::acvm::acir::circuit::BlockType_Memory* _internal_mutable_memory();

  public:
  // .acvm.acir.circuit.BlockType.CallData call_data = 2;
  bool has_call_data() const;
  private:
  bool _internal_has_call_data() const;

  public:
  void clear_call_data() ;
  const ::acvm::acir::circuit::BlockType_CallData& call_data() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::BlockType_CallData* release_call_data();
  ::acvm::acir::circuit::BlockType_CallData* mutable_call_data();
  void set_allocated_call_data(::acvm::acir::circuit::BlockType_CallData* value);
  void unsafe_arena_set_allocated_call_data(::acvm::acir::circuit::BlockType_CallData* value);
  ::acvm::acir::circuit::BlockType_CallData* unsafe_arena_release_call_data();

  private:
  const ::acvm::acir::circuit::BlockType_CallData& _internal_call_data() const;
  ::acvm::acir::circuit::BlockType_CallData* _internal_mutable_call_data();

  public:
  // .acvm.acir.circuit.BlockType.ReturnData return_data = 3;
  bool has_return_data() const;
  private:
  bool _internal_has_return_data() const;

  public:
  void clear_return_data() ;
  const ::acvm::acir::circuit::BlockType_ReturnData& return_data() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::BlockType_ReturnData* release_return_data();
  ::acvm::acir::circuit::BlockType_ReturnData* mutable_return_data();
  void set_allocated_return_data(::acvm::acir::circuit::BlockType_ReturnData* value);
  void unsafe_arena_set_allocated_return_data(::acvm::acir::circuit::BlockType_ReturnData* value);
  ::acvm::acir::circuit::BlockType_ReturnData* unsafe_arena_release_return_data();

  private:
  const ::acvm::acir::circuit::BlockType_ReturnData& _internal_return_data() const;
  ::acvm::acir::circuit::BlockType_ReturnData* _internal_mutable_return_data();

  public:
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.BlockType)
 private:
  class _Internal;
  void set_has_memory();
  void set_has_call_data();
  void set_has_return_data();
  inline bool has_value() const;
  inline void clear_has_value();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BlockType& from_msg);
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::acvm::acir::circuit::BlockType_Memory* memory_;
      ::acvm::acir::circuit::BlockType_CallData* call_data_;
      ::acvm::acir::circuit::BlockType_ReturnData* return_data_;
    } value_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class BlackBoxFuncCall_BigIntToLeBytes final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.BlackBoxFuncCall.BigIntToLeBytes) */ {
 public:
  inline BlackBoxFuncCall_BigIntToLeBytes() : BlackBoxFuncCall_BigIntToLeBytes(nullptr) {}
  ~BlackBoxFuncCall_BigIntToLeBytes() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlackBoxFuncCall_BigIntToLeBytes* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlackBoxFuncCall_BigIntToLeBytes));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlackBoxFuncCall_BigIntToLeBytes(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlackBoxFuncCall_BigIntToLeBytes(const BlackBoxFuncCall_BigIntToLeBytes& from) : BlackBoxFuncCall_BigIntToLeBytes(nullptr, from) {}
  inline BlackBoxFuncCall_BigIntToLeBytes(BlackBoxFuncCall_BigIntToLeBytes&& from) noexcept
      : BlackBoxFuncCall_BigIntToLeBytes(nullptr, std::move(from)) {}
  inline BlackBoxFuncCall_BigIntToLeBytes& operator=(const BlackBoxFuncCall_BigIntToLeBytes& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlackBoxFuncCall_BigIntToLeBytes& operator=(BlackBoxFuncCall_BigIntToLeBytes&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlackBoxFuncCall_BigIntToLeBytes& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlackBoxFuncCall_BigIntToLeBytes* internal_default_instance() {
    return reinterpret_cast<const BlackBoxFuncCall_BigIntToLeBytes*>(
        &_BlackBoxFuncCall_BigIntToLeBytes_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 31;
  friend void swap(BlackBoxFuncCall_BigIntToLeBytes& a, BlackBoxFuncCall_BigIntToLeBytes& b) { a.Swap(&b); }
  inline void Swap(BlackBoxFuncCall_BigIntToLeBytes* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlackBoxFuncCall_BigIntToLeBytes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlackBoxFuncCall_BigIntToLeBytes* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BlackBoxFuncCall_BigIntToLeBytes>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlackBoxFuncCall_BigIntToLeBytes& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlackBoxFuncCall_BigIntToLeBytes& from) { BlackBoxFuncCall_BigIntToLeBytes::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BlackBoxFuncCall_BigIntToLeBytes* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.BlackBoxFuncCall.BigIntToLeBytes"; }

 protected:
  explicit BlackBoxFuncCall_BigIntToLeBytes(::google::protobuf::Arena* arena);
  BlackBoxFuncCall_BigIntToLeBytes(::google::protobuf::Arena* arena, const BlackBoxFuncCall_BigIntToLeBytes& from);
  BlackBoxFuncCall_BigIntToLeBytes(::google::protobuf::Arena* arena, BlackBoxFuncCall_BigIntToLeBytes&& from) noexcept
      : BlackBoxFuncCall_BigIntToLeBytes(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOutputsFieldNumber = 2,
    kInputFieldNumber = 1,
  };
  // repeated .acvm.acir.native.Witness outputs = 2;
  int outputs_size() const;
  private:
  int _internal_outputs_size() const;

  public:
  void clear_outputs() ;
  ::acvm::acir::native::Witness* mutable_outputs(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* mutable_outputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& _internal_outputs() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* _internal_mutable_outputs();
  public:
  const ::acvm::acir::native::Witness& outputs(int index) const;
  ::acvm::acir::native::Witness* add_outputs();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& outputs() const;
  // uint32 input = 1;
  void clear_input() ;
  ::uint32_t input() const;
  void set_input(::uint32_t value);

  private:
  ::uint32_t _internal_input() const;
  void _internal_set_input(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.BlackBoxFuncCall.BigIntToLeBytes)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BlackBoxFuncCall_BigIntToLeBytes& from_msg);
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::native::Witness > outputs_;
    ::uint32_t input_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class Opcode_MemoryInit final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.Opcode.MemoryInit) */ {
 public:
  inline Opcode_MemoryInit() : Opcode_MemoryInit(nullptr) {}
  ~Opcode_MemoryInit() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Opcode_MemoryInit* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Opcode_MemoryInit));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Opcode_MemoryInit(
      ::google::protobuf::internal::ConstantInitialized);

  inline Opcode_MemoryInit(const Opcode_MemoryInit& from) : Opcode_MemoryInit(nullptr, from) {}
  inline Opcode_MemoryInit(Opcode_MemoryInit&& from) noexcept
      : Opcode_MemoryInit(nullptr, std::move(from)) {}
  inline Opcode_MemoryInit& operator=(const Opcode_MemoryInit& from) {
    CopyFrom(from);
    return *this;
  }
  inline Opcode_MemoryInit& operator=(Opcode_MemoryInit&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Opcode_MemoryInit& default_instance() {
    return *internal_default_instance();
  }
  static inline const Opcode_MemoryInit* internal_default_instance() {
    return reinterpret_cast<const Opcode_MemoryInit*>(
        &_Opcode_MemoryInit_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(Opcode_MemoryInit& a, Opcode_MemoryInit& b) { a.Swap(&b); }
  inline void Swap(Opcode_MemoryInit* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Opcode_MemoryInit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Opcode_MemoryInit* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Opcode_MemoryInit>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Opcode_MemoryInit& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Opcode_MemoryInit& from) { Opcode_MemoryInit::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Opcode_MemoryInit* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.Opcode.MemoryInit"; }

 protected:
  explicit Opcode_MemoryInit(::google::protobuf::Arena* arena);
  Opcode_MemoryInit(::google::protobuf::Arena* arena, const Opcode_MemoryInit& from);
  Opcode_MemoryInit(::google::protobuf::Arena* arena, Opcode_MemoryInit&& from) noexcept
      : Opcode_MemoryInit(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInitFieldNumber = 2,
    kBlockTypeFieldNumber = 3,
    kBlockIdFieldNumber = 1,
  };
  // repeated .acvm.acir.native.Witness init = 2;
  int init_size() const;
  private:
  int _internal_init_size() const;

  public:
  void clear_init() ;
  ::acvm::acir::native::Witness* mutable_init(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* mutable_init();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& _internal_init() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* _internal_mutable_init();
  public:
  const ::acvm::acir::native::Witness& init(int index) const;
  ::acvm::acir::native::Witness* add_init();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& init() const;
  // .acvm.acir.circuit.BlockType block_type = 3;
  bool has_block_type() const;
  void clear_block_type() ;
  const ::acvm::acir::circuit::BlockType& block_type() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::BlockType* release_block_type();
  ::acvm::acir::circuit::BlockType* mutable_block_type();
  void set_allocated_block_type(::acvm::acir::circuit::BlockType* value);
  void unsafe_arena_set_allocated_block_type(::acvm::acir::circuit::BlockType* value);
  ::acvm::acir::circuit::BlockType* unsafe_arena_release_block_type();

  private:
  const ::acvm::acir::circuit::BlockType& _internal_block_type() const;
  ::acvm::acir::circuit::BlockType* _internal_mutable_block_type();

  public:
  // uint32 block_id = 1;
  void clear_block_id() ;
  ::uint32_t block_id() const;
  void set_block_id(::uint32_t value);

  private:
  ::uint32_t _internal_block_id() const;
  void _internal_set_block_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.Opcode.MemoryInit)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Opcode_MemoryInit& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::native::Witness > init_;
    ::acvm::acir::circuit::BlockType* block_type_;
    ::uint32_t block_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class FunctionInput final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.FunctionInput) */ {
 public:
  inline FunctionInput() : FunctionInput(nullptr) {}
  ~FunctionInput() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FunctionInput* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FunctionInput));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FunctionInput(
      ::google::protobuf::internal::ConstantInitialized);

  inline FunctionInput(const FunctionInput& from) : FunctionInput(nullptr, from) {}
  inline FunctionInput(FunctionInput&& from) noexcept
      : FunctionInput(nullptr, std::move(from)) {}
  inline FunctionInput& operator=(const FunctionInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline FunctionInput& operator=(FunctionInput&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FunctionInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const FunctionInput* internal_default_instance() {
    return reinterpret_cast<const FunctionInput*>(
        &_FunctionInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 35;
  friend void swap(FunctionInput& a, FunctionInput& b) { a.Swap(&b); }
  inline void Swap(FunctionInput* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FunctionInput* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FunctionInput* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FunctionInput>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FunctionInput& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FunctionInput& from) { FunctionInput::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FunctionInput* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.FunctionInput"; }

 protected:
  explicit FunctionInput(::google::protobuf::Arena* arena);
  FunctionInput(::google::protobuf::Arena* arena, const FunctionInput& from);
  FunctionInput(::google::protobuf::Arena* arena, FunctionInput&& from) noexcept
      : FunctionInput(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInputFieldNumber = 1,
    kNumBitsFieldNumber = 2,
  };
  // .acvm.acir.circuit.ConstantOrWitnessEnum input = 1;
  bool has_input() const;
  void clear_input() ;
  const ::acvm::acir::circuit::ConstantOrWitnessEnum& input() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::ConstantOrWitnessEnum* release_input();
  ::acvm::acir::circuit::ConstantOrWitnessEnum* mutable_input();
  void set_allocated_input(::acvm::acir::circuit::ConstantOrWitnessEnum* value);
  void unsafe_arena_set_allocated_input(::acvm::acir::circuit::ConstantOrWitnessEnum* value);
  ::acvm::acir::circuit::ConstantOrWitnessEnum* unsafe_arena_release_input();

  private:
  const ::acvm::acir::circuit::ConstantOrWitnessEnum& _internal_input() const;
  ::acvm::acir::circuit::ConstantOrWitnessEnum* _internal_mutable_input();

  public:
  // uint32 num_bits = 2;
  void clear_num_bits() ;
  ::uint32_t num_bits() const;
  void set_num_bits(::uint32_t value);

  private:
  ::uint32_t _internal_num_bits() const;
  void _internal_set_num_bits(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.FunctionInput)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FunctionInput& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::acvm::acir::circuit::ConstantOrWitnessEnum* input_;
    ::uint32_t num_bits_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class BrilligOutputs final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.BrilligOutputs) */ {
 public:
  inline BrilligOutputs() : BrilligOutputs(nullptr) {}
  ~BrilligOutputs() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BrilligOutputs* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BrilligOutputs));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BrilligOutputs(
      ::google::protobuf::internal::ConstantInitialized);

  inline BrilligOutputs(const BrilligOutputs& from) : BrilligOutputs(nullptr, from) {}
  inline BrilligOutputs(BrilligOutputs&& from) noexcept
      : BrilligOutputs(nullptr, std::move(from)) {}
  inline BrilligOutputs& operator=(const BrilligOutputs& from) {
    CopyFrom(from);
    return *this;
  }
  inline BrilligOutputs& operator=(BrilligOutputs&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BrilligOutputs& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kSimple = 1,
    kArray = 2,
    VALUE_NOT_SET = 0,
  };
  static inline const BrilligOutputs* internal_default_instance() {
    return reinterpret_cast<const BrilligOutputs*>(
        &_BrilligOutputs_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 45;
  friend void swap(BrilligOutputs& a, BrilligOutputs& b) { a.Swap(&b); }
  inline void Swap(BrilligOutputs* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BrilligOutputs* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BrilligOutputs* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BrilligOutputs>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BrilligOutputs& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BrilligOutputs& from) { BrilligOutputs::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BrilligOutputs* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.BrilligOutputs"; }

 protected:
  explicit BrilligOutputs(::google::protobuf::Arena* arena);
  BrilligOutputs(::google::protobuf::Arena* arena, const BrilligOutputs& from);
  BrilligOutputs(::google::protobuf::Arena* arena, BrilligOutputs&& from) noexcept
      : BrilligOutputs(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Array = BrilligOutputs_Array;

  // accessors -------------------------------------------------------
  enum : int {
    kSimpleFieldNumber = 1,
    kArrayFieldNumber = 2,
  };
  // .acvm.acir.native.Witness simple = 1;
  bool has_simple() const;
  private:
  bool _internal_has_simple() const;

  public:
  void clear_simple() ;
  const ::acvm::acir::native::Witness& simple() const;
  PROTOBUF_NODISCARD ::acvm::acir::native::Witness* release_simple();
  ::acvm::acir::native::Witness* mutable_simple();
  void set_allocated_simple(::acvm::acir::native::Witness* value);
  void unsafe_arena_set_allocated_simple(::acvm::acir::native::Witness* value);
  ::acvm::acir::native::Witness* unsafe_arena_release_simple();

  private:
  const ::acvm::acir::native::Witness& _internal_simple() const;
  ::acvm::acir::native::Witness* _internal_mutable_simple();

  public:
  // .acvm.acir.circuit.BrilligOutputs.Array array = 2;
  bool has_array() const;
  private:
  bool _internal_has_array() const;

  public:
  void clear_array() ;
  const ::acvm::acir::circuit::BrilligOutputs_Array& array() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::BrilligOutputs_Array* release_array();
  ::acvm::acir::circuit::BrilligOutputs_Array* mutable_array();
  void set_allocated_array(::acvm::acir::circuit::BrilligOutputs_Array* value);
  void unsafe_arena_set_allocated_array(::acvm::acir::circuit::BrilligOutputs_Array* value);
  ::acvm::acir::circuit::BrilligOutputs_Array* unsafe_arena_release_array();

  private:
  const ::acvm::acir::circuit::BrilligOutputs_Array& _internal_array() const;
  ::acvm::acir::circuit::BrilligOutputs_Array* _internal_mutable_array();

  public:
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.BrilligOutputs)
 private:
  class _Internal;
  void set_has_simple();
  void set_has_array();
  inline bool has_value() const;
  inline void clear_has_value();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BrilligOutputs& from_msg);
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::acvm::acir::native::Witness* simple_;
      ::acvm::acir::circuit::BrilligOutputs_Array* array_;
    } value_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class Opcode_Call final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.Opcode.Call) */ {
 public:
  inline Opcode_Call() : Opcode_Call(nullptr) {}
  ~Opcode_Call() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Opcode_Call* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Opcode_Call));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Opcode_Call(
      ::google::protobuf::internal::ConstantInitialized);

  inline Opcode_Call(const Opcode_Call& from) : Opcode_Call(nullptr, from) {}
  inline Opcode_Call(Opcode_Call&& from) noexcept
      : Opcode_Call(nullptr, std::move(from)) {}
  inline Opcode_Call& operator=(const Opcode_Call& from) {
    CopyFrom(from);
    return *this;
  }
  inline Opcode_Call& operator=(Opcode_Call&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Opcode_Call& default_instance() {
    return *internal_default_instance();
  }
  static inline const Opcode_Call* internal_default_instance() {
    return reinterpret_cast<const Opcode_Call*>(
        &_Opcode_Call_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(Opcode_Call& a, Opcode_Call& b) { a.Swap(&b); }
  inline void Swap(Opcode_Call* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Opcode_Call* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Opcode_Call* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Opcode_Call>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Opcode_Call& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Opcode_Call& from) { Opcode_Call::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Opcode_Call* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.Opcode.Call"; }

 protected:
  explicit Opcode_Call(::google::protobuf::Arena* arena);
  Opcode_Call(::google::protobuf::Arena* arena, const Opcode_Call& from);
  Opcode_Call(::google::protobuf::Arena* arena, Opcode_Call&& from) noexcept
      : Opcode_Call(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInputsFieldNumber = 2,
    kOutputsFieldNumber = 3,
    kPredicateFieldNumber = 4,
    kIdFieldNumber = 1,
  };
  // repeated .acvm.acir.native.Witness inputs = 2;
  int inputs_size() const;
  private:
  int _internal_inputs_size() const;

  public:
  void clear_inputs() ;
  ::acvm::acir::native::Witness* mutable_inputs(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* mutable_inputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& _internal_inputs() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* _internal_mutable_inputs();
  public:
  const ::acvm::acir::native::Witness& inputs(int index) const;
  ::acvm::acir::native::Witness* add_inputs();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& inputs() const;
  // repeated .acvm.acir.native.Witness outputs = 3;
  int outputs_size() const;
  private:
  int _internal_outputs_size() const;

  public:
  void clear_outputs() ;
  ::acvm::acir::native::Witness* mutable_outputs(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* mutable_outputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& _internal_outputs() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* _internal_mutable_outputs();
  public:
  const ::acvm::acir::native::Witness& outputs(int index) const;
  ::acvm::acir::native::Witness* add_outputs();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& outputs() const;
  // optional .acvm.acir.native.Expression predicate = 4;
  bool has_predicate() const;
  void clear_predicate() ;
  const ::acvm::acir::native::Expression& predicate() const;
  PROTOBUF_NODISCARD ::acvm::acir::native::Expression* release_predicate();
  ::acvm::acir::native::Expression* mutable_predicate();
  void set_allocated_predicate(::acvm::acir::native::Expression* value);
  void unsafe_arena_set_allocated_predicate(::acvm::acir::native::Expression* value);
  ::acvm::acir::native::Expression* unsafe_arena_release_predicate();

  private:
  const ::acvm::acir::native::Expression& _internal_predicate() const;
  ::acvm::acir::native::Expression* _internal_mutable_predicate();

  public:
  // uint32 id = 1;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.Opcode.Call)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Opcode_Call& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::native::Witness > inputs_;
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::native::Witness > outputs_;
    ::acvm::acir::native::Expression* predicate_;
    ::uint32_t id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class MemOp final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.MemOp) */ {
 public:
  inline MemOp() : MemOp(nullptr) {}
  ~MemOp() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MemOp* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MemOp));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MemOp(
      ::google::protobuf::internal::ConstantInitialized);

  inline MemOp(const MemOp& from) : MemOp(nullptr, from) {}
  inline MemOp(MemOp&& from) noexcept
      : MemOp(nullptr, std::move(from)) {}
  inline MemOp& operator=(const MemOp& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemOp& operator=(MemOp&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MemOp& default_instance() {
    return *internal_default_instance();
  }
  static inline const MemOp* internal_default_instance() {
    return reinterpret_cast<const MemOp*>(
        &_MemOp_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 37;
  friend void swap(MemOp& a, MemOp& b) { a.Swap(&b); }
  inline void Swap(MemOp* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MemOp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MemOp* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MemOp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MemOp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MemOp& from) { MemOp::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MemOp* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.MemOp"; }

 protected:
  explicit MemOp(::google::protobuf::Arena* arena);
  MemOp(::google::protobuf::Arena* arena, const MemOp& from);
  MemOp(::google::protobuf::Arena* arena, MemOp&& from) noexcept
      : MemOp(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOperationFieldNumber = 1,
    kIndexFieldNumber = 2,
    kValueFieldNumber = 3,
  };
  // .acvm.acir.native.Expression operation = 1;
  bool has_operation() const;
  void clear_operation() ;
  const ::acvm::acir::native::Expression& operation() const;
  PROTOBUF_NODISCARD ::acvm::acir::native::Expression* release_operation();
  ::acvm::acir::native::Expression* mutable_operation();
  void set_allocated_operation(::acvm::acir::native::Expression* value);
  void unsafe_arena_set_allocated_operation(::acvm::acir::native::Expression* value);
  ::acvm::acir::native::Expression* unsafe_arena_release_operation();

  private:
  const ::acvm::acir::native::Expression& _internal_operation() const;
  ::acvm::acir::native::Expression* _internal_mutable_operation();

  public:
  // .acvm.acir.native.Expression index = 2;
  bool has_index() const;
  void clear_index() ;
  const ::acvm::acir::native::Expression& index() const;
  PROTOBUF_NODISCARD ::acvm::acir::native::Expression* release_index();
  ::acvm::acir::native::Expression* mutable_index();
  void set_allocated_index(::acvm::acir::native::Expression* value);
  void unsafe_arena_set_allocated_index(::acvm::acir::native::Expression* value);
  ::acvm::acir::native::Expression* unsafe_arena_release_index();

  private:
  const ::acvm::acir::native::Expression& _internal_index() const;
  ::acvm::acir::native::Expression* _internal_mutable_index();

  public:
  // .acvm.acir.native.Expression value = 3;
  bool has_value() const;
  void clear_value() ;
  const ::acvm::acir::native::Expression& value() const;
  PROTOBUF_NODISCARD ::acvm::acir::native::Expression* release_value();
  ::acvm::acir::native::Expression* mutable_value();
  void set_allocated_value(::acvm::acir::native::Expression* value);
  void unsafe_arena_set_allocated_value(::acvm::acir::native::Expression* value);
  ::acvm::acir::native::Expression* unsafe_arena_release_value();

  private:
  const ::acvm::acir::native::Expression& _internal_value() const;
  ::acvm::acir::native::Expression* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.MemOp)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MemOp& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::acvm::acir::native::Expression* operation_;
    ::acvm::acir::native::Expression* index_;
    ::acvm::acir::native::Expression* value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class ExpressionOrMemory final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.ExpressionOrMemory) */ {
 public:
  inline ExpressionOrMemory() : ExpressionOrMemory(nullptr) {}
  ~ExpressionOrMemory() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ExpressionOrMemory* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ExpressionOrMemory));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExpressionOrMemory(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExpressionOrMemory(const ExpressionOrMemory& from) : ExpressionOrMemory(nullptr, from) {}
  inline ExpressionOrMemory(ExpressionOrMemory&& from) noexcept
      : ExpressionOrMemory(nullptr, std::move(from)) {}
  inline ExpressionOrMemory& operator=(const ExpressionOrMemory& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExpressionOrMemory& operator=(ExpressionOrMemory&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExpressionOrMemory& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kExpression = 1,
    kMemory = 2,
    VALUE_NOT_SET = 0,
  };
  static inline const ExpressionOrMemory* internal_default_instance() {
    return reinterpret_cast<const ExpressionOrMemory*>(
        &_ExpressionOrMemory_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(ExpressionOrMemory& a, ExpressionOrMemory& b) { a.Swap(&b); }
  inline void Swap(ExpressionOrMemory* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExpressionOrMemory* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExpressionOrMemory* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ExpressionOrMemory>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExpressionOrMemory& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExpressionOrMemory& from) { ExpressionOrMemory::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ExpressionOrMemory* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.ExpressionOrMemory"; }

 protected:
  explicit ExpressionOrMemory(::google::protobuf::Arena* arena);
  ExpressionOrMemory(::google::protobuf::Arena* arena, const ExpressionOrMemory& from);
  ExpressionOrMemory(::google::protobuf::Arena* arena, ExpressionOrMemory&& from) noexcept
      : ExpressionOrMemory(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExpressionFieldNumber = 1,
    kMemoryFieldNumber = 2,
  };
  // .acvm.acir.native.Expression expression = 1;
  bool has_expression() const;
  private:
  bool _internal_has_expression() const;

  public:
  void clear_expression() ;
  const ::acvm::acir::native::Expression& expression() const;
  PROTOBUF_NODISCARD ::acvm::acir::native::Expression* release_expression();
  ::acvm::acir::native::Expression* mutable_expression();
  void set_allocated_expression(::acvm::acir::native::Expression* value);
  void unsafe_arena_set_allocated_expression(::acvm::acir::native::Expression* value);
  ::acvm::acir::native::Expression* unsafe_arena_release_expression();

  private:
  const ::acvm::acir::native::Expression& _internal_expression() const;
  ::acvm::acir::native::Expression* _internal_mutable_expression();

  public:
  // uint32 memory = 2;
  bool has_memory() const;
  void clear_memory() ;
  ::uint32_t memory() const;
  void set_memory(::uint32_t value);

  private:
  ::uint32_t _internal_memory() const;
  void _internal_set_memory(::uint32_t value);

  public:
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.ExpressionOrMemory)
 private:
  class _Internal;
  void set_has_expression();
  void set_has_memory();
  inline bool has_value() const;
  inline void clear_has_value();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ExpressionOrMemory& from_msg);
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::acvm::acir::native::Expression* expression_;
      ::uint32_t memory_;
    } value_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class BrilligInputs_Array final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.BrilligInputs.Array) */ {
 public:
  inline BrilligInputs_Array() : BrilligInputs_Array(nullptr) {}
  ~BrilligInputs_Array() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BrilligInputs_Array* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BrilligInputs_Array));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BrilligInputs_Array(
      ::google::protobuf::internal::ConstantInitialized);

  inline BrilligInputs_Array(const BrilligInputs_Array& from) : BrilligInputs_Array(nullptr, from) {}
  inline BrilligInputs_Array(BrilligInputs_Array&& from) noexcept
      : BrilligInputs_Array(nullptr, std::move(from)) {}
  inline BrilligInputs_Array& operator=(const BrilligInputs_Array& from) {
    CopyFrom(from);
    return *this;
  }
  inline BrilligInputs_Array& operator=(BrilligInputs_Array&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BrilligInputs_Array& default_instance() {
    return *internal_default_instance();
  }
  static inline const BrilligInputs_Array* internal_default_instance() {
    return reinterpret_cast<const BrilligInputs_Array*>(
        &_BrilligInputs_Array_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 42;
  friend void swap(BrilligInputs_Array& a, BrilligInputs_Array& b) { a.Swap(&b); }
  inline void Swap(BrilligInputs_Array* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BrilligInputs_Array* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BrilligInputs_Array* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BrilligInputs_Array>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BrilligInputs_Array& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BrilligInputs_Array& from) { BrilligInputs_Array::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BrilligInputs_Array* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.BrilligInputs.Array"; }

 protected:
  explicit BrilligInputs_Array(::google::protobuf::Arena* arena);
  BrilligInputs_Array(::google::protobuf::Arena* arena, const BrilligInputs_Array& from);
  BrilligInputs_Array(::google::protobuf::Arena* arena, BrilligInputs_Array&& from) noexcept
      : BrilligInputs_Array(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValuesFieldNumber = 2,
  };
  // repeated .acvm.acir.native.Expression values = 2;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  ::acvm::acir::native::Expression* mutable_values(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Expression>* mutable_values();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Expression>& _internal_values() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Expression>* _internal_mutable_values();
  public:
  const ::acvm::acir::native::Expression& values(int index) const;
  ::acvm::acir::native::Expression* add_values();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Expression>& values() const;
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.BrilligInputs.Array)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BrilligInputs_Array& from_msg);
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::native::Expression > values_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class BlackBoxFuncCall_XOR final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.BlackBoxFuncCall.XOR) */ {
 public:
  inline BlackBoxFuncCall_XOR() : BlackBoxFuncCall_XOR(nullptr) {}
  ~BlackBoxFuncCall_XOR() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlackBoxFuncCall_XOR* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlackBoxFuncCall_XOR));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlackBoxFuncCall_XOR(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlackBoxFuncCall_XOR(const BlackBoxFuncCall_XOR& from) : BlackBoxFuncCall_XOR(nullptr, from) {}
  inline BlackBoxFuncCall_XOR(BlackBoxFuncCall_XOR&& from) noexcept
      : BlackBoxFuncCall_XOR(nullptr, std::move(from)) {}
  inline BlackBoxFuncCall_XOR& operator=(const BlackBoxFuncCall_XOR& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlackBoxFuncCall_XOR& operator=(BlackBoxFuncCall_XOR&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlackBoxFuncCall_XOR& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlackBoxFuncCall_XOR* internal_default_instance() {
    return reinterpret_cast<const BlackBoxFuncCall_XOR*>(
        &_BlackBoxFuncCall_XOR_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(BlackBoxFuncCall_XOR& a, BlackBoxFuncCall_XOR& b) { a.Swap(&b); }
  inline void Swap(BlackBoxFuncCall_XOR* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlackBoxFuncCall_XOR* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlackBoxFuncCall_XOR* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BlackBoxFuncCall_XOR>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlackBoxFuncCall_XOR& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlackBoxFuncCall_XOR& from) { BlackBoxFuncCall_XOR::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BlackBoxFuncCall_XOR* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.BlackBoxFuncCall.XOR"; }

 protected:
  explicit BlackBoxFuncCall_XOR(::google::protobuf::Arena* arena);
  BlackBoxFuncCall_XOR(::google::protobuf::Arena* arena, const BlackBoxFuncCall_XOR& from);
  BlackBoxFuncCall_XOR(::google::protobuf::Arena* arena, BlackBoxFuncCall_XOR&& from) noexcept
      : BlackBoxFuncCall_XOR(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLhsFieldNumber = 1,
    kRhsFieldNumber = 2,
    kOutputFieldNumber = 3,
  };
  // .acvm.acir.circuit.FunctionInput lhs = 1;
  bool has_lhs() const;
  void clear_lhs() ;
  const ::acvm::acir::circuit::FunctionInput& lhs() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::FunctionInput* release_lhs();
  ::acvm::acir::circuit::FunctionInput* mutable_lhs();
  void set_allocated_lhs(::acvm::acir::circuit::FunctionInput* value);
  void unsafe_arena_set_allocated_lhs(::acvm::acir::circuit::FunctionInput* value);
  ::acvm::acir::circuit::FunctionInput* unsafe_arena_release_lhs();

  private:
  const ::acvm::acir::circuit::FunctionInput& _internal_lhs() const;
  ::acvm::acir::circuit::FunctionInput* _internal_mutable_lhs();

  public:
  // .acvm.acir.circuit.FunctionInput rhs = 2;
  bool has_rhs() const;
  void clear_rhs() ;
  const ::acvm::acir::circuit::FunctionInput& rhs() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::FunctionInput* release_rhs();
  ::acvm::acir::circuit::FunctionInput* mutable_rhs();
  void set_allocated_rhs(::acvm::acir::circuit::FunctionInput* value);
  void unsafe_arena_set_allocated_rhs(::acvm::acir::circuit::FunctionInput* value);
  ::acvm::acir::circuit::FunctionInput* unsafe_arena_release_rhs();

  private:
  const ::acvm::acir::circuit::FunctionInput& _internal_rhs() const;
  ::acvm::acir::circuit::FunctionInput* _internal_mutable_rhs();

  public:
  // .acvm.acir.native.Witness output = 3;
  bool has_output() const;
  void clear_output() ;
  const ::acvm::acir::native::Witness& output() const;
  PROTOBUF_NODISCARD ::acvm::acir::native::Witness* release_output();
  ::acvm::acir::native::Witness* mutable_output();
  void set_allocated_output(::acvm::acir::native::Witness* value);
  void unsafe_arena_set_allocated_output(::acvm::acir::native::Witness* value);
  ::acvm::acir::native::Witness* unsafe_arena_release_output();

  private:
  const ::acvm::acir::native::Witness& _internal_output() const;
  ::acvm::acir::native::Witness* _internal_mutable_output();

  public:
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.BlackBoxFuncCall.XOR)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BlackBoxFuncCall_XOR& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::acvm::acir::circuit::FunctionInput* lhs_;
    ::acvm::acir::circuit::FunctionInput* rhs_;
    ::acvm::acir::native::Witness* output_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class BlackBoxFuncCall_Sha256Compression final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.BlackBoxFuncCall.Sha256Compression) */ {
 public:
  inline BlackBoxFuncCall_Sha256Compression() : BlackBoxFuncCall_Sha256Compression(nullptr) {}
  ~BlackBoxFuncCall_Sha256Compression() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlackBoxFuncCall_Sha256Compression* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlackBoxFuncCall_Sha256Compression));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlackBoxFuncCall_Sha256Compression(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlackBoxFuncCall_Sha256Compression(const BlackBoxFuncCall_Sha256Compression& from) : BlackBoxFuncCall_Sha256Compression(nullptr, from) {}
  inline BlackBoxFuncCall_Sha256Compression(BlackBoxFuncCall_Sha256Compression&& from) noexcept
      : BlackBoxFuncCall_Sha256Compression(nullptr, std::move(from)) {}
  inline BlackBoxFuncCall_Sha256Compression& operator=(const BlackBoxFuncCall_Sha256Compression& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlackBoxFuncCall_Sha256Compression& operator=(BlackBoxFuncCall_Sha256Compression&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlackBoxFuncCall_Sha256Compression& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlackBoxFuncCall_Sha256Compression* internal_default_instance() {
    return reinterpret_cast<const BlackBoxFuncCall_Sha256Compression*>(
        &_BlackBoxFuncCall_Sha256Compression_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 33;
  friend void swap(BlackBoxFuncCall_Sha256Compression& a, BlackBoxFuncCall_Sha256Compression& b) { a.Swap(&b); }
  inline void Swap(BlackBoxFuncCall_Sha256Compression* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlackBoxFuncCall_Sha256Compression* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlackBoxFuncCall_Sha256Compression* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BlackBoxFuncCall_Sha256Compression>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlackBoxFuncCall_Sha256Compression& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlackBoxFuncCall_Sha256Compression& from) { BlackBoxFuncCall_Sha256Compression::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BlackBoxFuncCall_Sha256Compression* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.BlackBoxFuncCall.Sha256Compression"; }

 protected:
  explicit BlackBoxFuncCall_Sha256Compression(::google::protobuf::Arena* arena);
  BlackBoxFuncCall_Sha256Compression(::google::protobuf::Arena* arena, const BlackBoxFuncCall_Sha256Compression& from);
  BlackBoxFuncCall_Sha256Compression(::google::protobuf::Arena* arena, BlackBoxFuncCall_Sha256Compression&& from) noexcept
      : BlackBoxFuncCall_Sha256Compression(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInputsFieldNumber = 1,
    kHashValuesFieldNumber = 2,
    kOutputsFieldNumber = 3,
  };
  // repeated .acvm.acir.circuit.FunctionInput inputs = 1;
  int inputs_size() const;
  private:
  int _internal_inputs_size() const;

  public:
  void clear_inputs() ;
  ::acvm::acir::circuit::FunctionInput* mutable_inputs(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* mutable_inputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& _internal_inputs() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* _internal_mutable_inputs();
  public:
  const ::acvm::acir::circuit::FunctionInput& inputs(int index) const;
  ::acvm::acir::circuit::FunctionInput* add_inputs();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& inputs() const;
  // repeated .acvm.acir.circuit.FunctionInput hash_values = 2;
  int hash_values_size() const;
  private:
  int _internal_hash_values_size() const;

  public:
  void clear_hash_values() ;
  ::acvm::acir::circuit::FunctionInput* mutable_hash_values(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* mutable_hash_values();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& _internal_hash_values() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* _internal_mutable_hash_values();
  public:
  const ::acvm::acir::circuit::FunctionInput& hash_values(int index) const;
  ::acvm::acir::circuit::FunctionInput* add_hash_values();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& hash_values() const;
  // repeated .acvm.acir.native.Witness outputs = 3;
  int outputs_size() const;
  private:
  int _internal_outputs_size() const;

  public:
  void clear_outputs() ;
  ::acvm::acir::native::Witness* mutable_outputs(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* mutable_outputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& _internal_outputs() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* _internal_mutable_outputs();
  public:
  const ::acvm::acir::native::Witness& outputs(int index) const;
  ::acvm::acir::native::Witness* add_outputs();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& outputs() const;
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.BlackBoxFuncCall.Sha256Compression)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BlackBoxFuncCall_Sha256Compression& from_msg);
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::circuit::FunctionInput > inputs_;
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::circuit::FunctionInput > hash_values_;
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::native::Witness > outputs_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class BlackBoxFuncCall_RecursiveAggregation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.BlackBoxFuncCall.RecursiveAggregation) */ {
 public:
  inline BlackBoxFuncCall_RecursiveAggregation() : BlackBoxFuncCall_RecursiveAggregation(nullptr) {}
  ~BlackBoxFuncCall_RecursiveAggregation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlackBoxFuncCall_RecursiveAggregation* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlackBoxFuncCall_RecursiveAggregation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlackBoxFuncCall_RecursiveAggregation(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlackBoxFuncCall_RecursiveAggregation(const BlackBoxFuncCall_RecursiveAggregation& from) : BlackBoxFuncCall_RecursiveAggregation(nullptr, from) {}
  inline BlackBoxFuncCall_RecursiveAggregation(BlackBoxFuncCall_RecursiveAggregation&& from) noexcept
      : BlackBoxFuncCall_RecursiveAggregation(nullptr, std::move(from)) {}
  inline BlackBoxFuncCall_RecursiveAggregation& operator=(const BlackBoxFuncCall_RecursiveAggregation& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlackBoxFuncCall_RecursiveAggregation& operator=(BlackBoxFuncCall_RecursiveAggregation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlackBoxFuncCall_RecursiveAggregation& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlackBoxFuncCall_RecursiveAggregation* internal_default_instance() {
    return reinterpret_cast<const BlackBoxFuncCall_RecursiveAggregation*>(
        &_BlackBoxFuncCall_RecursiveAggregation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(BlackBoxFuncCall_RecursiveAggregation& a, BlackBoxFuncCall_RecursiveAggregation& b) { a.Swap(&b); }
  inline void Swap(BlackBoxFuncCall_RecursiveAggregation* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlackBoxFuncCall_RecursiveAggregation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlackBoxFuncCall_RecursiveAggregation* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BlackBoxFuncCall_RecursiveAggregation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlackBoxFuncCall_RecursiveAggregation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlackBoxFuncCall_RecursiveAggregation& from) { BlackBoxFuncCall_RecursiveAggregation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BlackBoxFuncCall_RecursiveAggregation* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.BlackBoxFuncCall.RecursiveAggregation"; }

 protected:
  explicit BlackBoxFuncCall_RecursiveAggregation(::google::protobuf::Arena* arena);
  BlackBoxFuncCall_RecursiveAggregation(::google::protobuf::Arena* arena, const BlackBoxFuncCall_RecursiveAggregation& from);
  BlackBoxFuncCall_RecursiveAggregation(::google::protobuf::Arena* arena, BlackBoxFuncCall_RecursiveAggregation&& from) noexcept
      : BlackBoxFuncCall_RecursiveAggregation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kVerificationKeyFieldNumber = 1,
    kProofFieldNumber = 2,
    kPublicInputsFieldNumber = 3,
    kKeyHashFieldNumber = 4,
    kProofTypeFieldNumber = 5,
  };
  // repeated .acvm.acir.circuit.FunctionInput verification_key = 1;
  int verification_key_size() const;
  private:
  int _internal_verification_key_size() const;

  public:
  void clear_verification_key() ;
  ::acvm::acir::circuit::FunctionInput* mutable_verification_key(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* mutable_verification_key();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& _internal_verification_key() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* _internal_mutable_verification_key();
  public:
  const ::acvm::acir::circuit::FunctionInput& verification_key(int index) const;
  ::acvm::acir::circuit::FunctionInput* add_verification_key();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& verification_key() const;
  // repeated .acvm.acir.circuit.FunctionInput proof = 2;
  int proof_size() const;
  private:
  int _internal_proof_size() const;

  public:
  void clear_proof() ;
  ::acvm::acir::circuit::FunctionInput* mutable_proof(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* mutable_proof();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& _internal_proof() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* _internal_mutable_proof();
  public:
  const ::acvm::acir::circuit::FunctionInput& proof(int index) const;
  ::acvm::acir::circuit::FunctionInput* add_proof();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& proof() const;
  // repeated .acvm.acir.circuit.FunctionInput public_inputs = 3;
  int public_inputs_size() const;
  private:
  int _internal_public_inputs_size() const;

  public:
  void clear_public_inputs() ;
  ::acvm::acir::circuit::FunctionInput* mutable_public_inputs(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* mutable_public_inputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& _internal_public_inputs() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* _internal_mutable_public_inputs();
  public:
  const ::acvm::acir::circuit::FunctionInput& public_inputs(int index) const;
  ::acvm::acir::circuit::FunctionInput* add_public_inputs();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& public_inputs() const;
  // .acvm.acir.circuit.FunctionInput key_hash = 4;
  bool has_key_hash() const;
  void clear_key_hash() ;
  const ::acvm::acir::circuit::FunctionInput& key_hash() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::FunctionInput* release_key_hash();
  ::acvm::acir::circuit::FunctionInput* mutable_key_hash();
  void set_allocated_key_hash(::acvm::acir::circuit::FunctionInput* value);
  void unsafe_arena_set_allocated_key_hash(::acvm::acir::circuit::FunctionInput* value);
  ::acvm::acir::circuit::FunctionInput* unsafe_arena_release_key_hash();

  private:
  const ::acvm::acir::circuit::FunctionInput& _internal_key_hash() const;
  ::acvm::acir::circuit::FunctionInput* _internal_mutable_key_hash();

  public:
  // uint32 proof_type = 5;
  void clear_proof_type() ;
  ::uint32_t proof_type() const;
  void set_proof_type(::uint32_t value);

  private:
  ::uint32_t _internal_proof_type() const;
  void _internal_set_proof_type(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.BlackBoxFuncCall.RecursiveAggregation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 4,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BlackBoxFuncCall_RecursiveAggregation& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::circuit::FunctionInput > verification_key_;
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::circuit::FunctionInput > proof_;
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::circuit::FunctionInput > public_inputs_;
    ::acvm::acir::circuit::FunctionInput* key_hash_;
    ::uint32_t proof_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class BlackBoxFuncCall_RANGE final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.BlackBoxFuncCall.RANGE) */ {
 public:
  inline BlackBoxFuncCall_RANGE() : BlackBoxFuncCall_RANGE(nullptr) {}
  ~BlackBoxFuncCall_RANGE() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlackBoxFuncCall_RANGE* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlackBoxFuncCall_RANGE));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlackBoxFuncCall_RANGE(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlackBoxFuncCall_RANGE(const BlackBoxFuncCall_RANGE& from) : BlackBoxFuncCall_RANGE(nullptr, from) {}
  inline BlackBoxFuncCall_RANGE(BlackBoxFuncCall_RANGE&& from) noexcept
      : BlackBoxFuncCall_RANGE(nullptr, std::move(from)) {}
  inline BlackBoxFuncCall_RANGE& operator=(const BlackBoxFuncCall_RANGE& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlackBoxFuncCall_RANGE& operator=(BlackBoxFuncCall_RANGE&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlackBoxFuncCall_RANGE& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlackBoxFuncCall_RANGE* internal_default_instance() {
    return reinterpret_cast<const BlackBoxFuncCall_RANGE*>(
        &_BlackBoxFuncCall_RANGE_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(BlackBoxFuncCall_RANGE& a, BlackBoxFuncCall_RANGE& b) { a.Swap(&b); }
  inline void Swap(BlackBoxFuncCall_RANGE* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlackBoxFuncCall_RANGE* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlackBoxFuncCall_RANGE* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BlackBoxFuncCall_RANGE>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlackBoxFuncCall_RANGE& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlackBoxFuncCall_RANGE& from) { BlackBoxFuncCall_RANGE::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BlackBoxFuncCall_RANGE* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.BlackBoxFuncCall.RANGE"; }

 protected:
  explicit BlackBoxFuncCall_RANGE(::google::protobuf::Arena* arena);
  BlackBoxFuncCall_RANGE(::google::protobuf::Arena* arena, const BlackBoxFuncCall_RANGE& from);
  BlackBoxFuncCall_RANGE(::google::protobuf::Arena* arena, BlackBoxFuncCall_RANGE&& from) noexcept
      : BlackBoxFuncCall_RANGE(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInputFieldNumber = 1,
  };
  // .acvm.acir.circuit.FunctionInput input = 1;
  bool has_input() const;
  void clear_input() ;
  const ::acvm::acir::circuit::FunctionInput& input() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::FunctionInput* release_input();
  ::acvm::acir::circuit::FunctionInput* mutable_input();
  void set_allocated_input(::acvm::acir::circuit::FunctionInput* value);
  void unsafe_arena_set_allocated_input(::acvm::acir::circuit::FunctionInput* value);
  ::acvm::acir::circuit::FunctionInput* unsafe_arena_release_input();

  private:
  const ::acvm::acir::circuit::FunctionInput& _internal_input() const;
  ::acvm::acir::circuit::FunctionInput* _internal_mutable_input();

  public:
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.BlackBoxFuncCall.RANGE)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BlackBoxFuncCall_RANGE& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::acvm::acir::circuit::FunctionInput* input_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class BlackBoxFuncCall_Poseidon2Permutation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.BlackBoxFuncCall.Poseidon2Permutation) */ {
 public:
  inline BlackBoxFuncCall_Poseidon2Permutation() : BlackBoxFuncCall_Poseidon2Permutation(nullptr) {}
  ~BlackBoxFuncCall_Poseidon2Permutation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlackBoxFuncCall_Poseidon2Permutation* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlackBoxFuncCall_Poseidon2Permutation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlackBoxFuncCall_Poseidon2Permutation(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlackBoxFuncCall_Poseidon2Permutation(const BlackBoxFuncCall_Poseidon2Permutation& from) : BlackBoxFuncCall_Poseidon2Permutation(nullptr, from) {}
  inline BlackBoxFuncCall_Poseidon2Permutation(BlackBoxFuncCall_Poseidon2Permutation&& from) noexcept
      : BlackBoxFuncCall_Poseidon2Permutation(nullptr, std::move(from)) {}
  inline BlackBoxFuncCall_Poseidon2Permutation& operator=(const BlackBoxFuncCall_Poseidon2Permutation& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlackBoxFuncCall_Poseidon2Permutation& operator=(BlackBoxFuncCall_Poseidon2Permutation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlackBoxFuncCall_Poseidon2Permutation& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlackBoxFuncCall_Poseidon2Permutation* internal_default_instance() {
    return reinterpret_cast<const BlackBoxFuncCall_Poseidon2Permutation*>(
        &_BlackBoxFuncCall_Poseidon2Permutation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 32;
  friend void swap(BlackBoxFuncCall_Poseidon2Permutation& a, BlackBoxFuncCall_Poseidon2Permutation& b) { a.Swap(&b); }
  inline void Swap(BlackBoxFuncCall_Poseidon2Permutation* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlackBoxFuncCall_Poseidon2Permutation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlackBoxFuncCall_Poseidon2Permutation* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BlackBoxFuncCall_Poseidon2Permutation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlackBoxFuncCall_Poseidon2Permutation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlackBoxFuncCall_Poseidon2Permutation& from) { BlackBoxFuncCall_Poseidon2Permutation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BlackBoxFuncCall_Poseidon2Permutation* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.BlackBoxFuncCall.Poseidon2Permutation"; }

 protected:
  explicit BlackBoxFuncCall_Poseidon2Permutation(::google::protobuf::Arena* arena);
  BlackBoxFuncCall_Poseidon2Permutation(::google::protobuf::Arena* arena, const BlackBoxFuncCall_Poseidon2Permutation& from);
  BlackBoxFuncCall_Poseidon2Permutation(::google::protobuf::Arena* arena, BlackBoxFuncCall_Poseidon2Permutation&& from) noexcept
      : BlackBoxFuncCall_Poseidon2Permutation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInputsFieldNumber = 1,
    kOutputsFieldNumber = 2,
    kLenFieldNumber = 3,
  };
  // repeated .acvm.acir.circuit.FunctionInput inputs = 1;
  int inputs_size() const;
  private:
  int _internal_inputs_size() const;

  public:
  void clear_inputs() ;
  ::acvm::acir::circuit::FunctionInput* mutable_inputs(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* mutable_inputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& _internal_inputs() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* _internal_mutable_inputs();
  public:
  const ::acvm::acir::circuit::FunctionInput& inputs(int index) const;
  ::acvm::acir::circuit::FunctionInput* add_inputs();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& inputs() const;
  // repeated .acvm.acir.native.Witness outputs = 2;
  int outputs_size() const;
  private:
  int _internal_outputs_size() const;

  public:
  void clear_outputs() ;
  ::acvm::acir::native::Witness* mutable_outputs(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* mutable_outputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& _internal_outputs() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* _internal_mutable_outputs();
  public:
  const ::acvm::acir::native::Witness& outputs(int index) const;
  ::acvm::acir::native::Witness* add_outputs();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& outputs() const;
  // uint32 len = 3;
  void clear_len() ;
  ::uint32_t len() const;
  void set_len(::uint32_t value);

  private:
  ::uint32_t _internal_len() const;
  void _internal_set_len(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.BlackBoxFuncCall.Poseidon2Permutation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BlackBoxFuncCall_Poseidon2Permutation& from_msg);
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::circuit::FunctionInput > inputs_;
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::native::Witness > outputs_;
    ::uint32_t len_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class BlackBoxFuncCall_MultiScalarMul final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.BlackBoxFuncCall.MultiScalarMul) */ {
 public:
  inline BlackBoxFuncCall_MultiScalarMul() : BlackBoxFuncCall_MultiScalarMul(nullptr) {}
  ~BlackBoxFuncCall_MultiScalarMul() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlackBoxFuncCall_MultiScalarMul* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlackBoxFuncCall_MultiScalarMul));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlackBoxFuncCall_MultiScalarMul(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlackBoxFuncCall_MultiScalarMul(const BlackBoxFuncCall_MultiScalarMul& from) : BlackBoxFuncCall_MultiScalarMul(nullptr, from) {}
  inline BlackBoxFuncCall_MultiScalarMul(BlackBoxFuncCall_MultiScalarMul&& from) noexcept
      : BlackBoxFuncCall_MultiScalarMul(nullptr, std::move(from)) {}
  inline BlackBoxFuncCall_MultiScalarMul& operator=(const BlackBoxFuncCall_MultiScalarMul& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlackBoxFuncCall_MultiScalarMul& operator=(BlackBoxFuncCall_MultiScalarMul&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlackBoxFuncCall_MultiScalarMul& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlackBoxFuncCall_MultiScalarMul* internal_default_instance() {
    return reinterpret_cast<const BlackBoxFuncCall_MultiScalarMul*>(
        &_BlackBoxFuncCall_MultiScalarMul_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(BlackBoxFuncCall_MultiScalarMul& a, BlackBoxFuncCall_MultiScalarMul& b) { a.Swap(&b); }
  inline void Swap(BlackBoxFuncCall_MultiScalarMul* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlackBoxFuncCall_MultiScalarMul* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlackBoxFuncCall_MultiScalarMul* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BlackBoxFuncCall_MultiScalarMul>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlackBoxFuncCall_MultiScalarMul& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlackBoxFuncCall_MultiScalarMul& from) { BlackBoxFuncCall_MultiScalarMul::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BlackBoxFuncCall_MultiScalarMul* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.BlackBoxFuncCall.MultiScalarMul"; }

 protected:
  explicit BlackBoxFuncCall_MultiScalarMul(::google::protobuf::Arena* arena);
  BlackBoxFuncCall_MultiScalarMul(::google::protobuf::Arena* arena, const BlackBoxFuncCall_MultiScalarMul& from);
  BlackBoxFuncCall_MultiScalarMul(::google::protobuf::Arena* arena, BlackBoxFuncCall_MultiScalarMul&& from) noexcept
      : BlackBoxFuncCall_MultiScalarMul(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPointsFieldNumber = 1,
    kScalarsFieldNumber = 2,
    kOutputsFieldNumber = 3,
  };
  // repeated .acvm.acir.circuit.FunctionInput points = 1;
  int points_size() const;
  private:
  int _internal_points_size() const;

  public:
  void clear_points() ;
  ::acvm::acir::circuit::FunctionInput* mutable_points(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* mutable_points();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& _internal_points() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* _internal_mutable_points();
  public:
  const ::acvm::acir::circuit::FunctionInput& points(int index) const;
  ::acvm::acir::circuit::FunctionInput* add_points();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& points() const;
  // repeated .acvm.acir.circuit.FunctionInput scalars = 2;
  int scalars_size() const;
  private:
  int _internal_scalars_size() const;

  public:
  void clear_scalars() ;
  ::acvm::acir::circuit::FunctionInput* mutable_scalars(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* mutable_scalars();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& _internal_scalars() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* _internal_mutable_scalars();
  public:
  const ::acvm::acir::circuit::FunctionInput& scalars(int index) const;
  ::acvm::acir::circuit::FunctionInput* add_scalars();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& scalars() const;
  // repeated .acvm.acir.native.Witness outputs = 3;
  int outputs_size() const;
  private:
  int _internal_outputs_size() const;

  public:
  void clear_outputs() ;
  ::acvm::acir::native::Witness* mutable_outputs(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* mutable_outputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& _internal_outputs() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* _internal_mutable_outputs();
  public:
  const ::acvm::acir::native::Witness& outputs(int index) const;
  ::acvm::acir::native::Witness* add_outputs();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& outputs() const;
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.BlackBoxFuncCall.MultiScalarMul)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BlackBoxFuncCall_MultiScalarMul& from_msg);
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::circuit::FunctionInput > points_;
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::circuit::FunctionInput > scalars_;
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::native::Witness > outputs_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class BlackBoxFuncCall_Keccakf1600 final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.BlackBoxFuncCall.Keccakf1600) */ {
 public:
  inline BlackBoxFuncCall_Keccakf1600() : BlackBoxFuncCall_Keccakf1600(nullptr) {}
  ~BlackBoxFuncCall_Keccakf1600() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlackBoxFuncCall_Keccakf1600* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlackBoxFuncCall_Keccakf1600));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlackBoxFuncCall_Keccakf1600(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlackBoxFuncCall_Keccakf1600(const BlackBoxFuncCall_Keccakf1600& from) : BlackBoxFuncCall_Keccakf1600(nullptr, from) {}
  inline BlackBoxFuncCall_Keccakf1600(BlackBoxFuncCall_Keccakf1600&& from) noexcept
      : BlackBoxFuncCall_Keccakf1600(nullptr, std::move(from)) {}
  inline BlackBoxFuncCall_Keccakf1600& operator=(const BlackBoxFuncCall_Keccakf1600& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlackBoxFuncCall_Keccakf1600& operator=(BlackBoxFuncCall_Keccakf1600&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlackBoxFuncCall_Keccakf1600& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlackBoxFuncCall_Keccakf1600* internal_default_instance() {
    return reinterpret_cast<const BlackBoxFuncCall_Keccakf1600*>(
        &_BlackBoxFuncCall_Keccakf1600_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(BlackBoxFuncCall_Keccakf1600& a, BlackBoxFuncCall_Keccakf1600& b) { a.Swap(&b); }
  inline void Swap(BlackBoxFuncCall_Keccakf1600* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlackBoxFuncCall_Keccakf1600* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlackBoxFuncCall_Keccakf1600* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BlackBoxFuncCall_Keccakf1600>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlackBoxFuncCall_Keccakf1600& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlackBoxFuncCall_Keccakf1600& from) { BlackBoxFuncCall_Keccakf1600::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BlackBoxFuncCall_Keccakf1600* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.BlackBoxFuncCall.Keccakf1600"; }

 protected:
  explicit BlackBoxFuncCall_Keccakf1600(::google::protobuf::Arena* arena);
  BlackBoxFuncCall_Keccakf1600(::google::protobuf::Arena* arena, const BlackBoxFuncCall_Keccakf1600& from);
  BlackBoxFuncCall_Keccakf1600(::google::protobuf::Arena* arena, BlackBoxFuncCall_Keccakf1600&& from) noexcept
      : BlackBoxFuncCall_Keccakf1600(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInputsFieldNumber = 1,
    kOutputsFieldNumber = 2,
  };
  // repeated .acvm.acir.circuit.FunctionInput inputs = 1;
  int inputs_size() const;
  private:
  int _internal_inputs_size() const;

  public:
  void clear_inputs() ;
  ::acvm::acir::circuit::FunctionInput* mutable_inputs(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* mutable_inputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& _internal_inputs() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* _internal_mutable_inputs();
  public:
  const ::acvm::acir::circuit::FunctionInput& inputs(int index) const;
  ::acvm::acir::circuit::FunctionInput* add_inputs();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& inputs() const;
  // repeated .acvm.acir.native.Witness outputs = 2;
  int outputs_size() const;
  private:
  int _internal_outputs_size() const;

  public:
  void clear_outputs() ;
  ::acvm::acir::native::Witness* mutable_outputs(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* mutable_outputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& _internal_outputs() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* _internal_mutable_outputs();
  public:
  const ::acvm::acir::native::Witness& outputs(int index) const;
  ::acvm::acir::native::Witness* add_outputs();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& outputs() const;
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.BlackBoxFuncCall.Keccakf1600)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BlackBoxFuncCall_Keccakf1600& from_msg);
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::circuit::FunctionInput > inputs_;
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::native::Witness > outputs_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class BlackBoxFuncCall_EmbeddedCurveAdd final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.BlackBoxFuncCall.EmbeddedCurveAdd) */ {
 public:
  inline BlackBoxFuncCall_EmbeddedCurveAdd() : BlackBoxFuncCall_EmbeddedCurveAdd(nullptr) {}
  ~BlackBoxFuncCall_EmbeddedCurveAdd() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlackBoxFuncCall_EmbeddedCurveAdd* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlackBoxFuncCall_EmbeddedCurveAdd));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlackBoxFuncCall_EmbeddedCurveAdd(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlackBoxFuncCall_EmbeddedCurveAdd(const BlackBoxFuncCall_EmbeddedCurveAdd& from) : BlackBoxFuncCall_EmbeddedCurveAdd(nullptr, from) {}
  inline BlackBoxFuncCall_EmbeddedCurveAdd(BlackBoxFuncCall_EmbeddedCurveAdd&& from) noexcept
      : BlackBoxFuncCall_EmbeddedCurveAdd(nullptr, std::move(from)) {}
  inline BlackBoxFuncCall_EmbeddedCurveAdd& operator=(const BlackBoxFuncCall_EmbeddedCurveAdd& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlackBoxFuncCall_EmbeddedCurveAdd& operator=(BlackBoxFuncCall_EmbeddedCurveAdd&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlackBoxFuncCall_EmbeddedCurveAdd& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlackBoxFuncCall_EmbeddedCurveAdd* internal_default_instance() {
    return reinterpret_cast<const BlackBoxFuncCall_EmbeddedCurveAdd*>(
        &_BlackBoxFuncCall_EmbeddedCurveAdd_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(BlackBoxFuncCall_EmbeddedCurveAdd& a, BlackBoxFuncCall_EmbeddedCurveAdd& b) { a.Swap(&b); }
  inline void Swap(BlackBoxFuncCall_EmbeddedCurveAdd* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlackBoxFuncCall_EmbeddedCurveAdd* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlackBoxFuncCall_EmbeddedCurveAdd* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BlackBoxFuncCall_EmbeddedCurveAdd>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlackBoxFuncCall_EmbeddedCurveAdd& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlackBoxFuncCall_EmbeddedCurveAdd& from) { BlackBoxFuncCall_EmbeddedCurveAdd::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BlackBoxFuncCall_EmbeddedCurveAdd* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.BlackBoxFuncCall.EmbeddedCurveAdd"; }

 protected:
  explicit BlackBoxFuncCall_EmbeddedCurveAdd(::google::protobuf::Arena* arena);
  BlackBoxFuncCall_EmbeddedCurveAdd(::google::protobuf::Arena* arena, const BlackBoxFuncCall_EmbeddedCurveAdd& from);
  BlackBoxFuncCall_EmbeddedCurveAdd(::google::protobuf::Arena* arena, BlackBoxFuncCall_EmbeddedCurveAdd&& from) noexcept
      : BlackBoxFuncCall_EmbeddedCurveAdd(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInput1FieldNumber = 1,
    kInput2FieldNumber = 2,
    kOutputsFieldNumber = 3,
  };
  // repeated .acvm.acir.circuit.FunctionInput input1 = 1;
  int input1_size() const;
  private:
  int _internal_input1_size() const;

  public:
  void clear_input1() ;
  ::acvm::acir::circuit::FunctionInput* mutable_input1(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* mutable_input1();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& _internal_input1() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* _internal_mutable_input1();
  public:
  const ::acvm::acir::circuit::FunctionInput& input1(int index) const;
  ::acvm::acir::circuit::FunctionInput* add_input1();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& input1() const;
  // repeated .acvm.acir.circuit.FunctionInput input2 = 2;
  int input2_size() const;
  private:
  int _internal_input2_size() const;

  public:
  void clear_input2() ;
  ::acvm::acir::circuit::FunctionInput* mutable_input2(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* mutable_input2();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& _internal_input2() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* _internal_mutable_input2();
  public:
  const ::acvm::acir::circuit::FunctionInput& input2(int index) const;
  ::acvm::acir::circuit::FunctionInput* add_input2();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& input2() const;
  // repeated .acvm.acir.native.Witness outputs = 3;
  int outputs_size() const;
  private:
  int _internal_outputs_size() const;

  public:
  void clear_outputs() ;
  ::acvm::acir::native::Witness* mutable_outputs(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* mutable_outputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& _internal_outputs() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* _internal_mutable_outputs();
  public:
  const ::acvm::acir::native::Witness& outputs(int index) const;
  ::acvm::acir::native::Witness* add_outputs();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& outputs() const;
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.BlackBoxFuncCall.EmbeddedCurveAdd)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BlackBoxFuncCall_EmbeddedCurveAdd& from_msg);
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::circuit::FunctionInput > input1_;
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::circuit::FunctionInput > input2_;
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::native::Witness > outputs_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class BlackBoxFuncCall_EcdsaSecp256r1 final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256r1) */ {
 public:
  inline BlackBoxFuncCall_EcdsaSecp256r1() : BlackBoxFuncCall_EcdsaSecp256r1(nullptr) {}
  ~BlackBoxFuncCall_EcdsaSecp256r1() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlackBoxFuncCall_EcdsaSecp256r1* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlackBoxFuncCall_EcdsaSecp256r1));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlackBoxFuncCall_EcdsaSecp256r1(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlackBoxFuncCall_EcdsaSecp256r1(const BlackBoxFuncCall_EcdsaSecp256r1& from) : BlackBoxFuncCall_EcdsaSecp256r1(nullptr, from) {}
  inline BlackBoxFuncCall_EcdsaSecp256r1(BlackBoxFuncCall_EcdsaSecp256r1&& from) noexcept
      : BlackBoxFuncCall_EcdsaSecp256r1(nullptr, std::move(from)) {}
  inline BlackBoxFuncCall_EcdsaSecp256r1& operator=(const BlackBoxFuncCall_EcdsaSecp256r1& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlackBoxFuncCall_EcdsaSecp256r1& operator=(BlackBoxFuncCall_EcdsaSecp256r1&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlackBoxFuncCall_EcdsaSecp256r1& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlackBoxFuncCall_EcdsaSecp256r1* internal_default_instance() {
    return reinterpret_cast<const BlackBoxFuncCall_EcdsaSecp256r1*>(
        &_BlackBoxFuncCall_EcdsaSecp256r1_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(BlackBoxFuncCall_EcdsaSecp256r1& a, BlackBoxFuncCall_EcdsaSecp256r1& b) { a.Swap(&b); }
  inline void Swap(BlackBoxFuncCall_EcdsaSecp256r1* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlackBoxFuncCall_EcdsaSecp256r1* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlackBoxFuncCall_EcdsaSecp256r1* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BlackBoxFuncCall_EcdsaSecp256r1>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlackBoxFuncCall_EcdsaSecp256r1& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlackBoxFuncCall_EcdsaSecp256r1& from) { BlackBoxFuncCall_EcdsaSecp256r1::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BlackBoxFuncCall_EcdsaSecp256r1* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256r1"; }

 protected:
  explicit BlackBoxFuncCall_EcdsaSecp256r1(::google::protobuf::Arena* arena);
  BlackBoxFuncCall_EcdsaSecp256r1(::google::protobuf::Arena* arena, const BlackBoxFuncCall_EcdsaSecp256r1& from);
  BlackBoxFuncCall_EcdsaSecp256r1(::google::protobuf::Arena* arena, BlackBoxFuncCall_EcdsaSecp256r1&& from) noexcept
      : BlackBoxFuncCall_EcdsaSecp256r1(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPublicKeyXFieldNumber = 1,
    kPublicKeyYFieldNumber = 2,
    kSignatureFieldNumber = 3,
    kHashedMessageFieldNumber = 4,
    kOutputFieldNumber = 5,
  };
  // repeated .acvm.acir.circuit.FunctionInput public_key_x = 1;
  int public_key_x_size() const;
  private:
  int _internal_public_key_x_size() const;

  public:
  void clear_public_key_x() ;
  ::acvm::acir::circuit::FunctionInput* mutable_public_key_x(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* mutable_public_key_x();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& _internal_public_key_x() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* _internal_mutable_public_key_x();
  public:
  const ::acvm::acir::circuit::FunctionInput& public_key_x(int index) const;
  ::acvm::acir::circuit::FunctionInput* add_public_key_x();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& public_key_x() const;
  // repeated .acvm.acir.circuit.FunctionInput public_key_y = 2;
  int public_key_y_size() const;
  private:
  int _internal_public_key_y_size() const;

  public:
  void clear_public_key_y() ;
  ::acvm::acir::circuit::FunctionInput* mutable_public_key_y(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* mutable_public_key_y();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& _internal_public_key_y() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* _internal_mutable_public_key_y();
  public:
  const ::acvm::acir::circuit::FunctionInput& public_key_y(int index) const;
  ::acvm::acir::circuit::FunctionInput* add_public_key_y();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& public_key_y() const;
  // repeated .acvm.acir.circuit.FunctionInput signature = 3;
  int signature_size() const;
  private:
  int _internal_signature_size() const;

  public:
  void clear_signature() ;
  ::acvm::acir::circuit::FunctionInput* mutable_signature(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* mutable_signature();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& _internal_signature() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* _internal_mutable_signature();
  public:
  const ::acvm::acir::circuit::FunctionInput& signature(int index) const;
  ::acvm::acir::circuit::FunctionInput* add_signature();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& signature() const;
  // repeated .acvm.acir.circuit.FunctionInput hashed_message = 4;
  int hashed_message_size() const;
  private:
  int _internal_hashed_message_size() const;

  public:
  void clear_hashed_message() ;
  ::acvm::acir::circuit::FunctionInput* mutable_hashed_message(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* mutable_hashed_message();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& _internal_hashed_message() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* _internal_mutable_hashed_message();
  public:
  const ::acvm::acir::circuit::FunctionInput& hashed_message(int index) const;
  ::acvm::acir::circuit::FunctionInput* add_hashed_message();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& hashed_message() const;
  // .acvm.acir.native.Witness output = 5;
  bool has_output() const;
  void clear_output() ;
  const ::acvm::acir::native::Witness& output() const;
  PROTOBUF_NODISCARD ::acvm::acir::native::Witness* release_output();
  ::acvm::acir::native::Witness* mutable_output();
  void set_allocated_output(::acvm::acir::native::Witness* value);
  void unsafe_arena_set_allocated_output(::acvm::acir::native::Witness* value);
  ::acvm::acir::native::Witness* unsafe_arena_release_output();

  private:
  const ::acvm::acir::native::Witness& _internal_output() const;
  ::acvm::acir::native::Witness* _internal_mutable_output();

  public:
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256r1)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 5,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BlackBoxFuncCall_EcdsaSecp256r1& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::circuit::FunctionInput > public_key_x_;
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::circuit::FunctionInput > public_key_y_;
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::circuit::FunctionInput > signature_;
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::circuit::FunctionInput > hashed_message_;
    ::acvm::acir::native::Witness* output_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class BlackBoxFuncCall_EcdsaSecp256k1 final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256k1) */ {
 public:
  inline BlackBoxFuncCall_EcdsaSecp256k1() : BlackBoxFuncCall_EcdsaSecp256k1(nullptr) {}
  ~BlackBoxFuncCall_EcdsaSecp256k1() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlackBoxFuncCall_EcdsaSecp256k1* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlackBoxFuncCall_EcdsaSecp256k1));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlackBoxFuncCall_EcdsaSecp256k1(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlackBoxFuncCall_EcdsaSecp256k1(const BlackBoxFuncCall_EcdsaSecp256k1& from) : BlackBoxFuncCall_EcdsaSecp256k1(nullptr, from) {}
  inline BlackBoxFuncCall_EcdsaSecp256k1(BlackBoxFuncCall_EcdsaSecp256k1&& from) noexcept
      : BlackBoxFuncCall_EcdsaSecp256k1(nullptr, std::move(from)) {}
  inline BlackBoxFuncCall_EcdsaSecp256k1& operator=(const BlackBoxFuncCall_EcdsaSecp256k1& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlackBoxFuncCall_EcdsaSecp256k1& operator=(BlackBoxFuncCall_EcdsaSecp256k1&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlackBoxFuncCall_EcdsaSecp256k1& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlackBoxFuncCall_EcdsaSecp256k1* internal_default_instance() {
    return reinterpret_cast<const BlackBoxFuncCall_EcdsaSecp256k1*>(
        &_BlackBoxFuncCall_EcdsaSecp256k1_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(BlackBoxFuncCall_EcdsaSecp256k1& a, BlackBoxFuncCall_EcdsaSecp256k1& b) { a.Swap(&b); }
  inline void Swap(BlackBoxFuncCall_EcdsaSecp256k1* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlackBoxFuncCall_EcdsaSecp256k1* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlackBoxFuncCall_EcdsaSecp256k1* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BlackBoxFuncCall_EcdsaSecp256k1>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlackBoxFuncCall_EcdsaSecp256k1& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlackBoxFuncCall_EcdsaSecp256k1& from) { BlackBoxFuncCall_EcdsaSecp256k1::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BlackBoxFuncCall_EcdsaSecp256k1* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256k1"; }

 protected:
  explicit BlackBoxFuncCall_EcdsaSecp256k1(::google::protobuf::Arena* arena);
  BlackBoxFuncCall_EcdsaSecp256k1(::google::protobuf::Arena* arena, const BlackBoxFuncCall_EcdsaSecp256k1& from);
  BlackBoxFuncCall_EcdsaSecp256k1(::google::protobuf::Arena* arena, BlackBoxFuncCall_EcdsaSecp256k1&& from) noexcept
      : BlackBoxFuncCall_EcdsaSecp256k1(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPublicKeyXFieldNumber = 1,
    kPublicKeyYFieldNumber = 2,
    kSignatureFieldNumber = 3,
    kHashedMessageFieldNumber = 4,
    kOutputFieldNumber = 5,
  };
  // repeated .acvm.acir.circuit.FunctionInput public_key_x = 1;
  int public_key_x_size() const;
  private:
  int _internal_public_key_x_size() const;

  public:
  void clear_public_key_x() ;
  ::acvm::acir::circuit::FunctionInput* mutable_public_key_x(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* mutable_public_key_x();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& _internal_public_key_x() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* _internal_mutable_public_key_x();
  public:
  const ::acvm::acir::circuit::FunctionInput& public_key_x(int index) const;
  ::acvm::acir::circuit::FunctionInput* add_public_key_x();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& public_key_x() const;
  // repeated .acvm.acir.circuit.FunctionInput public_key_y = 2;
  int public_key_y_size() const;
  private:
  int _internal_public_key_y_size() const;

  public:
  void clear_public_key_y() ;
  ::acvm::acir::circuit::FunctionInput* mutable_public_key_y(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* mutable_public_key_y();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& _internal_public_key_y() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* _internal_mutable_public_key_y();
  public:
  const ::acvm::acir::circuit::FunctionInput& public_key_y(int index) const;
  ::acvm::acir::circuit::FunctionInput* add_public_key_y();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& public_key_y() const;
  // repeated .acvm.acir.circuit.FunctionInput signature = 3;
  int signature_size() const;
  private:
  int _internal_signature_size() const;

  public:
  void clear_signature() ;
  ::acvm::acir::circuit::FunctionInput* mutable_signature(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* mutable_signature();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& _internal_signature() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* _internal_mutable_signature();
  public:
  const ::acvm::acir::circuit::FunctionInput& signature(int index) const;
  ::acvm::acir::circuit::FunctionInput* add_signature();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& signature() const;
  // repeated .acvm.acir.circuit.FunctionInput hashed_message = 4;
  int hashed_message_size() const;
  private:
  int _internal_hashed_message_size() const;

  public:
  void clear_hashed_message() ;
  ::acvm::acir::circuit::FunctionInput* mutable_hashed_message(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* mutable_hashed_message();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& _internal_hashed_message() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* _internal_mutable_hashed_message();
  public:
  const ::acvm::acir::circuit::FunctionInput& hashed_message(int index) const;
  ::acvm::acir::circuit::FunctionInput* add_hashed_message();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& hashed_message() const;
  // .acvm.acir.native.Witness output = 5;
  bool has_output() const;
  void clear_output() ;
  const ::acvm::acir::native::Witness& output() const;
  PROTOBUF_NODISCARD ::acvm::acir::native::Witness* release_output();
  ::acvm::acir::native::Witness* mutable_output();
  void set_allocated_output(::acvm::acir::native::Witness* value);
  void unsafe_arena_set_allocated_output(::acvm::acir::native::Witness* value);
  ::acvm::acir::native::Witness* unsafe_arena_release_output();

  private:
  const ::acvm::acir::native::Witness& _internal_output() const;
  ::acvm::acir::native::Witness* _internal_mutable_output();

  public:
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256k1)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 5,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BlackBoxFuncCall_EcdsaSecp256k1& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::circuit::FunctionInput > public_key_x_;
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::circuit::FunctionInput > public_key_y_;
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::circuit::FunctionInput > signature_;
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::circuit::FunctionInput > hashed_message_;
    ::acvm::acir::native::Witness* output_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class BlackBoxFuncCall_Blake3 final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.BlackBoxFuncCall.Blake3) */ {
 public:
  inline BlackBoxFuncCall_Blake3() : BlackBoxFuncCall_Blake3(nullptr) {}
  ~BlackBoxFuncCall_Blake3() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlackBoxFuncCall_Blake3* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlackBoxFuncCall_Blake3));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlackBoxFuncCall_Blake3(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlackBoxFuncCall_Blake3(const BlackBoxFuncCall_Blake3& from) : BlackBoxFuncCall_Blake3(nullptr, from) {}
  inline BlackBoxFuncCall_Blake3(BlackBoxFuncCall_Blake3&& from) noexcept
      : BlackBoxFuncCall_Blake3(nullptr, std::move(from)) {}
  inline BlackBoxFuncCall_Blake3& operator=(const BlackBoxFuncCall_Blake3& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlackBoxFuncCall_Blake3& operator=(BlackBoxFuncCall_Blake3&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlackBoxFuncCall_Blake3& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlackBoxFuncCall_Blake3* internal_default_instance() {
    return reinterpret_cast<const BlackBoxFuncCall_Blake3*>(
        &_BlackBoxFuncCall_Blake3_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(BlackBoxFuncCall_Blake3& a, BlackBoxFuncCall_Blake3& b) { a.Swap(&b); }
  inline void Swap(BlackBoxFuncCall_Blake3* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlackBoxFuncCall_Blake3* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlackBoxFuncCall_Blake3* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BlackBoxFuncCall_Blake3>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlackBoxFuncCall_Blake3& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlackBoxFuncCall_Blake3& from) { BlackBoxFuncCall_Blake3::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BlackBoxFuncCall_Blake3* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.BlackBoxFuncCall.Blake3"; }

 protected:
  explicit BlackBoxFuncCall_Blake3(::google::protobuf::Arena* arena);
  BlackBoxFuncCall_Blake3(::google::protobuf::Arena* arena, const BlackBoxFuncCall_Blake3& from);
  BlackBoxFuncCall_Blake3(::google::protobuf::Arena* arena, BlackBoxFuncCall_Blake3&& from) noexcept
      : BlackBoxFuncCall_Blake3(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInputsFieldNumber = 1,
    kOutputsFieldNumber = 2,
  };
  // repeated .acvm.acir.circuit.FunctionInput inputs = 1;
  int inputs_size() const;
  private:
  int _internal_inputs_size() const;

  public:
  void clear_inputs() ;
  ::acvm::acir::circuit::FunctionInput* mutable_inputs(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* mutable_inputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& _internal_inputs() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* _internal_mutable_inputs();
  public:
  const ::acvm::acir::circuit::FunctionInput& inputs(int index) const;
  ::acvm::acir::circuit::FunctionInput* add_inputs();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& inputs() const;
  // repeated .acvm.acir.native.Witness outputs = 2;
  int outputs_size() const;
  private:
  int _internal_outputs_size() const;

  public:
  void clear_outputs() ;
  ::acvm::acir::native::Witness* mutable_outputs(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* mutable_outputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& _internal_outputs() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* _internal_mutable_outputs();
  public:
  const ::acvm::acir::native::Witness& outputs(int index) const;
  ::acvm::acir::native::Witness* add_outputs();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& outputs() const;
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.BlackBoxFuncCall.Blake3)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BlackBoxFuncCall_Blake3& from_msg);
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::circuit::FunctionInput > inputs_;
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::native::Witness > outputs_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class BlackBoxFuncCall_Blake2s final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.BlackBoxFuncCall.Blake2s) */ {
 public:
  inline BlackBoxFuncCall_Blake2s() : BlackBoxFuncCall_Blake2s(nullptr) {}
  ~BlackBoxFuncCall_Blake2s() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlackBoxFuncCall_Blake2s* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlackBoxFuncCall_Blake2s));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlackBoxFuncCall_Blake2s(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlackBoxFuncCall_Blake2s(const BlackBoxFuncCall_Blake2s& from) : BlackBoxFuncCall_Blake2s(nullptr, from) {}
  inline BlackBoxFuncCall_Blake2s(BlackBoxFuncCall_Blake2s&& from) noexcept
      : BlackBoxFuncCall_Blake2s(nullptr, std::move(from)) {}
  inline BlackBoxFuncCall_Blake2s& operator=(const BlackBoxFuncCall_Blake2s& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlackBoxFuncCall_Blake2s& operator=(BlackBoxFuncCall_Blake2s&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlackBoxFuncCall_Blake2s& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlackBoxFuncCall_Blake2s* internal_default_instance() {
    return reinterpret_cast<const BlackBoxFuncCall_Blake2s*>(
        &_BlackBoxFuncCall_Blake2s_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(BlackBoxFuncCall_Blake2s& a, BlackBoxFuncCall_Blake2s& b) { a.Swap(&b); }
  inline void Swap(BlackBoxFuncCall_Blake2s* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlackBoxFuncCall_Blake2s* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlackBoxFuncCall_Blake2s* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BlackBoxFuncCall_Blake2s>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlackBoxFuncCall_Blake2s& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlackBoxFuncCall_Blake2s& from) { BlackBoxFuncCall_Blake2s::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BlackBoxFuncCall_Blake2s* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.BlackBoxFuncCall.Blake2s"; }

 protected:
  explicit BlackBoxFuncCall_Blake2s(::google::protobuf::Arena* arena);
  BlackBoxFuncCall_Blake2s(::google::protobuf::Arena* arena, const BlackBoxFuncCall_Blake2s& from);
  BlackBoxFuncCall_Blake2s(::google::protobuf::Arena* arena, BlackBoxFuncCall_Blake2s&& from) noexcept
      : BlackBoxFuncCall_Blake2s(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInputsFieldNumber = 1,
    kOutputsFieldNumber = 2,
  };
  // repeated .acvm.acir.circuit.FunctionInput inputs = 1;
  int inputs_size() const;
  private:
  int _internal_inputs_size() const;

  public:
  void clear_inputs() ;
  ::acvm::acir::circuit::FunctionInput* mutable_inputs(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* mutable_inputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& _internal_inputs() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* _internal_mutable_inputs();
  public:
  const ::acvm::acir::circuit::FunctionInput& inputs(int index) const;
  ::acvm::acir::circuit::FunctionInput* add_inputs();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& inputs() const;
  // repeated .acvm.acir.native.Witness outputs = 2;
  int outputs_size() const;
  private:
  int _internal_outputs_size() const;

  public:
  void clear_outputs() ;
  ::acvm::acir::native::Witness* mutable_outputs(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* mutable_outputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& _internal_outputs() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* _internal_mutable_outputs();
  public:
  const ::acvm::acir::native::Witness& outputs(int index) const;
  ::acvm::acir::native::Witness* add_outputs();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& outputs() const;
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.BlackBoxFuncCall.Blake2s)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BlackBoxFuncCall_Blake2s& from_msg);
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::circuit::FunctionInput > inputs_;
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::native::Witness > outputs_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class BlackBoxFuncCall_BigIntFromLeBytes final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.BlackBoxFuncCall.BigIntFromLeBytes) */ {
 public:
  inline BlackBoxFuncCall_BigIntFromLeBytes() : BlackBoxFuncCall_BigIntFromLeBytes(nullptr) {}
  ~BlackBoxFuncCall_BigIntFromLeBytes() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlackBoxFuncCall_BigIntFromLeBytes* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlackBoxFuncCall_BigIntFromLeBytes));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlackBoxFuncCall_BigIntFromLeBytes(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlackBoxFuncCall_BigIntFromLeBytes(const BlackBoxFuncCall_BigIntFromLeBytes& from) : BlackBoxFuncCall_BigIntFromLeBytes(nullptr, from) {}
  inline BlackBoxFuncCall_BigIntFromLeBytes(BlackBoxFuncCall_BigIntFromLeBytes&& from) noexcept
      : BlackBoxFuncCall_BigIntFromLeBytes(nullptr, std::move(from)) {}
  inline BlackBoxFuncCall_BigIntFromLeBytes& operator=(const BlackBoxFuncCall_BigIntFromLeBytes& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlackBoxFuncCall_BigIntFromLeBytes& operator=(BlackBoxFuncCall_BigIntFromLeBytes&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlackBoxFuncCall_BigIntFromLeBytes& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlackBoxFuncCall_BigIntFromLeBytes* internal_default_instance() {
    return reinterpret_cast<const BlackBoxFuncCall_BigIntFromLeBytes*>(
        &_BlackBoxFuncCall_BigIntFromLeBytes_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 30;
  friend void swap(BlackBoxFuncCall_BigIntFromLeBytes& a, BlackBoxFuncCall_BigIntFromLeBytes& b) { a.Swap(&b); }
  inline void Swap(BlackBoxFuncCall_BigIntFromLeBytes* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlackBoxFuncCall_BigIntFromLeBytes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlackBoxFuncCall_BigIntFromLeBytes* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BlackBoxFuncCall_BigIntFromLeBytes>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlackBoxFuncCall_BigIntFromLeBytes& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlackBoxFuncCall_BigIntFromLeBytes& from) { BlackBoxFuncCall_BigIntFromLeBytes::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BlackBoxFuncCall_BigIntFromLeBytes* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.BlackBoxFuncCall.BigIntFromLeBytes"; }

 protected:
  explicit BlackBoxFuncCall_BigIntFromLeBytes(::google::protobuf::Arena* arena);
  BlackBoxFuncCall_BigIntFromLeBytes(::google::protobuf::Arena* arena, const BlackBoxFuncCall_BigIntFromLeBytes& from);
  BlackBoxFuncCall_BigIntFromLeBytes(::google::protobuf::Arena* arena, BlackBoxFuncCall_BigIntFromLeBytes&& from) noexcept
      : BlackBoxFuncCall_BigIntFromLeBytes(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInputsFieldNumber = 1,
    kModulusFieldNumber = 2,
    kOutputFieldNumber = 3,
  };
  // repeated .acvm.acir.circuit.FunctionInput inputs = 1;
  int inputs_size() const;
  private:
  int _internal_inputs_size() const;

  public:
  void clear_inputs() ;
  ::acvm::acir::circuit::FunctionInput* mutable_inputs(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* mutable_inputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& _internal_inputs() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* _internal_mutable_inputs();
  public:
  const ::acvm::acir::circuit::FunctionInput& inputs(int index) const;
  ::acvm::acir::circuit::FunctionInput* add_inputs();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& inputs() const;
  // bytes modulus = 2;
  void clear_modulus() ;
  const std::string& modulus() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_modulus(Arg_&& arg, Args_... args);
  std::string* mutable_modulus();
  PROTOBUF_NODISCARD std::string* release_modulus();
  void set_allocated_modulus(std::string* value);

  private:
  const std::string& _internal_modulus() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modulus(
      const std::string& value);
  std::string* _internal_mutable_modulus();

  public:
  // uint32 output = 3;
  void clear_output() ;
  ::uint32_t output() const;
  void set_output(::uint32_t value);

  private:
  ::uint32_t _internal_output() const;
  void _internal_set_output(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.BlackBoxFuncCall.BigIntFromLeBytes)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BlackBoxFuncCall_BigIntFromLeBytes& from_msg);
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::circuit::FunctionInput > inputs_;
    ::google::protobuf::internal::ArenaStringPtr modulus_;
    ::uint32_t output_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class BlackBoxFuncCall_AND final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.BlackBoxFuncCall.AND) */ {
 public:
  inline BlackBoxFuncCall_AND() : BlackBoxFuncCall_AND(nullptr) {}
  ~BlackBoxFuncCall_AND() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlackBoxFuncCall_AND* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlackBoxFuncCall_AND));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlackBoxFuncCall_AND(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlackBoxFuncCall_AND(const BlackBoxFuncCall_AND& from) : BlackBoxFuncCall_AND(nullptr, from) {}
  inline BlackBoxFuncCall_AND(BlackBoxFuncCall_AND&& from) noexcept
      : BlackBoxFuncCall_AND(nullptr, std::move(from)) {}
  inline BlackBoxFuncCall_AND& operator=(const BlackBoxFuncCall_AND& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlackBoxFuncCall_AND& operator=(BlackBoxFuncCall_AND&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlackBoxFuncCall_AND& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlackBoxFuncCall_AND* internal_default_instance() {
    return reinterpret_cast<const BlackBoxFuncCall_AND*>(
        &_BlackBoxFuncCall_AND_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(BlackBoxFuncCall_AND& a, BlackBoxFuncCall_AND& b) { a.Swap(&b); }
  inline void Swap(BlackBoxFuncCall_AND* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlackBoxFuncCall_AND* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlackBoxFuncCall_AND* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BlackBoxFuncCall_AND>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlackBoxFuncCall_AND& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlackBoxFuncCall_AND& from) { BlackBoxFuncCall_AND::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BlackBoxFuncCall_AND* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.BlackBoxFuncCall.AND"; }

 protected:
  explicit BlackBoxFuncCall_AND(::google::protobuf::Arena* arena);
  BlackBoxFuncCall_AND(::google::protobuf::Arena* arena, const BlackBoxFuncCall_AND& from);
  BlackBoxFuncCall_AND(::google::protobuf::Arena* arena, BlackBoxFuncCall_AND&& from) noexcept
      : BlackBoxFuncCall_AND(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLhsFieldNumber = 1,
    kRhsFieldNumber = 2,
    kOutputFieldNumber = 3,
  };
  // .acvm.acir.circuit.FunctionInput lhs = 1;
  bool has_lhs() const;
  void clear_lhs() ;
  const ::acvm::acir::circuit::FunctionInput& lhs() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::FunctionInput* release_lhs();
  ::acvm::acir::circuit::FunctionInput* mutable_lhs();
  void set_allocated_lhs(::acvm::acir::circuit::FunctionInput* value);
  void unsafe_arena_set_allocated_lhs(::acvm::acir::circuit::FunctionInput* value);
  ::acvm::acir::circuit::FunctionInput* unsafe_arena_release_lhs();

  private:
  const ::acvm::acir::circuit::FunctionInput& _internal_lhs() const;
  ::acvm::acir::circuit::FunctionInput* _internal_mutable_lhs();

  public:
  // .acvm.acir.circuit.FunctionInput rhs = 2;
  bool has_rhs() const;
  void clear_rhs() ;
  const ::acvm::acir::circuit::FunctionInput& rhs() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::FunctionInput* release_rhs();
  ::acvm::acir::circuit::FunctionInput* mutable_rhs();
  void set_allocated_rhs(::acvm::acir::circuit::FunctionInput* value);
  void unsafe_arena_set_allocated_rhs(::acvm::acir::circuit::FunctionInput* value);
  ::acvm::acir::circuit::FunctionInput* unsafe_arena_release_rhs();

  private:
  const ::acvm::acir::circuit::FunctionInput& _internal_rhs() const;
  ::acvm::acir::circuit::FunctionInput* _internal_mutable_rhs();

  public:
  // .acvm.acir.native.Witness output = 3;
  bool has_output() const;
  void clear_output() ;
  const ::acvm::acir::native::Witness& output() const;
  PROTOBUF_NODISCARD ::acvm::acir::native::Witness* release_output();
  ::acvm::acir::native::Witness* mutable_output();
  void set_allocated_output(::acvm::acir::native::Witness* value);
  void unsafe_arena_set_allocated_output(::acvm::acir::native::Witness* value);
  ::acvm::acir::native::Witness* unsafe_arena_release_output();

  private:
  const ::acvm::acir::native::Witness& _internal_output() const;
  ::acvm::acir::native::Witness* _internal_mutable_output();

  public:
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.BlackBoxFuncCall.AND)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BlackBoxFuncCall_AND& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::acvm::acir::circuit::FunctionInput* lhs_;
    ::acvm::acir::circuit::FunctionInput* rhs_;
    ::acvm::acir::native::Witness* output_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class BlackBoxFuncCall_AES128Encrypt final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.BlackBoxFuncCall.AES128Encrypt) */ {
 public:
  inline BlackBoxFuncCall_AES128Encrypt() : BlackBoxFuncCall_AES128Encrypt(nullptr) {}
  ~BlackBoxFuncCall_AES128Encrypt() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlackBoxFuncCall_AES128Encrypt* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlackBoxFuncCall_AES128Encrypt));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlackBoxFuncCall_AES128Encrypt(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlackBoxFuncCall_AES128Encrypt(const BlackBoxFuncCall_AES128Encrypt& from) : BlackBoxFuncCall_AES128Encrypt(nullptr, from) {}
  inline BlackBoxFuncCall_AES128Encrypt(BlackBoxFuncCall_AES128Encrypt&& from) noexcept
      : BlackBoxFuncCall_AES128Encrypt(nullptr, std::move(from)) {}
  inline BlackBoxFuncCall_AES128Encrypt& operator=(const BlackBoxFuncCall_AES128Encrypt& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlackBoxFuncCall_AES128Encrypt& operator=(BlackBoxFuncCall_AES128Encrypt&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlackBoxFuncCall_AES128Encrypt& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlackBoxFuncCall_AES128Encrypt* internal_default_instance() {
    return reinterpret_cast<const BlackBoxFuncCall_AES128Encrypt*>(
        &_BlackBoxFuncCall_AES128Encrypt_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(BlackBoxFuncCall_AES128Encrypt& a, BlackBoxFuncCall_AES128Encrypt& b) { a.Swap(&b); }
  inline void Swap(BlackBoxFuncCall_AES128Encrypt* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlackBoxFuncCall_AES128Encrypt* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlackBoxFuncCall_AES128Encrypt* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BlackBoxFuncCall_AES128Encrypt>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlackBoxFuncCall_AES128Encrypt& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlackBoxFuncCall_AES128Encrypt& from) { BlackBoxFuncCall_AES128Encrypt::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BlackBoxFuncCall_AES128Encrypt* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.BlackBoxFuncCall.AES128Encrypt"; }

 protected:
  explicit BlackBoxFuncCall_AES128Encrypt(::google::protobuf::Arena* arena);
  BlackBoxFuncCall_AES128Encrypt(::google::protobuf::Arena* arena, const BlackBoxFuncCall_AES128Encrypt& from);
  BlackBoxFuncCall_AES128Encrypt(::google::protobuf::Arena* arena, BlackBoxFuncCall_AES128Encrypt&& from) noexcept
      : BlackBoxFuncCall_AES128Encrypt(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInputsFieldNumber = 1,
    kIvFieldNumber = 2,
    kKeyFieldNumber = 3,
    kOutputsFieldNumber = 4,
  };
  // repeated .acvm.acir.circuit.FunctionInput inputs = 1;
  int inputs_size() const;
  private:
  int _internal_inputs_size() const;

  public:
  void clear_inputs() ;
  ::acvm::acir::circuit::FunctionInput* mutable_inputs(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* mutable_inputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& _internal_inputs() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* _internal_mutable_inputs();
  public:
  const ::acvm::acir::circuit::FunctionInput& inputs(int index) const;
  ::acvm::acir::circuit::FunctionInput* add_inputs();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& inputs() const;
  // repeated .acvm.acir.circuit.FunctionInput iv = 2;
  int iv_size() const;
  private:
  int _internal_iv_size() const;

  public:
  void clear_iv() ;
  ::acvm::acir::circuit::FunctionInput* mutable_iv(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* mutable_iv();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& _internal_iv() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* _internal_mutable_iv();
  public:
  const ::acvm::acir::circuit::FunctionInput& iv(int index) const;
  ::acvm::acir::circuit::FunctionInput* add_iv();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& iv() const;
  // repeated .acvm.acir.circuit.FunctionInput key = 3;
  int key_size() const;
  private:
  int _internal_key_size() const;

  public:
  void clear_key() ;
  ::acvm::acir::circuit::FunctionInput* mutable_key(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* mutable_key();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& _internal_key() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* _internal_mutable_key();
  public:
  const ::acvm::acir::circuit::FunctionInput& key(int index) const;
  ::acvm::acir::circuit::FunctionInput* add_key();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& key() const;
  // repeated .acvm.acir.native.Witness outputs = 4;
  int outputs_size() const;
  private:
  int _internal_outputs_size() const;

  public:
  void clear_outputs() ;
  ::acvm::acir::native::Witness* mutable_outputs(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* mutable_outputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& _internal_outputs() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* _internal_mutable_outputs();
  public:
  const ::acvm::acir::native::Witness& outputs(int index) const;
  ::acvm::acir::native::Witness* add_outputs();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& outputs() const;
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.BlackBoxFuncCall.AES128Encrypt)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BlackBoxFuncCall_AES128Encrypt& from_msg);
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::circuit::FunctionInput > inputs_;
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::circuit::FunctionInput > iv_;
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::circuit::FunctionInput > key_;
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::native::Witness > outputs_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class Opcode_MemoryOp final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.Opcode.MemoryOp) */ {
 public:
  inline Opcode_MemoryOp() : Opcode_MemoryOp(nullptr) {}
  ~Opcode_MemoryOp() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Opcode_MemoryOp* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Opcode_MemoryOp));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Opcode_MemoryOp(
      ::google::protobuf::internal::ConstantInitialized);

  inline Opcode_MemoryOp(const Opcode_MemoryOp& from) : Opcode_MemoryOp(nullptr, from) {}
  inline Opcode_MemoryOp(Opcode_MemoryOp&& from) noexcept
      : Opcode_MemoryOp(nullptr, std::move(from)) {}
  inline Opcode_MemoryOp& operator=(const Opcode_MemoryOp& from) {
    CopyFrom(from);
    return *this;
  }
  inline Opcode_MemoryOp& operator=(Opcode_MemoryOp&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Opcode_MemoryOp& default_instance() {
    return *internal_default_instance();
  }
  static inline const Opcode_MemoryOp* internal_default_instance() {
    return reinterpret_cast<const Opcode_MemoryOp*>(
        &_Opcode_MemoryOp_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(Opcode_MemoryOp& a, Opcode_MemoryOp& b) { a.Swap(&b); }
  inline void Swap(Opcode_MemoryOp* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Opcode_MemoryOp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Opcode_MemoryOp* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Opcode_MemoryOp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Opcode_MemoryOp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Opcode_MemoryOp& from) { Opcode_MemoryOp::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Opcode_MemoryOp* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.Opcode.MemoryOp"; }

 protected:
  explicit Opcode_MemoryOp(::google::protobuf::Arena* arena);
  Opcode_MemoryOp(::google::protobuf::Arena* arena, const Opcode_MemoryOp& from);
  Opcode_MemoryOp(::google::protobuf::Arena* arena, Opcode_MemoryOp&& from) noexcept
      : Opcode_MemoryOp(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOpFieldNumber = 2,
    kPredicateFieldNumber = 3,
    kBlockIdFieldNumber = 1,
  };
  // .acvm.acir.circuit.MemOp op = 2;
  bool has_op() const;
  void clear_op() ;
  const ::acvm::acir::circuit::MemOp& op() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::MemOp* release_op();
  ::acvm::acir::circuit::MemOp* mutable_op();
  void set_allocated_op(::acvm::acir::circuit::MemOp* value);
  void unsafe_arena_set_allocated_op(::acvm::acir::circuit::MemOp* value);
  ::acvm::acir::circuit::MemOp* unsafe_arena_release_op();

  private:
  const ::acvm::acir::circuit::MemOp& _internal_op() const;
  ::acvm::acir::circuit::MemOp* _internal_mutable_op();

  public:
  // optional .acvm.acir.native.Expression predicate = 3;
  bool has_predicate() const;
  void clear_predicate() ;
  const ::acvm::acir::native::Expression& predicate() const;
  PROTOBUF_NODISCARD ::acvm::acir::native::Expression* release_predicate();
  ::acvm::acir::native::Expression* mutable_predicate();
  void set_allocated_predicate(::acvm::acir::native::Expression* value);
  void unsafe_arena_set_allocated_predicate(::acvm::acir::native::Expression* value);
  ::acvm::acir::native::Expression* unsafe_arena_release_predicate();

  private:
  const ::acvm::acir::native::Expression& _internal_predicate() const;
  ::acvm::acir::native::Expression* _internal_mutable_predicate();

  public:
  // uint32 block_id = 1;
  void clear_block_id() ;
  ::uint32_t block_id() const;
  void set_block_id(::uint32_t value);

  private:
  ::uint32_t _internal_block_id() const;
  void _internal_set_block_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.Opcode.MemoryOp)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Opcode_MemoryOp& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::acvm::acir::circuit::MemOp* op_;
    ::acvm::acir::native::Expression* predicate_;
    ::uint32_t block_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class BrilligInputs final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.BrilligInputs) */ {
 public:
  inline BrilligInputs() : BrilligInputs(nullptr) {}
  ~BrilligInputs() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BrilligInputs* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BrilligInputs));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BrilligInputs(
      ::google::protobuf::internal::ConstantInitialized);

  inline BrilligInputs(const BrilligInputs& from) : BrilligInputs(nullptr, from) {}
  inline BrilligInputs(BrilligInputs&& from) noexcept
      : BrilligInputs(nullptr, std::move(from)) {}
  inline BrilligInputs& operator=(const BrilligInputs& from) {
    CopyFrom(from);
    return *this;
  }
  inline BrilligInputs& operator=(BrilligInputs&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BrilligInputs& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kSingle = 1,
    kArray = 2,
    kMemoryArray = 3,
    VALUE_NOT_SET = 0,
  };
  static inline const BrilligInputs* internal_default_instance() {
    return reinterpret_cast<const BrilligInputs*>(
        &_BrilligInputs_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 43;
  friend void swap(BrilligInputs& a, BrilligInputs& b) { a.Swap(&b); }
  inline void Swap(BrilligInputs* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BrilligInputs* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BrilligInputs* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BrilligInputs>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BrilligInputs& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BrilligInputs& from) { BrilligInputs::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BrilligInputs* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.BrilligInputs"; }

 protected:
  explicit BrilligInputs(::google::protobuf::Arena* arena);
  BrilligInputs(::google::protobuf::Arena* arena, const BrilligInputs& from);
  BrilligInputs(::google::protobuf::Arena* arena, BrilligInputs&& from) noexcept
      : BrilligInputs(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Array = BrilligInputs_Array;

  // accessors -------------------------------------------------------
  enum : int {
    kSingleFieldNumber = 1,
    kArrayFieldNumber = 2,
    kMemoryArrayFieldNumber = 3,
  };
  // .acvm.acir.native.Expression single = 1;
  bool has_single() const;
  private:
  bool _internal_has_single() const;

  public:
  void clear_single() ;
  const ::acvm::acir::native::Expression& single() const;
  PROTOBUF_NODISCARD ::acvm::acir::native::Expression* release_single();
  ::acvm::acir::native::Expression* mutable_single();
  void set_allocated_single(::acvm::acir::native::Expression* value);
  void unsafe_arena_set_allocated_single(::acvm::acir::native::Expression* value);
  ::acvm::acir::native::Expression* unsafe_arena_release_single();

  private:
  const ::acvm::acir::native::Expression& _internal_single() const;
  ::acvm::acir::native::Expression* _internal_mutable_single();

  public:
  // .acvm.acir.circuit.BrilligInputs.Array array = 2;
  bool has_array() const;
  private:
  bool _internal_has_array() const;

  public:
  void clear_array() ;
  const ::acvm::acir::circuit::BrilligInputs_Array& array() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::BrilligInputs_Array* release_array();
  ::acvm::acir::circuit::BrilligInputs_Array* mutable_array();
  void set_allocated_array(::acvm::acir::circuit::BrilligInputs_Array* value);
  void unsafe_arena_set_allocated_array(::acvm::acir::circuit::BrilligInputs_Array* value);
  ::acvm::acir::circuit::BrilligInputs_Array* unsafe_arena_release_array();

  private:
  const ::acvm::acir::circuit::BrilligInputs_Array& _internal_array() const;
  ::acvm::acir::circuit::BrilligInputs_Array* _internal_mutable_array();

  public:
  // uint32 memory_array = 3;
  bool has_memory_array() const;
  void clear_memory_array() ;
  ::uint32_t memory_array() const;
  void set_memory_array(::uint32_t value);

  private:
  ::uint32_t _internal_memory_array() const;
  void _internal_set_memory_array(::uint32_t value);

  public:
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.BrilligInputs)
 private:
  class _Internal;
  void set_has_single();
  void set_has_array();
  void set_has_memory_array();
  inline bool has_value() const;
  inline void clear_has_value();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BrilligInputs& from_msg);
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::acvm::acir::native::Expression* single_;
      ::acvm::acir::circuit::BrilligInputs_Array* array_;
      ::uint32_t memory_array_;
    } value_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class BlackBoxFuncCall final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.BlackBoxFuncCall) */ {
 public:
  inline BlackBoxFuncCall() : BlackBoxFuncCall(nullptr) {}
  ~BlackBoxFuncCall() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlackBoxFuncCall* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlackBoxFuncCall));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlackBoxFuncCall(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlackBoxFuncCall(const BlackBoxFuncCall& from) : BlackBoxFuncCall(nullptr, from) {}
  inline BlackBoxFuncCall(BlackBoxFuncCall&& from) noexcept
      : BlackBoxFuncCall(nullptr, std::move(from)) {}
  inline BlackBoxFuncCall& operator=(const BlackBoxFuncCall& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlackBoxFuncCall& operator=(BlackBoxFuncCall&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlackBoxFuncCall& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kAes128Encrypt = 1,
    kAnd = 2,
    kXor = 3,
    kRange = 4,
    kBlake2S = 5,
    kBlake3 = 6,
    kEcdsaSecp256K1 = 7,
    kEcdsaSecp256R1 = 8,
    kMultiScalarMul = 9,
    kEmbeddedCurveAdd = 10,
    kKeccakF1600 = 11,
    kRecursiveAggregation = 12,
    kBigIntAdd = 13,
    kBigIntSub = 14,
    kBigIntMul = 15,
    kBigIntDiv = 16,
    kBigIntFromLeBytes = 17,
    kBigIntToLeBytes = 18,
    kPoseidon2Permutation = 19,
    kSha256Compression = 20,
    VALUE_NOT_SET = 0,
  };
  static inline const BlackBoxFuncCall* internal_default_instance() {
    return reinterpret_cast<const BlackBoxFuncCall*>(
        &_BlackBoxFuncCall_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 34;
  friend void swap(BlackBoxFuncCall& a, BlackBoxFuncCall& b) { a.Swap(&b); }
  inline void Swap(BlackBoxFuncCall* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlackBoxFuncCall* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlackBoxFuncCall* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BlackBoxFuncCall>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlackBoxFuncCall& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlackBoxFuncCall& from) { BlackBoxFuncCall::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BlackBoxFuncCall* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.BlackBoxFuncCall"; }

 protected:
  explicit BlackBoxFuncCall(::google::protobuf::Arena* arena);
  BlackBoxFuncCall(::google::protobuf::Arena* arena, const BlackBoxFuncCall& from);
  BlackBoxFuncCall(::google::protobuf::Arena* arena, BlackBoxFuncCall&& from) noexcept
      : BlackBoxFuncCall(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using AES128Encrypt = BlackBoxFuncCall_AES128Encrypt;
  using AND = BlackBoxFuncCall_AND;
  using XOR = BlackBoxFuncCall_XOR;
  using RANGE = BlackBoxFuncCall_RANGE;
  using Blake2s = BlackBoxFuncCall_Blake2s;
  using Blake3 = BlackBoxFuncCall_Blake3;
  using EcdsaSecp256k1 = BlackBoxFuncCall_EcdsaSecp256k1;
  using EcdsaSecp256r1 = BlackBoxFuncCall_EcdsaSecp256r1;
  using MultiScalarMul = BlackBoxFuncCall_MultiScalarMul;
  using EmbeddedCurveAdd = BlackBoxFuncCall_EmbeddedCurveAdd;
  using Keccakf1600 = BlackBoxFuncCall_Keccakf1600;
  using RecursiveAggregation = BlackBoxFuncCall_RecursiveAggregation;
  using BigIntAdd = BlackBoxFuncCall_BigIntAdd;
  using BigIntSub = BlackBoxFuncCall_BigIntSub;
  using BigIntMul = BlackBoxFuncCall_BigIntMul;
  using BigIntDiv = BlackBoxFuncCall_BigIntDiv;
  using BigIntFromLeBytes = BlackBoxFuncCall_BigIntFromLeBytes;
  using BigIntToLeBytes = BlackBoxFuncCall_BigIntToLeBytes;
  using Poseidon2Permutation = BlackBoxFuncCall_Poseidon2Permutation;
  using Sha256Compression = BlackBoxFuncCall_Sha256Compression;

  // accessors -------------------------------------------------------
  enum : int {
    kAes128EncryptFieldNumber = 1,
    kAndFieldNumber = 2,
    kXorFieldNumber = 3,
    kRangeFieldNumber = 4,
    kBlake2SFieldNumber = 5,
    kBlake3FieldNumber = 6,
    kEcdsaSecp256K1FieldNumber = 7,
    kEcdsaSecp256R1FieldNumber = 8,
    kMultiScalarMulFieldNumber = 9,
    kEmbeddedCurveAddFieldNumber = 10,
    kKeccakF1600FieldNumber = 11,
    kRecursiveAggregationFieldNumber = 12,
    kBigIntAddFieldNumber = 13,
    kBigIntSubFieldNumber = 14,
    kBigIntMulFieldNumber = 15,
    kBigIntDivFieldNumber = 16,
    kBigIntFromLeBytesFieldNumber = 17,
    kBigIntToLeBytesFieldNumber = 18,
    kPoseidon2PermutationFieldNumber = 19,
    kSha256CompressionFieldNumber = 20,
  };
  // .acvm.acir.circuit.BlackBoxFuncCall.AES128Encrypt aes128_encrypt = 1;
  bool has_aes128_encrypt() const;
  private:
  bool _internal_has_aes128_encrypt() const;

  public:
  void clear_aes128_encrypt() ;
  const ::acvm::acir::circuit::BlackBoxFuncCall_AES128Encrypt& aes128_encrypt() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::BlackBoxFuncCall_AES128Encrypt* release_aes128_encrypt();
  ::acvm::acir::circuit::BlackBoxFuncCall_AES128Encrypt* mutable_aes128_encrypt();
  void set_allocated_aes128_encrypt(::acvm::acir::circuit::BlackBoxFuncCall_AES128Encrypt* value);
  void unsafe_arena_set_allocated_aes128_encrypt(::acvm::acir::circuit::BlackBoxFuncCall_AES128Encrypt* value);
  ::acvm::acir::circuit::BlackBoxFuncCall_AES128Encrypt* unsafe_arena_release_aes128_encrypt();

  private:
  const ::acvm::acir::circuit::BlackBoxFuncCall_AES128Encrypt& _internal_aes128_encrypt() const;
  ::acvm::acir::circuit::BlackBoxFuncCall_AES128Encrypt* _internal_mutable_aes128_encrypt();

  public:
  // .acvm.acir.circuit.BlackBoxFuncCall.AND and = 2;
  bool has_and_() const;
  private:
  bool _internal_has_and_() const;

  public:
  void clear_and_() ;
  const ::acvm::acir::circuit::BlackBoxFuncCall_AND& and_() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::BlackBoxFuncCall_AND* release_and_();
  ::acvm::acir::circuit::BlackBoxFuncCall_AND* mutable_and_();
  void set_allocated_and_(::acvm::acir::circuit::BlackBoxFuncCall_AND* value);
  void unsafe_arena_set_allocated_and_(::acvm::acir::circuit::BlackBoxFuncCall_AND* value);
  ::acvm::acir::circuit::BlackBoxFuncCall_AND* unsafe_arena_release_and_();

  private:
  const ::acvm::acir::circuit::BlackBoxFuncCall_AND& _internal_and_() const;
  ::acvm::acir::circuit::BlackBoxFuncCall_AND* _internal_mutable_and_();

  public:
  // .acvm.acir.circuit.BlackBoxFuncCall.XOR xor = 3;
  bool has_xor_() const;
  private:
  bool _internal_has_xor_() const;

  public:
  void clear_xor_() ;
  const ::acvm::acir::circuit::BlackBoxFuncCall_XOR& xor_() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::BlackBoxFuncCall_XOR* release_xor_();
  ::acvm::acir::circuit::BlackBoxFuncCall_XOR* mutable_xor_();
  void set_allocated_xor_(::acvm::acir::circuit::BlackBoxFuncCall_XOR* value);
  void unsafe_arena_set_allocated_xor_(::acvm::acir::circuit::BlackBoxFuncCall_XOR* value);
  ::acvm::acir::circuit::BlackBoxFuncCall_XOR* unsafe_arena_release_xor_();

  private:
  const ::acvm::acir::circuit::BlackBoxFuncCall_XOR& _internal_xor_() const;
  ::acvm::acir::circuit::BlackBoxFuncCall_XOR* _internal_mutable_xor_();

  public:
  // .acvm.acir.circuit.BlackBoxFuncCall.RANGE range = 4;
  bool has_range() const;
  private:
  bool _internal_has_range() const;

  public:
  void clear_range() ;
  const ::acvm::acir::circuit::BlackBoxFuncCall_RANGE& range() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::BlackBoxFuncCall_RANGE* release_range();
  ::acvm::acir::circuit::BlackBoxFuncCall_RANGE* mutable_range();
  void set_allocated_range(::acvm::acir::circuit::BlackBoxFuncCall_RANGE* value);
  void unsafe_arena_set_allocated_range(::acvm::acir::circuit::BlackBoxFuncCall_RANGE* value);
  ::acvm::acir::circuit::BlackBoxFuncCall_RANGE* unsafe_arena_release_range();

  private:
  const ::acvm::acir::circuit::BlackBoxFuncCall_RANGE& _internal_range() const;
  ::acvm::acir::circuit::BlackBoxFuncCall_RANGE* _internal_mutable_range();

  public:
  // .acvm.acir.circuit.BlackBoxFuncCall.Blake2s blake2s = 5;
  bool has_blake2s() const;
  private:
  bool _internal_has_blake2s() const;

  public:
  void clear_blake2s() ;
  const ::acvm::acir::circuit::BlackBoxFuncCall_Blake2s& blake2s() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::BlackBoxFuncCall_Blake2s* release_blake2s();
  ::acvm::acir::circuit::BlackBoxFuncCall_Blake2s* mutable_blake2s();
  void set_allocated_blake2s(::acvm::acir::circuit::BlackBoxFuncCall_Blake2s* value);
  void unsafe_arena_set_allocated_blake2s(::acvm::acir::circuit::BlackBoxFuncCall_Blake2s* value);
  ::acvm::acir::circuit::BlackBoxFuncCall_Blake2s* unsafe_arena_release_blake2s();

  private:
  const ::acvm::acir::circuit::BlackBoxFuncCall_Blake2s& _internal_blake2s() const;
  ::acvm::acir::circuit::BlackBoxFuncCall_Blake2s* _internal_mutable_blake2s();

  public:
  // .acvm.acir.circuit.BlackBoxFuncCall.Blake3 blake3 = 6;
  bool has_blake3() const;
  private:
  bool _internal_has_blake3() const;

  public:
  void clear_blake3() ;
  const ::acvm::acir::circuit::BlackBoxFuncCall_Blake3& blake3() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::BlackBoxFuncCall_Blake3* release_blake3();
  ::acvm::acir::circuit::BlackBoxFuncCall_Blake3* mutable_blake3();
  void set_allocated_blake3(::acvm::acir::circuit::BlackBoxFuncCall_Blake3* value);
  void unsafe_arena_set_allocated_blake3(::acvm::acir::circuit::BlackBoxFuncCall_Blake3* value);
  ::acvm::acir::circuit::BlackBoxFuncCall_Blake3* unsafe_arena_release_blake3();

  private:
  const ::acvm::acir::circuit::BlackBoxFuncCall_Blake3& _internal_blake3() const;
  ::acvm::acir::circuit::BlackBoxFuncCall_Blake3* _internal_mutable_blake3();

  public:
  // .acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256k1 ecdsa_secp256k1 = 7;
  bool has_ecdsa_secp256k1() const;
  private:
  bool _internal_has_ecdsa_secp256k1() const;

  public:
  void clear_ecdsa_secp256k1() ;
  const ::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256k1& ecdsa_secp256k1() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256k1* release_ecdsa_secp256k1();
  ::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256k1* mutable_ecdsa_secp256k1();
  void set_allocated_ecdsa_secp256k1(::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256k1* value);
  void unsafe_arena_set_allocated_ecdsa_secp256k1(::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256k1* value);
  ::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256k1* unsafe_arena_release_ecdsa_secp256k1();

  private:
  const ::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256k1& _internal_ecdsa_secp256k1() const;
  ::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256k1* _internal_mutable_ecdsa_secp256k1();

  public:
  // .acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256r1 ecdsa_secp256r1 = 8;
  bool has_ecdsa_secp256r1() const;
  private:
  bool _internal_has_ecdsa_secp256r1() const;

  public:
  void clear_ecdsa_secp256r1() ;
  const ::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256r1& ecdsa_secp256r1() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256r1* release_ecdsa_secp256r1();
  ::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256r1* mutable_ecdsa_secp256r1();
  void set_allocated_ecdsa_secp256r1(::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256r1* value);
  void unsafe_arena_set_allocated_ecdsa_secp256r1(::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256r1* value);
  ::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256r1* unsafe_arena_release_ecdsa_secp256r1();

  private:
  const ::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256r1& _internal_ecdsa_secp256r1() const;
  ::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256r1* _internal_mutable_ecdsa_secp256r1();

  public:
  // .acvm.acir.circuit.BlackBoxFuncCall.MultiScalarMul multi_scalar_mul = 9;
  bool has_multi_scalar_mul() const;
  private:
  bool _internal_has_multi_scalar_mul() const;

  public:
  void clear_multi_scalar_mul() ;
  const ::acvm::acir::circuit::BlackBoxFuncCall_MultiScalarMul& multi_scalar_mul() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::BlackBoxFuncCall_MultiScalarMul* release_multi_scalar_mul();
  ::acvm::acir::circuit::BlackBoxFuncCall_MultiScalarMul* mutable_multi_scalar_mul();
  void set_allocated_multi_scalar_mul(::acvm::acir::circuit::BlackBoxFuncCall_MultiScalarMul* value);
  void unsafe_arena_set_allocated_multi_scalar_mul(::acvm::acir::circuit::BlackBoxFuncCall_MultiScalarMul* value);
  ::acvm::acir::circuit::BlackBoxFuncCall_MultiScalarMul* unsafe_arena_release_multi_scalar_mul();

  private:
  const ::acvm::acir::circuit::BlackBoxFuncCall_MultiScalarMul& _internal_multi_scalar_mul() const;
  ::acvm::acir::circuit::BlackBoxFuncCall_MultiScalarMul* _internal_mutable_multi_scalar_mul();

  public:
  // .acvm.acir.circuit.BlackBoxFuncCall.EmbeddedCurveAdd embedded_curve_add = 10;
  bool has_embedded_curve_add() const;
  private:
  bool _internal_has_embedded_curve_add() const;

  public:
  void clear_embedded_curve_add() ;
  const ::acvm::acir::circuit::BlackBoxFuncCall_EmbeddedCurveAdd& embedded_curve_add() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::BlackBoxFuncCall_EmbeddedCurveAdd* release_embedded_curve_add();
  ::acvm::acir::circuit::BlackBoxFuncCall_EmbeddedCurveAdd* mutable_embedded_curve_add();
  void set_allocated_embedded_curve_add(::acvm::acir::circuit::BlackBoxFuncCall_EmbeddedCurveAdd* value);
  void unsafe_arena_set_allocated_embedded_curve_add(::acvm::acir::circuit::BlackBoxFuncCall_EmbeddedCurveAdd* value);
  ::acvm::acir::circuit::BlackBoxFuncCall_EmbeddedCurveAdd* unsafe_arena_release_embedded_curve_add();

  private:
  const ::acvm::acir::circuit::BlackBoxFuncCall_EmbeddedCurveAdd& _internal_embedded_curve_add() const;
  ::acvm::acir::circuit::BlackBoxFuncCall_EmbeddedCurveAdd* _internal_mutable_embedded_curve_add();

  public:
  // .acvm.acir.circuit.BlackBoxFuncCall.Keccakf1600 keccak_f1600 = 11;
  bool has_keccak_f1600() const;
  private:
  bool _internal_has_keccak_f1600() const;

  public:
  void clear_keccak_f1600() ;
  const ::acvm::acir::circuit::BlackBoxFuncCall_Keccakf1600& keccak_f1600() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::BlackBoxFuncCall_Keccakf1600* release_keccak_f1600();
  ::acvm::acir::circuit::BlackBoxFuncCall_Keccakf1600* mutable_keccak_f1600();
  void set_allocated_keccak_f1600(::acvm::acir::circuit::BlackBoxFuncCall_Keccakf1600* value);
  void unsafe_arena_set_allocated_keccak_f1600(::acvm::acir::circuit::BlackBoxFuncCall_Keccakf1600* value);
  ::acvm::acir::circuit::BlackBoxFuncCall_Keccakf1600* unsafe_arena_release_keccak_f1600();

  private:
  const ::acvm::acir::circuit::BlackBoxFuncCall_Keccakf1600& _internal_keccak_f1600() const;
  ::acvm::acir::circuit::BlackBoxFuncCall_Keccakf1600* _internal_mutable_keccak_f1600();

  public:
  // .acvm.acir.circuit.BlackBoxFuncCall.RecursiveAggregation recursive_aggregation = 12;
  bool has_recursive_aggregation() const;
  private:
  bool _internal_has_recursive_aggregation() const;

  public:
  void clear_recursive_aggregation() ;
  const ::acvm::acir::circuit::BlackBoxFuncCall_RecursiveAggregation& recursive_aggregation() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::BlackBoxFuncCall_RecursiveAggregation* release_recursive_aggregation();
  ::acvm::acir::circuit::BlackBoxFuncCall_RecursiveAggregation* mutable_recursive_aggregation();
  void set_allocated_recursive_aggregation(::acvm::acir::circuit::BlackBoxFuncCall_RecursiveAggregation* value);
  void unsafe_arena_set_allocated_recursive_aggregation(::acvm::acir::circuit::BlackBoxFuncCall_RecursiveAggregation* value);
  ::acvm::acir::circuit::BlackBoxFuncCall_RecursiveAggregation* unsafe_arena_release_recursive_aggregation();

  private:
  const ::acvm::acir::circuit::BlackBoxFuncCall_RecursiveAggregation& _internal_recursive_aggregation() const;
  ::acvm::acir::circuit::BlackBoxFuncCall_RecursiveAggregation* _internal_mutable_recursive_aggregation();

  public:
  // .acvm.acir.circuit.BlackBoxFuncCall.BigIntAdd big_int_add = 13;
  bool has_big_int_add() const;
  private:
  bool _internal_has_big_int_add() const;

  public:
  void clear_big_int_add() ;
  const ::acvm::acir::circuit::BlackBoxFuncCall_BigIntAdd& big_int_add() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::BlackBoxFuncCall_BigIntAdd* release_big_int_add();
  ::acvm::acir::circuit::BlackBoxFuncCall_BigIntAdd* mutable_big_int_add();
  void set_allocated_big_int_add(::acvm::acir::circuit::BlackBoxFuncCall_BigIntAdd* value);
  void unsafe_arena_set_allocated_big_int_add(::acvm::acir::circuit::BlackBoxFuncCall_BigIntAdd* value);
  ::acvm::acir::circuit::BlackBoxFuncCall_BigIntAdd* unsafe_arena_release_big_int_add();

  private:
  const ::acvm::acir::circuit::BlackBoxFuncCall_BigIntAdd& _internal_big_int_add() const;
  ::acvm::acir::circuit::BlackBoxFuncCall_BigIntAdd* _internal_mutable_big_int_add();

  public:
  // .acvm.acir.circuit.BlackBoxFuncCall.BigIntSub big_int_sub = 14;
  bool has_big_int_sub() const;
  private:
  bool _internal_has_big_int_sub() const;

  public:
  void clear_big_int_sub() ;
  const ::acvm::acir::circuit::BlackBoxFuncCall_BigIntSub& big_int_sub() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::BlackBoxFuncCall_BigIntSub* release_big_int_sub();
  ::acvm::acir::circuit::BlackBoxFuncCall_BigIntSub* mutable_big_int_sub();
  void set_allocated_big_int_sub(::acvm::acir::circuit::BlackBoxFuncCall_BigIntSub* value);
  void unsafe_arena_set_allocated_big_int_sub(::acvm::acir::circuit::BlackBoxFuncCall_BigIntSub* value);
  ::acvm::acir::circuit::BlackBoxFuncCall_BigIntSub* unsafe_arena_release_big_int_sub();

  private:
  const ::acvm::acir::circuit::BlackBoxFuncCall_BigIntSub& _internal_big_int_sub() const;
  ::acvm::acir::circuit::BlackBoxFuncCall_BigIntSub* _internal_mutable_big_int_sub();

  public:
  // .acvm.acir.circuit.BlackBoxFuncCall.BigIntMul big_int_mul = 15;
  bool has_big_int_mul() const;
  private:
  bool _internal_has_big_int_mul() const;

  public:
  void clear_big_int_mul() ;
  const ::acvm::acir::circuit::BlackBoxFuncCall_BigIntMul& big_int_mul() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::BlackBoxFuncCall_BigIntMul* release_big_int_mul();
  ::acvm::acir::circuit::BlackBoxFuncCall_BigIntMul* mutable_big_int_mul();
  void set_allocated_big_int_mul(::acvm::acir::circuit::BlackBoxFuncCall_BigIntMul* value);
  void unsafe_arena_set_allocated_big_int_mul(::acvm::acir::circuit::BlackBoxFuncCall_BigIntMul* value);
  ::acvm::acir::circuit::BlackBoxFuncCall_BigIntMul* unsafe_arena_release_big_int_mul();

  private:
  const ::acvm::acir::circuit::BlackBoxFuncCall_BigIntMul& _internal_big_int_mul() const;
  ::acvm::acir::circuit::BlackBoxFuncCall_BigIntMul* _internal_mutable_big_int_mul();

  public:
  // .acvm.acir.circuit.BlackBoxFuncCall.BigIntDiv big_int_div = 16;
  bool has_big_int_div() const;
  private:
  bool _internal_has_big_int_div() const;

  public:
  void clear_big_int_div() ;
  const ::acvm::acir::circuit::BlackBoxFuncCall_BigIntDiv& big_int_div() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::BlackBoxFuncCall_BigIntDiv* release_big_int_div();
  ::acvm::acir::circuit::BlackBoxFuncCall_BigIntDiv* mutable_big_int_div();
  void set_allocated_big_int_div(::acvm::acir::circuit::BlackBoxFuncCall_BigIntDiv* value);
  void unsafe_arena_set_allocated_big_int_div(::acvm::acir::circuit::BlackBoxFuncCall_BigIntDiv* value);
  ::acvm::acir::circuit::BlackBoxFuncCall_BigIntDiv* unsafe_arena_release_big_int_div();

  private:
  const ::acvm::acir::circuit::BlackBoxFuncCall_BigIntDiv& _internal_big_int_div() const;
  ::acvm::acir::circuit::BlackBoxFuncCall_BigIntDiv* _internal_mutable_big_int_div();

  public:
  // .acvm.acir.circuit.BlackBoxFuncCall.BigIntFromLeBytes big_int_from_le_bytes = 17;
  bool has_big_int_from_le_bytes() const;
  private:
  bool _internal_has_big_int_from_le_bytes() const;

  public:
  void clear_big_int_from_le_bytes() ;
  const ::acvm::acir::circuit::BlackBoxFuncCall_BigIntFromLeBytes& big_int_from_le_bytes() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::BlackBoxFuncCall_BigIntFromLeBytes* release_big_int_from_le_bytes();
  ::acvm::acir::circuit::BlackBoxFuncCall_BigIntFromLeBytes* mutable_big_int_from_le_bytes();
  void set_allocated_big_int_from_le_bytes(::acvm::acir::circuit::BlackBoxFuncCall_BigIntFromLeBytes* value);
  void unsafe_arena_set_allocated_big_int_from_le_bytes(::acvm::acir::circuit::BlackBoxFuncCall_BigIntFromLeBytes* value);
  ::acvm::acir::circuit::BlackBoxFuncCall_BigIntFromLeBytes* unsafe_arena_release_big_int_from_le_bytes();

  private:
  const ::acvm::acir::circuit::BlackBoxFuncCall_BigIntFromLeBytes& _internal_big_int_from_le_bytes() const;
  ::acvm::acir::circuit::BlackBoxFuncCall_BigIntFromLeBytes* _internal_mutable_big_int_from_le_bytes();

  public:
  // .acvm.acir.circuit.BlackBoxFuncCall.BigIntToLeBytes big_int_to_le_bytes = 18;
  bool has_big_int_to_le_bytes() const;
  private:
  bool _internal_has_big_int_to_le_bytes() const;

  public:
  void clear_big_int_to_le_bytes() ;
  const ::acvm::acir::circuit::BlackBoxFuncCall_BigIntToLeBytes& big_int_to_le_bytes() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::BlackBoxFuncCall_BigIntToLeBytes* release_big_int_to_le_bytes();
  ::acvm::acir::circuit::BlackBoxFuncCall_BigIntToLeBytes* mutable_big_int_to_le_bytes();
  void set_allocated_big_int_to_le_bytes(::acvm::acir::circuit::BlackBoxFuncCall_BigIntToLeBytes* value);
  void unsafe_arena_set_allocated_big_int_to_le_bytes(::acvm::acir::circuit::BlackBoxFuncCall_BigIntToLeBytes* value);
  ::acvm::acir::circuit::BlackBoxFuncCall_BigIntToLeBytes* unsafe_arena_release_big_int_to_le_bytes();

  private:
  const ::acvm::acir::circuit::BlackBoxFuncCall_BigIntToLeBytes& _internal_big_int_to_le_bytes() const;
  ::acvm::acir::circuit::BlackBoxFuncCall_BigIntToLeBytes* _internal_mutable_big_int_to_le_bytes();

  public:
  // .acvm.acir.circuit.BlackBoxFuncCall.Poseidon2Permutation poseidon2_permutation = 19;
  bool has_poseidon2_permutation() const;
  private:
  bool _internal_has_poseidon2_permutation() const;

  public:
  void clear_poseidon2_permutation() ;
  const ::acvm::acir::circuit::BlackBoxFuncCall_Poseidon2Permutation& poseidon2_permutation() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::BlackBoxFuncCall_Poseidon2Permutation* release_poseidon2_permutation();
  ::acvm::acir::circuit::BlackBoxFuncCall_Poseidon2Permutation* mutable_poseidon2_permutation();
  void set_allocated_poseidon2_permutation(::acvm::acir::circuit::BlackBoxFuncCall_Poseidon2Permutation* value);
  void unsafe_arena_set_allocated_poseidon2_permutation(::acvm::acir::circuit::BlackBoxFuncCall_Poseidon2Permutation* value);
  ::acvm::acir::circuit::BlackBoxFuncCall_Poseidon2Permutation* unsafe_arena_release_poseidon2_permutation();

  private:
  const ::acvm::acir::circuit::BlackBoxFuncCall_Poseidon2Permutation& _internal_poseidon2_permutation() const;
  ::acvm::acir::circuit::BlackBoxFuncCall_Poseidon2Permutation* _internal_mutable_poseidon2_permutation();

  public:
  // .acvm.acir.circuit.BlackBoxFuncCall.Sha256Compression sha256_compression = 20;
  bool has_sha256_compression() const;
  private:
  bool _internal_has_sha256_compression() const;

  public:
  void clear_sha256_compression() ;
  const ::acvm::acir::circuit::BlackBoxFuncCall_Sha256Compression& sha256_compression() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::BlackBoxFuncCall_Sha256Compression* release_sha256_compression();
  ::acvm::acir::circuit::BlackBoxFuncCall_Sha256Compression* mutable_sha256_compression();
  void set_allocated_sha256_compression(::acvm::acir::circuit::BlackBoxFuncCall_Sha256Compression* value);
  void unsafe_arena_set_allocated_sha256_compression(::acvm::acir::circuit::BlackBoxFuncCall_Sha256Compression* value);
  ::acvm::acir::circuit::BlackBoxFuncCall_Sha256Compression* unsafe_arena_release_sha256_compression();

  private:
  const ::acvm::acir::circuit::BlackBoxFuncCall_Sha256Compression& _internal_sha256_compression() const;
  ::acvm::acir::circuit::BlackBoxFuncCall_Sha256Compression* _internal_mutable_sha256_compression();

  public:
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.BlackBoxFuncCall)
 private:
  class _Internal;
  void set_has_aes128_encrypt();
  void set_has_and_();
  void set_has_xor_();
  void set_has_range();
  void set_has_blake2s();
  void set_has_blake3();
  void set_has_ecdsa_secp256k1();
  void set_has_ecdsa_secp256r1();
  void set_has_multi_scalar_mul();
  void set_has_embedded_curve_add();
  void set_has_keccak_f1600();
  void set_has_recursive_aggregation();
  void set_has_big_int_add();
  void set_has_big_int_sub();
  void set_has_big_int_mul();
  void set_has_big_int_div();
  void set_has_big_int_from_le_bytes();
  void set_has_big_int_to_le_bytes();
  void set_has_poseidon2_permutation();
  void set_has_sha256_compression();
  inline bool has_value() const;
  inline void clear_has_value();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 20, 20,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BlackBoxFuncCall& from_msg);
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::acvm::acir::circuit::BlackBoxFuncCall_AES128Encrypt* aes128_encrypt_;
      ::acvm::acir::circuit::BlackBoxFuncCall_AND* and__;
      ::acvm::acir::circuit::BlackBoxFuncCall_XOR* xor__;
      ::acvm::acir::circuit::BlackBoxFuncCall_RANGE* range_;
      ::acvm::acir::circuit::BlackBoxFuncCall_Blake2s* blake2s_;
      ::acvm::acir::circuit::BlackBoxFuncCall_Blake3* blake3_;
      ::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256k1* ecdsa_secp256k1_;
      ::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256r1* ecdsa_secp256r1_;
      ::acvm::acir::circuit::BlackBoxFuncCall_MultiScalarMul* multi_scalar_mul_;
      ::acvm::acir::circuit::BlackBoxFuncCall_EmbeddedCurveAdd* embedded_curve_add_;
      ::acvm::acir::circuit::BlackBoxFuncCall_Keccakf1600* keccak_f1600_;
      ::acvm::acir::circuit::BlackBoxFuncCall_RecursiveAggregation* recursive_aggregation_;
      ::acvm::acir::circuit::BlackBoxFuncCall_BigIntAdd* big_int_add_;
      ::acvm::acir::circuit::BlackBoxFuncCall_BigIntSub* big_int_sub_;
      ::acvm::acir::circuit::BlackBoxFuncCall_BigIntMul* big_int_mul_;
      ::acvm::acir::circuit::BlackBoxFuncCall_BigIntDiv* big_int_div_;
      ::acvm::acir::circuit::BlackBoxFuncCall_BigIntFromLeBytes* big_int_from_le_bytes_;
      ::acvm::acir::circuit::BlackBoxFuncCall_BigIntToLeBytes* big_int_to_le_bytes_;
      ::acvm::acir::circuit::BlackBoxFuncCall_Poseidon2Permutation* poseidon2_permutation_;
      ::acvm::acir::circuit::BlackBoxFuncCall_Sha256Compression* sha256_compression_;
    } value_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class AssertionPayload final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.AssertionPayload) */ {
 public:
  inline AssertionPayload() : AssertionPayload(nullptr) {}
  ~AssertionPayload() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AssertionPayload* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AssertionPayload));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AssertionPayload(
      ::google::protobuf::internal::ConstantInitialized);

  inline AssertionPayload(const AssertionPayload& from) : AssertionPayload(nullptr, from) {}
  inline AssertionPayload(AssertionPayload&& from) noexcept
      : AssertionPayload(nullptr, std::move(from)) {}
  inline AssertionPayload& operator=(const AssertionPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssertionPayload& operator=(AssertionPayload&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssertionPayload& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssertionPayload* internal_default_instance() {
    return reinterpret_cast<const AssertionPayload*>(
        &_AssertionPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(AssertionPayload& a, AssertionPayload& b) { a.Swap(&b); }
  inline void Swap(AssertionPayload* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssertionPayload* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssertionPayload* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AssertionPayload>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AssertionPayload& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AssertionPayload& from) { AssertionPayload::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AssertionPayload* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.AssertionPayload"; }

 protected:
  explicit AssertionPayload(::google::protobuf::Arena* arena);
  AssertionPayload(::google::protobuf::Arena* arena, const AssertionPayload& from);
  AssertionPayload(::google::protobuf::Arena* arena, AssertionPayload&& from) noexcept
      : AssertionPayload(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPayloadFieldNumber = 2,
    kErrorSelectorFieldNumber = 1,
  };
  // repeated .acvm.acir.circuit.ExpressionOrMemory payload = 2;
  int payload_size() const;
  private:
  int _internal_payload_size() const;

  public:
  void clear_payload() ;
  ::acvm::acir::circuit::ExpressionOrMemory* mutable_payload(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::ExpressionOrMemory>* mutable_payload();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::ExpressionOrMemory>& _internal_payload() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::ExpressionOrMemory>* _internal_mutable_payload();
  public:
  const ::acvm::acir::circuit::ExpressionOrMemory& payload(int index) const;
  ::acvm::acir::circuit::ExpressionOrMemory* add_payload();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::ExpressionOrMemory>& payload() const;
  // uint64 error_selector = 1;
  void clear_error_selector() ;
  ::uint64_t error_selector() const;
  void set_error_selector(::uint64_t value);

  private:
  ::uint64_t _internal_error_selector() const;
  void _internal_set_error_selector(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.AssertionPayload)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AssertionPayload& from_msg);
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::circuit::ExpressionOrMemory > payload_;
    ::uint64_t error_selector_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class Opcode_BrilligCall final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.Opcode.BrilligCall) */ {
 public:
  inline Opcode_BrilligCall() : Opcode_BrilligCall(nullptr) {}
  ~Opcode_BrilligCall() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Opcode_BrilligCall* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Opcode_BrilligCall));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Opcode_BrilligCall(
      ::google::protobuf::internal::ConstantInitialized);

  inline Opcode_BrilligCall(const Opcode_BrilligCall& from) : Opcode_BrilligCall(nullptr, from) {}
  inline Opcode_BrilligCall(Opcode_BrilligCall&& from) noexcept
      : Opcode_BrilligCall(nullptr, std::move(from)) {}
  inline Opcode_BrilligCall& operator=(const Opcode_BrilligCall& from) {
    CopyFrom(from);
    return *this;
  }
  inline Opcode_BrilligCall& operator=(Opcode_BrilligCall&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Opcode_BrilligCall& default_instance() {
    return *internal_default_instance();
  }
  static inline const Opcode_BrilligCall* internal_default_instance() {
    return reinterpret_cast<const Opcode_BrilligCall*>(
        &_Opcode_BrilligCall_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(Opcode_BrilligCall& a, Opcode_BrilligCall& b) { a.Swap(&b); }
  inline void Swap(Opcode_BrilligCall* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Opcode_BrilligCall* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Opcode_BrilligCall* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Opcode_BrilligCall>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Opcode_BrilligCall& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Opcode_BrilligCall& from) { Opcode_BrilligCall::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Opcode_BrilligCall* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.Opcode.BrilligCall"; }

 protected:
  explicit Opcode_BrilligCall(::google::protobuf::Arena* arena);
  Opcode_BrilligCall(::google::protobuf::Arena* arena, const Opcode_BrilligCall& from);
  Opcode_BrilligCall(::google::protobuf::Arena* arena, Opcode_BrilligCall&& from) noexcept
      : Opcode_BrilligCall(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInputsFieldNumber = 2,
    kOutputsFieldNumber = 3,
    kPredicateFieldNumber = 4,
    kIdFieldNumber = 1,
  };
  // repeated .acvm.acir.circuit.BrilligInputs inputs = 2;
  int inputs_size() const;
  private:
  int _internal_inputs_size() const;

  public:
  void clear_inputs() ;
  ::acvm::acir::circuit::BrilligInputs* mutable_inputs(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::BrilligInputs>* mutable_inputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::BrilligInputs>& _internal_inputs() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::BrilligInputs>* _internal_mutable_inputs();
  public:
  const ::acvm::acir::circuit::BrilligInputs& inputs(int index) const;
  ::acvm::acir::circuit::BrilligInputs* add_inputs();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::BrilligInputs>& inputs() const;
  // repeated .acvm.acir.circuit.BrilligOutputs outputs = 3;
  int outputs_size() const;
  private:
  int _internal_outputs_size() const;

  public:
  void clear_outputs() ;
  ::acvm::acir::circuit::BrilligOutputs* mutable_outputs(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::BrilligOutputs>* mutable_outputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::BrilligOutputs>& _internal_outputs() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::BrilligOutputs>* _internal_mutable_outputs();
  public:
  const ::acvm::acir::circuit::BrilligOutputs& outputs(int index) const;
  ::acvm::acir::circuit::BrilligOutputs* add_outputs();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::BrilligOutputs>& outputs() const;
  // optional .acvm.acir.native.Expression predicate = 4;
  bool has_predicate() const;
  void clear_predicate() ;
  const ::acvm::acir::native::Expression& predicate() const;
  PROTOBUF_NODISCARD ::acvm::acir::native::Expression* release_predicate();
  ::acvm::acir::native::Expression* mutable_predicate();
  void set_allocated_predicate(::acvm::acir::native::Expression* value);
  void unsafe_arena_set_allocated_predicate(::acvm::acir::native::Expression* value);
  ::acvm::acir::native::Expression* unsafe_arena_release_predicate();

  private:
  const ::acvm::acir::native::Expression& _internal_predicate() const;
  ::acvm::acir::native::Expression* _internal_mutable_predicate();

  public:
  // uint32 id = 1;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.Opcode.BrilligCall)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Opcode_BrilligCall& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::circuit::BrilligInputs > inputs_;
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::circuit::BrilligOutputs > outputs_;
    ::acvm::acir::native::Expression* predicate_;
    ::uint32_t id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class AssertMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.AssertMessage) */ {
 public:
  inline AssertMessage() : AssertMessage(nullptr) {}
  ~AssertMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AssertMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AssertMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AssertMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline AssertMessage(const AssertMessage& from) : AssertMessage(nullptr, from) {}
  inline AssertMessage(AssertMessage&& from) noexcept
      : AssertMessage(nullptr, std::move(from)) {}
  inline AssertMessage& operator=(const AssertMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssertMessage& operator=(AssertMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssertMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssertMessage* internal_default_instance() {
    return reinterpret_cast<const AssertMessage*>(
        &_AssertMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(AssertMessage& a, AssertMessage& b) { a.Swap(&b); }
  inline void Swap(AssertMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssertMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssertMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AssertMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AssertMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AssertMessage& from) { AssertMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AssertMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.AssertMessage"; }

 protected:
  explicit AssertMessage(::google::protobuf::Arena* arena);
  AssertMessage(::google::protobuf::Arena* arena, const AssertMessage& from);
  AssertMessage(::google::protobuf::Arena* arena, AssertMessage&& from) noexcept
      : AssertMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLocationFieldNumber = 1,
    kPayloadFieldNumber = 2,
  };
  // .acvm.acir.circuit.OpcodeLocation location = 1;
  bool has_location() const;
  void clear_location() ;
  const ::acvm::acir::circuit::OpcodeLocation& location() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::OpcodeLocation* release_location();
  ::acvm::acir::circuit::OpcodeLocation* mutable_location();
  void set_allocated_location(::acvm::acir::circuit::OpcodeLocation* value);
  void unsafe_arena_set_allocated_location(::acvm::acir::circuit::OpcodeLocation* value);
  ::acvm::acir::circuit::OpcodeLocation* unsafe_arena_release_location();

  private:
  const ::acvm::acir::circuit::OpcodeLocation& _internal_location() const;
  ::acvm::acir::circuit::OpcodeLocation* _internal_mutable_location();

  public:
  // .acvm.acir.circuit.AssertionPayload payload = 2;
  bool has_payload() const;
  void clear_payload() ;
  const ::acvm::acir::circuit::AssertionPayload& payload() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::AssertionPayload* release_payload();
  ::acvm::acir::circuit::AssertionPayload* mutable_payload();
  void set_allocated_payload(::acvm::acir::circuit::AssertionPayload* value);
  void unsafe_arena_set_allocated_payload(::acvm::acir::circuit::AssertionPayload* value);
  ::acvm::acir::circuit::AssertionPayload* unsafe_arena_release_payload();

  private:
  const ::acvm::acir::circuit::AssertionPayload& _internal_payload() const;
  ::acvm::acir::circuit::AssertionPayload* _internal_mutable_payload();

  public:
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.AssertMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AssertMessage& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::acvm::acir::circuit::OpcodeLocation* location_;
    ::acvm::acir::circuit::AssertionPayload* payload_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class Opcode final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.Opcode) */ {
 public:
  inline Opcode() : Opcode(nullptr) {}
  ~Opcode() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Opcode* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Opcode));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Opcode(
      ::google::protobuf::internal::ConstantInitialized);

  inline Opcode(const Opcode& from) : Opcode(nullptr, from) {}
  inline Opcode(Opcode&& from) noexcept
      : Opcode(nullptr, std::move(from)) {}
  inline Opcode& operator=(const Opcode& from) {
    CopyFrom(from);
    return *this;
  }
  inline Opcode& operator=(Opcode&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Opcode& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kAssertZero = 1,
    kBlackboxFuncCall = 2,
    kMemoryOp = 3,
    kMemoryInit = 4,
    kBrilligCall = 5,
    kCall = 6,
    VALUE_NOT_SET = 0,
  };
  static inline const Opcode* internal_default_instance() {
    return reinterpret_cast<const Opcode*>(
        &_Opcode_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(Opcode& a, Opcode& b) { a.Swap(&b); }
  inline void Swap(Opcode* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Opcode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Opcode* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Opcode>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Opcode& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Opcode& from) { Opcode::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Opcode* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.Opcode"; }

 protected:
  explicit Opcode(::google::protobuf::Arena* arena);
  Opcode(::google::protobuf::Arena* arena, const Opcode& from);
  Opcode(::google::protobuf::Arena* arena, Opcode&& from) noexcept
      : Opcode(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using MemoryOp = Opcode_MemoryOp;
  using MemoryInit = Opcode_MemoryInit;
  using BrilligCall = Opcode_BrilligCall;
  using Call = Opcode_Call;

  // accessors -------------------------------------------------------
  enum : int {
    kAssertZeroFieldNumber = 1,
    kBlackboxFuncCallFieldNumber = 2,
    kMemoryOpFieldNumber = 3,
    kMemoryInitFieldNumber = 4,
    kBrilligCallFieldNumber = 5,
    kCallFieldNumber = 6,
  };
  // .acvm.acir.native.Expression assert_zero = 1;
  bool has_assert_zero() const;
  private:
  bool _internal_has_assert_zero() const;

  public:
  void clear_assert_zero() ;
  const ::acvm::acir::native::Expression& assert_zero() const;
  PROTOBUF_NODISCARD ::acvm::acir::native::Expression* release_assert_zero();
  ::acvm::acir::native::Expression* mutable_assert_zero();
  void set_allocated_assert_zero(::acvm::acir::native::Expression* value);
  void unsafe_arena_set_allocated_assert_zero(::acvm::acir::native::Expression* value);
  ::acvm::acir::native::Expression* unsafe_arena_release_assert_zero();

  private:
  const ::acvm::acir::native::Expression& _internal_assert_zero() const;
  ::acvm::acir::native::Expression* _internal_mutable_assert_zero();

  public:
  // .acvm.acir.circuit.BlackBoxFuncCall blackbox_func_call = 2;
  bool has_blackbox_func_call() const;
  private:
  bool _internal_has_blackbox_func_call() const;

  public:
  void clear_blackbox_func_call() ;
  const ::acvm::acir::circuit::BlackBoxFuncCall& blackbox_func_call() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::BlackBoxFuncCall* release_blackbox_func_call();
  ::acvm::acir::circuit::BlackBoxFuncCall* mutable_blackbox_func_call();
  void set_allocated_blackbox_func_call(::acvm::acir::circuit::BlackBoxFuncCall* value);
  void unsafe_arena_set_allocated_blackbox_func_call(::acvm::acir::circuit::BlackBoxFuncCall* value);
  ::acvm::acir::circuit::BlackBoxFuncCall* unsafe_arena_release_blackbox_func_call();

  private:
  const ::acvm::acir::circuit::BlackBoxFuncCall& _internal_blackbox_func_call() const;
  ::acvm::acir::circuit::BlackBoxFuncCall* _internal_mutable_blackbox_func_call();

  public:
  // .acvm.acir.circuit.Opcode.MemoryOp memory_op = 3;
  bool has_memory_op() const;
  private:
  bool _internal_has_memory_op() const;

  public:
  void clear_memory_op() ;
  const ::acvm::acir::circuit::Opcode_MemoryOp& memory_op() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::Opcode_MemoryOp* release_memory_op();
  ::acvm::acir::circuit::Opcode_MemoryOp* mutable_memory_op();
  void set_allocated_memory_op(::acvm::acir::circuit::Opcode_MemoryOp* value);
  void unsafe_arena_set_allocated_memory_op(::acvm::acir::circuit::Opcode_MemoryOp* value);
  ::acvm::acir::circuit::Opcode_MemoryOp* unsafe_arena_release_memory_op();

  private:
  const ::acvm::acir::circuit::Opcode_MemoryOp& _internal_memory_op() const;
  ::acvm::acir::circuit::Opcode_MemoryOp* _internal_mutable_memory_op();

  public:
  // .acvm.acir.circuit.Opcode.MemoryInit memory_init = 4;
  bool has_memory_init() const;
  private:
  bool _internal_has_memory_init() const;

  public:
  void clear_memory_init() ;
  const ::acvm::acir::circuit::Opcode_MemoryInit& memory_init() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::Opcode_MemoryInit* release_memory_init();
  ::acvm::acir::circuit::Opcode_MemoryInit* mutable_memory_init();
  void set_allocated_memory_init(::acvm::acir::circuit::Opcode_MemoryInit* value);
  void unsafe_arena_set_allocated_memory_init(::acvm::acir::circuit::Opcode_MemoryInit* value);
  ::acvm::acir::circuit::Opcode_MemoryInit* unsafe_arena_release_memory_init();

  private:
  const ::acvm::acir::circuit::Opcode_MemoryInit& _internal_memory_init() const;
  ::acvm::acir::circuit::Opcode_MemoryInit* _internal_mutable_memory_init();

  public:
  // .acvm.acir.circuit.Opcode.BrilligCall brillig_call = 5;
  bool has_brillig_call() const;
  private:
  bool _internal_has_brillig_call() const;

  public:
  void clear_brillig_call() ;
  const ::acvm::acir::circuit::Opcode_BrilligCall& brillig_call() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::Opcode_BrilligCall* release_brillig_call();
  ::acvm::acir::circuit::Opcode_BrilligCall* mutable_brillig_call();
  void set_allocated_brillig_call(::acvm::acir::circuit::Opcode_BrilligCall* value);
  void unsafe_arena_set_allocated_brillig_call(::acvm::acir::circuit::Opcode_BrilligCall* value);
  ::acvm::acir::circuit::Opcode_BrilligCall* unsafe_arena_release_brillig_call();

  private:
  const ::acvm::acir::circuit::Opcode_BrilligCall& _internal_brillig_call() const;
  ::acvm::acir::circuit::Opcode_BrilligCall* _internal_mutable_brillig_call();

  public:
  // .acvm.acir.circuit.Opcode.Call call = 6;
  bool has_call() const;
  private:
  bool _internal_has_call() const;

  public:
  void clear_call() ;
  const ::acvm::acir::circuit::Opcode_Call& call() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::Opcode_Call* release_call();
  ::acvm::acir::circuit::Opcode_Call* mutable_call();
  void set_allocated_call(::acvm::acir::circuit::Opcode_Call* value);
  void unsafe_arena_set_allocated_call(::acvm::acir::circuit::Opcode_Call* value);
  ::acvm::acir::circuit::Opcode_Call* unsafe_arena_release_call();

  private:
  const ::acvm::acir::circuit::Opcode_Call& _internal_call() const;
  ::acvm::acir::circuit::Opcode_Call* _internal_mutable_call();

  public:
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.Opcode)
 private:
  class _Internal;
  void set_has_assert_zero();
  void set_has_blackbox_func_call();
  void set_has_memory_op();
  void set_has_memory_init();
  void set_has_brillig_call();
  void set_has_call();
  inline bool has_value() const;
  inline void clear_has_value();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 6, 6,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Opcode& from_msg);
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::acvm::acir::native::Expression* assert_zero_;
      ::acvm::acir::circuit::BlackBoxFuncCall* blackbox_func_call_;
      ::acvm::acir::circuit::Opcode_MemoryOp* memory_op_;
      ::acvm::acir::circuit::Opcode_MemoryInit* memory_init_;
      ::acvm::acir::circuit::Opcode_BrilligCall* brillig_call_;
      ::acvm::acir::circuit::Opcode_Call* call_;
    } value_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};
// -------------------------------------------------------------------

class Circuit final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:acvm.acir.circuit.Circuit) */ {
 public:
  inline Circuit() : Circuit(nullptr) {}
  ~Circuit() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Circuit* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Circuit));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Circuit(
      ::google::protobuf::internal::ConstantInitialized);

  inline Circuit(const Circuit& from) : Circuit(nullptr, from) {}
  inline Circuit(Circuit&& from) noexcept
      : Circuit(nullptr, std::move(from)) {}
  inline Circuit& operator=(const Circuit& from) {
    CopyFrom(from);
    return *this;
  }
  inline Circuit& operator=(Circuit&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Circuit& default_instance() {
    return *internal_default_instance();
  }
  static inline const Circuit* internal_default_instance() {
    return reinterpret_cast<const Circuit*>(
        &_Circuit_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Circuit& a, Circuit& b) { a.Swap(&b); }
  inline void Swap(Circuit* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Circuit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Circuit* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Circuit>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Circuit& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Circuit& from) { Circuit::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Circuit* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "acvm.acir.circuit.Circuit"; }

 protected:
  explicit Circuit(::google::protobuf::Arena* arena);
  Circuit(::google::protobuf::Arena* arena, const Circuit& from);
  Circuit(::google::protobuf::Arena* arena, Circuit&& from) noexcept
      : Circuit(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOpcodesFieldNumber = 2,
    kPrivateParametersFieldNumber = 4,
    kPublicParametersFieldNumber = 5,
    kReturnValuesFieldNumber = 6,
    kAssertMessagesFieldNumber = 7,
    kExpressionWidthFieldNumber = 3,
    kCurrentWitnessIndexFieldNumber = 1,
  };
  // repeated .acvm.acir.circuit.Opcode opcodes = 2;
  int opcodes_size() const;
  private:
  int _internal_opcodes_size() const;

  public:
  void clear_opcodes() ;
  ::acvm::acir::circuit::Opcode* mutable_opcodes(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::Opcode>* mutable_opcodes();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::Opcode>& _internal_opcodes() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::Opcode>* _internal_mutable_opcodes();
  public:
  const ::acvm::acir::circuit::Opcode& opcodes(int index) const;
  ::acvm::acir::circuit::Opcode* add_opcodes();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::Opcode>& opcodes() const;
  // repeated .acvm.acir.native.Witness private_parameters = 4;
  int private_parameters_size() const;
  private:
  int _internal_private_parameters_size() const;

  public:
  void clear_private_parameters() ;
  ::acvm::acir::native::Witness* mutable_private_parameters(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* mutable_private_parameters();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& _internal_private_parameters() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* _internal_mutable_private_parameters();
  public:
  const ::acvm::acir::native::Witness& private_parameters(int index) const;
  ::acvm::acir::native::Witness* add_private_parameters();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& private_parameters() const;
  // repeated .acvm.acir.native.Witness public_parameters = 5;
  int public_parameters_size() const;
  private:
  int _internal_public_parameters_size() const;

  public:
  void clear_public_parameters() ;
  ::acvm::acir::native::Witness* mutable_public_parameters(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* mutable_public_parameters();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& _internal_public_parameters() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* _internal_mutable_public_parameters();
  public:
  const ::acvm::acir::native::Witness& public_parameters(int index) const;
  ::acvm::acir::native::Witness* add_public_parameters();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& public_parameters() const;
  // repeated .acvm.acir.native.Witness return_values = 6;
  int return_values_size() const;
  private:
  int _internal_return_values_size() const;

  public:
  void clear_return_values() ;
  ::acvm::acir::native::Witness* mutable_return_values(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* mutable_return_values();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& _internal_return_values() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* _internal_mutable_return_values();
  public:
  const ::acvm::acir::native::Witness& return_values(int index) const;
  ::acvm::acir::native::Witness* add_return_values();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& return_values() const;
  // repeated .acvm.acir.circuit.AssertMessage assert_messages = 7;
  int assert_messages_size() const;
  private:
  int _internal_assert_messages_size() const;

  public:
  void clear_assert_messages() ;
  ::acvm::acir::circuit::AssertMessage* mutable_assert_messages(int index);
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::AssertMessage>* mutable_assert_messages();

  private:
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::AssertMessage>& _internal_assert_messages() const;
  ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::AssertMessage>* _internal_mutable_assert_messages();
  public:
  const ::acvm::acir::circuit::AssertMessage& assert_messages(int index) const;
  ::acvm::acir::circuit::AssertMessage* add_assert_messages();
  const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::AssertMessage>& assert_messages() const;
  // .acvm.acir.circuit.ExpressionWidth expression_width = 3;
  bool has_expression_width() const;
  void clear_expression_width() ;
  const ::acvm::acir::circuit::ExpressionWidth& expression_width() const;
  PROTOBUF_NODISCARD ::acvm::acir::circuit::ExpressionWidth* release_expression_width();
  ::acvm::acir::circuit::ExpressionWidth* mutable_expression_width();
  void set_allocated_expression_width(::acvm::acir::circuit::ExpressionWidth* value);
  void unsafe_arena_set_allocated_expression_width(::acvm::acir::circuit::ExpressionWidth* value);
  ::acvm::acir::circuit::ExpressionWidth* unsafe_arena_release_expression_width();

  private:
  const ::acvm::acir::circuit::ExpressionWidth& _internal_expression_width() const;
  ::acvm::acir::circuit::ExpressionWidth* _internal_mutable_expression_width();

  public:
  // uint32 current_witness_index = 1;
  void clear_current_witness_index() ;
  ::uint32_t current_witness_index() const;
  void set_current_witness_index(::uint32_t value);

  private:
  ::uint32_t _internal_current_witness_index() const;
  void _internal_set_current_witness_index(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:acvm.acir.circuit.Circuit)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 6,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Circuit& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::circuit::Opcode > opcodes_;
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::native::Witness > private_parameters_;
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::native::Witness > public_parameters_;
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::native::Witness > return_values_;
    ::google::protobuf::RepeatedPtrField< ::acvm::acir::circuit::AssertMessage > assert_messages_;
    ::acvm::acir::circuit::ExpressionWidth* expression_width_;
    ::uint32_t current_witness_index_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acir_2fcircuit_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Circuit

// uint32 current_witness_index = 1;
inline void Circuit::clear_current_witness_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_witness_index_ = 0u;
}
inline ::uint32_t Circuit::current_witness_index() const {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.Circuit.current_witness_index)
  return _internal_current_witness_index();
}
inline void Circuit::set_current_witness_index(::uint32_t value) {
  _internal_set_current_witness_index(value);
  // @@protoc_insertion_point(field_set:acvm.acir.circuit.Circuit.current_witness_index)
}
inline ::uint32_t Circuit::_internal_current_witness_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.current_witness_index_;
}
inline void Circuit::_internal_set_current_witness_index(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_witness_index_ = value;
}

// repeated .acvm.acir.circuit.Opcode opcodes = 2;
inline int Circuit::_internal_opcodes_size() const {
  return _internal_opcodes().size();
}
inline int Circuit::opcodes_size() const {
  return _internal_opcodes_size();
}
inline void Circuit::clear_opcodes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.opcodes_.Clear();
}
inline ::acvm::acir::circuit::Opcode* Circuit::mutable_opcodes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.Circuit.opcodes)
  return _internal_mutable_opcodes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::Opcode>* Circuit::mutable_opcodes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.Circuit.opcodes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_opcodes();
}
inline const ::acvm::acir::circuit::Opcode& Circuit::opcodes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.Circuit.opcodes)
  return _internal_opcodes().Get(index);
}
inline ::acvm::acir::circuit::Opcode* Circuit::add_opcodes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::circuit::Opcode* _add = _internal_mutable_opcodes()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.Circuit.opcodes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::Opcode>& Circuit::opcodes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.Circuit.opcodes)
  return _internal_opcodes();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::Opcode>&
Circuit::_internal_opcodes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.opcodes_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::Opcode>*
Circuit::_internal_mutable_opcodes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.opcodes_;
}

// .acvm.acir.circuit.ExpressionWidth expression_width = 3;
inline bool Circuit::has_expression_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.expression_width_ != nullptr);
  return value;
}
inline void Circuit::clear_expression_width() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.expression_width_ != nullptr) _impl_.expression_width_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::acvm::acir::circuit::ExpressionWidth& Circuit::_internal_expression_width() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::acvm::acir::circuit::ExpressionWidth* p = _impl_.expression_width_;
  return p != nullptr ? *p : reinterpret_cast<const ::acvm::acir::circuit::ExpressionWidth&>(::acvm::acir::circuit::_ExpressionWidth_default_instance_);
}
inline const ::acvm::acir::circuit::ExpressionWidth& Circuit::expression_width() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.Circuit.expression_width)
  return _internal_expression_width();
}
inline void Circuit::unsafe_arena_set_allocated_expression_width(::acvm::acir::circuit::ExpressionWidth* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.expression_width_);
  }
  _impl_.expression_width_ = reinterpret_cast<::acvm::acir::circuit::ExpressionWidth*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.Circuit.expression_width)
}
inline ::acvm::acir::circuit::ExpressionWidth* Circuit::release_expression_width() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::acvm::acir::circuit::ExpressionWidth* released = _impl_.expression_width_;
  _impl_.expression_width_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::acvm::acir::circuit::ExpressionWidth* Circuit::unsafe_arena_release_expression_width() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.Circuit.expression_width)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::acvm::acir::circuit::ExpressionWidth* temp = _impl_.expression_width_;
  _impl_.expression_width_ = nullptr;
  return temp;
}
inline ::acvm::acir::circuit::ExpressionWidth* Circuit::_internal_mutable_expression_width() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.expression_width_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::ExpressionWidth>(GetArena());
    _impl_.expression_width_ = reinterpret_cast<::acvm::acir::circuit::ExpressionWidth*>(p);
  }
  return _impl_.expression_width_;
}
inline ::acvm::acir::circuit::ExpressionWidth* Circuit::mutable_expression_width() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::acvm::acir::circuit::ExpressionWidth* _msg = _internal_mutable_expression_width();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.Circuit.expression_width)
  return _msg;
}
inline void Circuit::set_allocated_expression_width(::acvm::acir::circuit::ExpressionWidth* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.expression_width_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.expression_width_ = reinterpret_cast<::acvm::acir::circuit::ExpressionWidth*>(value);
  // @@protoc_insertion_point(field_set_allocated:acvm.acir.circuit.Circuit.expression_width)
}

// repeated .acvm.acir.native.Witness private_parameters = 4;
inline int Circuit::_internal_private_parameters_size() const {
  return _internal_private_parameters().size();
}
inline int Circuit::private_parameters_size() const {
  return _internal_private_parameters_size();
}
inline ::acvm::acir::native::Witness* Circuit::mutable_private_parameters(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.Circuit.private_parameters)
  return _internal_mutable_private_parameters()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* Circuit::mutable_private_parameters()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.Circuit.private_parameters)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_private_parameters();
}
inline const ::acvm::acir::native::Witness& Circuit::private_parameters(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.Circuit.private_parameters)
  return _internal_private_parameters().Get(index);
}
inline ::acvm::acir::native::Witness* Circuit::add_private_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::native::Witness* _add = _internal_mutable_private_parameters()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.Circuit.private_parameters)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& Circuit::private_parameters() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.Circuit.private_parameters)
  return _internal_private_parameters();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>&
Circuit::_internal_private_parameters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.private_parameters_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>*
Circuit::_internal_mutable_private_parameters() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.private_parameters_;
}

// repeated .acvm.acir.native.Witness public_parameters = 5;
inline int Circuit::_internal_public_parameters_size() const {
  return _internal_public_parameters().size();
}
inline int Circuit::public_parameters_size() const {
  return _internal_public_parameters_size();
}
inline ::acvm::acir::native::Witness* Circuit::mutable_public_parameters(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.Circuit.public_parameters)
  return _internal_mutable_public_parameters()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* Circuit::mutable_public_parameters()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.Circuit.public_parameters)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_public_parameters();
}
inline const ::acvm::acir::native::Witness& Circuit::public_parameters(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.Circuit.public_parameters)
  return _internal_public_parameters().Get(index);
}
inline ::acvm::acir::native::Witness* Circuit::add_public_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::native::Witness* _add = _internal_mutable_public_parameters()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.Circuit.public_parameters)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& Circuit::public_parameters() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.Circuit.public_parameters)
  return _internal_public_parameters();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>&
Circuit::_internal_public_parameters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.public_parameters_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>*
Circuit::_internal_mutable_public_parameters() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.public_parameters_;
}

// repeated .acvm.acir.native.Witness return_values = 6;
inline int Circuit::_internal_return_values_size() const {
  return _internal_return_values().size();
}
inline int Circuit::return_values_size() const {
  return _internal_return_values_size();
}
inline ::acvm::acir::native::Witness* Circuit::mutable_return_values(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.Circuit.return_values)
  return _internal_mutable_return_values()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* Circuit::mutable_return_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.Circuit.return_values)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_return_values();
}
inline const ::acvm::acir::native::Witness& Circuit::return_values(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.Circuit.return_values)
  return _internal_return_values().Get(index);
}
inline ::acvm::acir::native::Witness* Circuit::add_return_values() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::native::Witness* _add = _internal_mutable_return_values()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.Circuit.return_values)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& Circuit::return_values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.Circuit.return_values)
  return _internal_return_values();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>&
Circuit::_internal_return_values() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.return_values_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>*
Circuit::_internal_mutable_return_values() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.return_values_;
}

// repeated .acvm.acir.circuit.AssertMessage assert_messages = 7;
inline int Circuit::_internal_assert_messages_size() const {
  return _internal_assert_messages().size();
}
inline int Circuit::assert_messages_size() const {
  return _internal_assert_messages_size();
}
inline void Circuit::clear_assert_messages() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.assert_messages_.Clear();
}
inline ::acvm::acir::circuit::AssertMessage* Circuit::mutable_assert_messages(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.Circuit.assert_messages)
  return _internal_mutable_assert_messages()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::AssertMessage>* Circuit::mutable_assert_messages()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.Circuit.assert_messages)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_assert_messages();
}
inline const ::acvm::acir::circuit::AssertMessage& Circuit::assert_messages(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.Circuit.assert_messages)
  return _internal_assert_messages().Get(index);
}
inline ::acvm::acir::circuit::AssertMessage* Circuit::add_assert_messages() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::circuit::AssertMessage* _add = _internal_mutable_assert_messages()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.Circuit.assert_messages)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::AssertMessage>& Circuit::assert_messages() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.Circuit.assert_messages)
  return _internal_assert_messages();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::AssertMessage>&
Circuit::_internal_assert_messages() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.assert_messages_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::AssertMessage>*
Circuit::_internal_mutable_assert_messages() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.assert_messages_;
}

// -------------------------------------------------------------------

// ExpressionWidth_Unbounded

// -------------------------------------------------------------------

// ExpressionWidth_Bounded

// uint64 width = 1;
inline void ExpressionWidth_Bounded::clear_width() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = ::uint64_t{0u};
}
inline ::uint64_t ExpressionWidth_Bounded::width() const {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.ExpressionWidth.Bounded.width)
  return _internal_width();
}
inline void ExpressionWidth_Bounded::set_width(::uint64_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:acvm.acir.circuit.ExpressionWidth.Bounded.width)
}
inline ::uint64_t ExpressionWidth_Bounded::_internal_width() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.width_;
}
inline void ExpressionWidth_Bounded::_internal_set_width(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = value;
}

// -------------------------------------------------------------------

// ExpressionWidth

// .acvm.acir.circuit.ExpressionWidth.Unbounded unbounded = 1;
inline bool ExpressionWidth::has_unbounded() const {
  return value_case() == kUnbounded;
}
inline bool ExpressionWidth::_internal_has_unbounded() const {
  return value_case() == kUnbounded;
}
inline void ExpressionWidth::set_has_unbounded() {
  _impl_._oneof_case_[0] = kUnbounded;
}
inline void ExpressionWidth::clear_unbounded() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kUnbounded) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.unbounded_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.unbounded_);
    }
    clear_has_value();
  }
}
inline ::acvm::acir::circuit::ExpressionWidth_Unbounded* ExpressionWidth::release_unbounded() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.ExpressionWidth.unbounded)
  if (value_case() == kUnbounded) {
    clear_has_value();
    auto* temp = _impl_.value_.unbounded_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.unbounded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::circuit::ExpressionWidth_Unbounded& ExpressionWidth::_internal_unbounded() const {
  return value_case() == kUnbounded ? *_impl_.value_.unbounded_ : reinterpret_cast<::acvm::acir::circuit::ExpressionWidth_Unbounded&>(::acvm::acir::circuit::_ExpressionWidth_Unbounded_default_instance_);
}
inline const ::acvm::acir::circuit::ExpressionWidth_Unbounded& ExpressionWidth::unbounded() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.ExpressionWidth.unbounded)
  return _internal_unbounded();
}
inline ::acvm::acir::circuit::ExpressionWidth_Unbounded* ExpressionWidth::unsafe_arena_release_unbounded() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.ExpressionWidth.unbounded)
  if (value_case() == kUnbounded) {
    clear_has_value();
    auto* temp = _impl_.value_.unbounded_;
    _impl_.value_.unbounded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ExpressionWidth::unsafe_arena_set_allocated_unbounded(::acvm::acir::circuit::ExpressionWidth_Unbounded* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_unbounded();
    _impl_.value_.unbounded_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.ExpressionWidth.unbounded)
}
inline ::acvm::acir::circuit::ExpressionWidth_Unbounded* ExpressionWidth::_internal_mutable_unbounded() {
  if (value_case() != kUnbounded) {
    clear_value();
    set_has_unbounded();
    _impl_.value_.unbounded_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::ExpressionWidth_Unbounded>(GetArena());
  }
  return _impl_.value_.unbounded_;
}
inline ::acvm::acir::circuit::ExpressionWidth_Unbounded* ExpressionWidth::mutable_unbounded() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::circuit::ExpressionWidth_Unbounded* _msg = _internal_mutable_unbounded();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.ExpressionWidth.unbounded)
  return _msg;
}

// .acvm.acir.circuit.ExpressionWidth.Bounded bounded = 2;
inline bool ExpressionWidth::has_bounded() const {
  return value_case() == kBounded;
}
inline bool ExpressionWidth::_internal_has_bounded() const {
  return value_case() == kBounded;
}
inline void ExpressionWidth::set_has_bounded() {
  _impl_._oneof_case_[0] = kBounded;
}
inline void ExpressionWidth::clear_bounded() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kBounded) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.bounded_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.bounded_);
    }
    clear_has_value();
  }
}
inline ::acvm::acir::circuit::ExpressionWidth_Bounded* ExpressionWidth::release_bounded() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.ExpressionWidth.bounded)
  if (value_case() == kBounded) {
    clear_has_value();
    auto* temp = _impl_.value_.bounded_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.bounded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::circuit::ExpressionWidth_Bounded& ExpressionWidth::_internal_bounded() const {
  return value_case() == kBounded ? *_impl_.value_.bounded_ : reinterpret_cast<::acvm::acir::circuit::ExpressionWidth_Bounded&>(::acvm::acir::circuit::_ExpressionWidth_Bounded_default_instance_);
}
inline const ::acvm::acir::circuit::ExpressionWidth_Bounded& ExpressionWidth::bounded() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.ExpressionWidth.bounded)
  return _internal_bounded();
}
inline ::acvm::acir::circuit::ExpressionWidth_Bounded* ExpressionWidth::unsafe_arena_release_bounded() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.ExpressionWidth.bounded)
  if (value_case() == kBounded) {
    clear_has_value();
    auto* temp = _impl_.value_.bounded_;
    _impl_.value_.bounded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ExpressionWidth::unsafe_arena_set_allocated_bounded(::acvm::acir::circuit::ExpressionWidth_Bounded* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_bounded();
    _impl_.value_.bounded_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.ExpressionWidth.bounded)
}
inline ::acvm::acir::circuit::ExpressionWidth_Bounded* ExpressionWidth::_internal_mutable_bounded() {
  if (value_case() != kBounded) {
    clear_value();
    set_has_bounded();
    _impl_.value_.bounded_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::ExpressionWidth_Bounded>(GetArena());
  }
  return _impl_.value_.bounded_;
}
inline ::acvm::acir::circuit::ExpressionWidth_Bounded* ExpressionWidth::mutable_bounded() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::circuit::ExpressionWidth_Bounded* _msg = _internal_mutable_bounded();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.ExpressionWidth.bounded)
  return _msg;
}

inline bool ExpressionWidth::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void ExpressionWidth::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline ExpressionWidth::ValueCase ExpressionWidth::value_case() const {
  return ExpressionWidth::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AssertMessage

// .acvm.acir.circuit.OpcodeLocation location = 1;
inline bool AssertMessage::has_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.location_ != nullptr);
  return value;
}
inline void AssertMessage::clear_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.location_ != nullptr) _impl_.location_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::acvm::acir::circuit::OpcodeLocation& AssertMessage::_internal_location() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::acvm::acir::circuit::OpcodeLocation* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::acvm::acir::circuit::OpcodeLocation&>(::acvm::acir::circuit::_OpcodeLocation_default_instance_);
}
inline const ::acvm::acir::circuit::OpcodeLocation& AssertMessage::location() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.AssertMessage.location)
  return _internal_location();
}
inline void AssertMessage::unsafe_arena_set_allocated_location(::acvm::acir::circuit::OpcodeLocation* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = reinterpret_cast<::acvm::acir::circuit::OpcodeLocation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.AssertMessage.location)
}
inline ::acvm::acir::circuit::OpcodeLocation* AssertMessage::release_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::acvm::acir::circuit::OpcodeLocation* released = _impl_.location_;
  _impl_.location_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::acvm::acir::circuit::OpcodeLocation* AssertMessage::unsafe_arena_release_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.AssertMessage.location)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::acvm::acir::circuit::OpcodeLocation* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::acvm::acir::circuit::OpcodeLocation* AssertMessage::_internal_mutable_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.location_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::OpcodeLocation>(GetArena());
    _impl_.location_ = reinterpret_cast<::acvm::acir::circuit::OpcodeLocation*>(p);
  }
  return _impl_.location_;
}
inline ::acvm::acir::circuit::OpcodeLocation* AssertMessage::mutable_location() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::acvm::acir::circuit::OpcodeLocation* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.AssertMessage.location)
  return _msg;
}
inline void AssertMessage::set_allocated_location(::acvm::acir::circuit::OpcodeLocation* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.location_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.location_ = reinterpret_cast<::acvm::acir::circuit::OpcodeLocation*>(value);
  // @@protoc_insertion_point(field_set_allocated:acvm.acir.circuit.AssertMessage.location)
}

// .acvm.acir.circuit.AssertionPayload payload = 2;
inline bool AssertMessage::has_payload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.payload_ != nullptr);
  return value;
}
inline void AssertMessage::clear_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.payload_ != nullptr) _impl_.payload_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::acvm::acir::circuit::AssertionPayload& AssertMessage::_internal_payload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::acvm::acir::circuit::AssertionPayload* p = _impl_.payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::acvm::acir::circuit::AssertionPayload&>(::acvm::acir::circuit::_AssertionPayload_default_instance_);
}
inline const ::acvm::acir::circuit::AssertionPayload& AssertMessage::payload() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.AssertMessage.payload)
  return _internal_payload();
}
inline void AssertMessage::unsafe_arena_set_allocated_payload(::acvm::acir::circuit::AssertionPayload* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.payload_);
  }
  _impl_.payload_ = reinterpret_cast<::acvm::acir::circuit::AssertionPayload*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.AssertMessage.payload)
}
inline ::acvm::acir::circuit::AssertionPayload* AssertMessage::release_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::acvm::acir::circuit::AssertionPayload* released = _impl_.payload_;
  _impl_.payload_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::acvm::acir::circuit::AssertionPayload* AssertMessage::unsafe_arena_release_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.AssertMessage.payload)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::acvm::acir::circuit::AssertionPayload* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
  return temp;
}
inline ::acvm::acir::circuit::AssertionPayload* AssertMessage::_internal_mutable_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.payload_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::AssertionPayload>(GetArena());
    _impl_.payload_ = reinterpret_cast<::acvm::acir::circuit::AssertionPayload*>(p);
  }
  return _impl_.payload_;
}
inline ::acvm::acir::circuit::AssertionPayload* AssertMessage::mutable_payload() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::acvm::acir::circuit::AssertionPayload* _msg = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.AssertMessage.payload)
  return _msg;
}
inline void AssertMessage::set_allocated_payload(::acvm::acir::circuit::AssertionPayload* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.payload_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.payload_ = reinterpret_cast<::acvm::acir::circuit::AssertionPayload*>(value);
  // @@protoc_insertion_point(field_set_allocated:acvm.acir.circuit.AssertMessage.payload)
}

// -------------------------------------------------------------------

// OpcodeLocation_BrilligLocation

// uint64 acir_index = 1;
inline void OpcodeLocation_BrilligLocation::clear_acir_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.acir_index_ = ::uint64_t{0u};
}
inline ::uint64_t OpcodeLocation_BrilligLocation::acir_index() const {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.OpcodeLocation.BrilligLocation.acir_index)
  return _internal_acir_index();
}
inline void OpcodeLocation_BrilligLocation::set_acir_index(::uint64_t value) {
  _internal_set_acir_index(value);
  // @@protoc_insertion_point(field_set:acvm.acir.circuit.OpcodeLocation.BrilligLocation.acir_index)
}
inline ::uint64_t OpcodeLocation_BrilligLocation::_internal_acir_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.acir_index_;
}
inline void OpcodeLocation_BrilligLocation::_internal_set_acir_index(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.acir_index_ = value;
}

// uint64 brillig_index = 2;
inline void OpcodeLocation_BrilligLocation::clear_brillig_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.brillig_index_ = ::uint64_t{0u};
}
inline ::uint64_t OpcodeLocation_BrilligLocation::brillig_index() const {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.OpcodeLocation.BrilligLocation.brillig_index)
  return _internal_brillig_index();
}
inline void OpcodeLocation_BrilligLocation::set_brillig_index(::uint64_t value) {
  _internal_set_brillig_index(value);
  // @@protoc_insertion_point(field_set:acvm.acir.circuit.OpcodeLocation.BrilligLocation.brillig_index)
}
inline ::uint64_t OpcodeLocation_BrilligLocation::_internal_brillig_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.brillig_index_;
}
inline void OpcodeLocation_BrilligLocation::_internal_set_brillig_index(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.brillig_index_ = value;
}

// -------------------------------------------------------------------

// OpcodeLocation

// uint64 acir = 1;
inline bool OpcodeLocation::has_acir() const {
  return value_case() == kAcir;
}
inline void OpcodeLocation::set_has_acir() {
  _impl_._oneof_case_[0] = kAcir;
}
inline void OpcodeLocation::clear_acir() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kAcir) {
    _impl_.value_.acir_ = ::uint64_t{0u};
    clear_has_value();
  }
}
inline ::uint64_t OpcodeLocation::acir() const {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.OpcodeLocation.acir)
  return _internal_acir();
}
inline void OpcodeLocation::set_acir(::uint64_t value) {
  if (value_case() != kAcir) {
    clear_value();
    set_has_acir();
  }
  _impl_.value_.acir_ = value;
  // @@protoc_insertion_point(field_set:acvm.acir.circuit.OpcodeLocation.acir)
}
inline ::uint64_t OpcodeLocation::_internal_acir() const {
  if (value_case() == kAcir) {
    return _impl_.value_.acir_;
  }
  return ::uint64_t{0u};
}

// .acvm.acir.circuit.OpcodeLocation.BrilligLocation brillig = 2;
inline bool OpcodeLocation::has_brillig() const {
  return value_case() == kBrillig;
}
inline bool OpcodeLocation::_internal_has_brillig() const {
  return value_case() == kBrillig;
}
inline void OpcodeLocation::set_has_brillig() {
  _impl_._oneof_case_[0] = kBrillig;
}
inline void OpcodeLocation::clear_brillig() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kBrillig) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.brillig_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.brillig_);
    }
    clear_has_value();
  }
}
inline ::acvm::acir::circuit::OpcodeLocation_BrilligLocation* OpcodeLocation::release_brillig() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.OpcodeLocation.brillig)
  if (value_case() == kBrillig) {
    clear_has_value();
    auto* temp = _impl_.value_.brillig_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.brillig_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::circuit::OpcodeLocation_BrilligLocation& OpcodeLocation::_internal_brillig() const {
  return value_case() == kBrillig ? *_impl_.value_.brillig_ : reinterpret_cast<::acvm::acir::circuit::OpcodeLocation_BrilligLocation&>(::acvm::acir::circuit::_OpcodeLocation_BrilligLocation_default_instance_);
}
inline const ::acvm::acir::circuit::OpcodeLocation_BrilligLocation& OpcodeLocation::brillig() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.OpcodeLocation.brillig)
  return _internal_brillig();
}
inline ::acvm::acir::circuit::OpcodeLocation_BrilligLocation* OpcodeLocation::unsafe_arena_release_brillig() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.OpcodeLocation.brillig)
  if (value_case() == kBrillig) {
    clear_has_value();
    auto* temp = _impl_.value_.brillig_;
    _impl_.value_.brillig_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OpcodeLocation::unsafe_arena_set_allocated_brillig(::acvm::acir::circuit::OpcodeLocation_BrilligLocation* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_brillig();
    _impl_.value_.brillig_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.OpcodeLocation.brillig)
}
inline ::acvm::acir::circuit::OpcodeLocation_BrilligLocation* OpcodeLocation::_internal_mutable_brillig() {
  if (value_case() != kBrillig) {
    clear_value();
    set_has_brillig();
    _impl_.value_.brillig_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::OpcodeLocation_BrilligLocation>(GetArena());
  }
  return _impl_.value_.brillig_;
}
inline ::acvm::acir::circuit::OpcodeLocation_BrilligLocation* OpcodeLocation::mutable_brillig() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::circuit::OpcodeLocation_BrilligLocation* _msg = _internal_mutable_brillig();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.OpcodeLocation.brillig)
  return _msg;
}

inline bool OpcodeLocation::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void OpcodeLocation::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline OpcodeLocation::ValueCase OpcodeLocation::value_case() const {
  return OpcodeLocation::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AssertionPayload

// uint64 error_selector = 1;
inline void AssertionPayload::clear_error_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_selector_ = ::uint64_t{0u};
}
inline ::uint64_t AssertionPayload::error_selector() const {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.AssertionPayload.error_selector)
  return _internal_error_selector();
}
inline void AssertionPayload::set_error_selector(::uint64_t value) {
  _internal_set_error_selector(value);
  // @@protoc_insertion_point(field_set:acvm.acir.circuit.AssertionPayload.error_selector)
}
inline ::uint64_t AssertionPayload::_internal_error_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_selector_;
}
inline void AssertionPayload::_internal_set_error_selector(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_selector_ = value;
}

// repeated .acvm.acir.circuit.ExpressionOrMemory payload = 2;
inline int AssertionPayload::_internal_payload_size() const {
  return _internal_payload().size();
}
inline int AssertionPayload::payload_size() const {
  return _internal_payload_size();
}
inline void AssertionPayload::clear_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_.Clear();
}
inline ::acvm::acir::circuit::ExpressionOrMemory* AssertionPayload::mutable_payload(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.AssertionPayload.payload)
  return _internal_mutable_payload()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::ExpressionOrMemory>* AssertionPayload::mutable_payload()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.AssertionPayload.payload)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_payload();
}
inline const ::acvm::acir::circuit::ExpressionOrMemory& AssertionPayload::payload(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.AssertionPayload.payload)
  return _internal_payload().Get(index);
}
inline ::acvm::acir::circuit::ExpressionOrMemory* AssertionPayload::add_payload() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::circuit::ExpressionOrMemory* _add = _internal_mutable_payload()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.AssertionPayload.payload)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::ExpressionOrMemory>& AssertionPayload::payload() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.AssertionPayload.payload)
  return _internal_payload();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::ExpressionOrMemory>&
AssertionPayload::_internal_payload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.payload_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::ExpressionOrMemory>*
AssertionPayload::_internal_mutable_payload() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.payload_;
}

// -------------------------------------------------------------------

// ExpressionOrMemory

// .acvm.acir.native.Expression expression = 1;
inline bool ExpressionOrMemory::has_expression() const {
  return value_case() == kExpression;
}
inline bool ExpressionOrMemory::_internal_has_expression() const {
  return value_case() == kExpression;
}
inline void ExpressionOrMemory::set_has_expression() {
  _impl_._oneof_case_[0] = kExpression;
}
inline ::acvm::acir::native::Expression* ExpressionOrMemory::release_expression() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.ExpressionOrMemory.expression)
  if (value_case() == kExpression) {
    clear_has_value();
    auto* temp = _impl_.value_.expression_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.expression_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::native::Expression& ExpressionOrMemory::_internal_expression() const {
  return value_case() == kExpression ? *_impl_.value_.expression_ : reinterpret_cast<::acvm::acir::native::Expression&>(::acvm::acir::native::_Expression_default_instance_);
}
inline const ::acvm::acir::native::Expression& ExpressionOrMemory::expression() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.ExpressionOrMemory.expression)
  return _internal_expression();
}
inline ::acvm::acir::native::Expression* ExpressionOrMemory::unsafe_arena_release_expression() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.ExpressionOrMemory.expression)
  if (value_case() == kExpression) {
    clear_has_value();
    auto* temp = _impl_.value_.expression_;
    _impl_.value_.expression_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ExpressionOrMemory::unsafe_arena_set_allocated_expression(::acvm::acir::native::Expression* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_expression();
    _impl_.value_.expression_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.ExpressionOrMemory.expression)
}
inline ::acvm::acir::native::Expression* ExpressionOrMemory::_internal_mutable_expression() {
  if (value_case() != kExpression) {
    clear_value();
    set_has_expression();
    _impl_.value_.expression_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::native::Expression>(GetArena());
  }
  return _impl_.value_.expression_;
}
inline ::acvm::acir::native::Expression* ExpressionOrMemory::mutable_expression() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::native::Expression* _msg = _internal_mutable_expression();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.ExpressionOrMemory.expression)
  return _msg;
}

// uint32 memory = 2;
inline bool ExpressionOrMemory::has_memory() const {
  return value_case() == kMemory;
}
inline void ExpressionOrMemory::set_has_memory() {
  _impl_._oneof_case_[0] = kMemory;
}
inline void ExpressionOrMemory::clear_memory() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kMemory) {
    _impl_.value_.memory_ = 0u;
    clear_has_value();
  }
}
inline ::uint32_t ExpressionOrMemory::memory() const {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.ExpressionOrMemory.memory)
  return _internal_memory();
}
inline void ExpressionOrMemory::set_memory(::uint32_t value) {
  if (value_case() != kMemory) {
    clear_value();
    set_has_memory();
  }
  _impl_.value_.memory_ = value;
  // @@protoc_insertion_point(field_set:acvm.acir.circuit.ExpressionOrMemory.memory)
}
inline ::uint32_t ExpressionOrMemory::_internal_memory() const {
  if (value_case() == kMemory) {
    return _impl_.value_.memory_;
  }
  return 0u;
}

inline bool ExpressionOrMemory::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void ExpressionOrMemory::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline ExpressionOrMemory::ValueCase ExpressionOrMemory::value_case() const {
  return ExpressionOrMemory::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Opcode_MemoryOp

// uint32 block_id = 1;
inline void Opcode_MemoryOp::clear_block_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.block_id_ = 0u;
}
inline ::uint32_t Opcode_MemoryOp::block_id() const {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.Opcode.MemoryOp.block_id)
  return _internal_block_id();
}
inline void Opcode_MemoryOp::set_block_id(::uint32_t value) {
  _internal_set_block_id(value);
  // @@protoc_insertion_point(field_set:acvm.acir.circuit.Opcode.MemoryOp.block_id)
}
inline ::uint32_t Opcode_MemoryOp::_internal_block_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.block_id_;
}
inline void Opcode_MemoryOp::_internal_set_block_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.block_id_ = value;
}

// .acvm.acir.circuit.MemOp op = 2;
inline bool Opcode_MemoryOp::has_op() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.op_ != nullptr);
  return value;
}
inline void Opcode_MemoryOp::clear_op() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.op_ != nullptr) _impl_.op_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::acvm::acir::circuit::MemOp& Opcode_MemoryOp::_internal_op() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::acvm::acir::circuit::MemOp* p = _impl_.op_;
  return p != nullptr ? *p : reinterpret_cast<const ::acvm::acir::circuit::MemOp&>(::acvm::acir::circuit::_MemOp_default_instance_);
}
inline const ::acvm::acir::circuit::MemOp& Opcode_MemoryOp::op() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.Opcode.MemoryOp.op)
  return _internal_op();
}
inline void Opcode_MemoryOp::unsafe_arena_set_allocated_op(::acvm::acir::circuit::MemOp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.op_);
  }
  _impl_.op_ = reinterpret_cast<::acvm::acir::circuit::MemOp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.Opcode.MemoryOp.op)
}
inline ::acvm::acir::circuit::MemOp* Opcode_MemoryOp::release_op() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::acvm::acir::circuit::MemOp* released = _impl_.op_;
  _impl_.op_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::acvm::acir::circuit::MemOp* Opcode_MemoryOp::unsafe_arena_release_op() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.Opcode.MemoryOp.op)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::acvm::acir::circuit::MemOp* temp = _impl_.op_;
  _impl_.op_ = nullptr;
  return temp;
}
inline ::acvm::acir::circuit::MemOp* Opcode_MemoryOp::_internal_mutable_op() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.op_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::MemOp>(GetArena());
    _impl_.op_ = reinterpret_cast<::acvm::acir::circuit::MemOp*>(p);
  }
  return _impl_.op_;
}
inline ::acvm::acir::circuit::MemOp* Opcode_MemoryOp::mutable_op() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::acvm::acir::circuit::MemOp* _msg = _internal_mutable_op();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.Opcode.MemoryOp.op)
  return _msg;
}
inline void Opcode_MemoryOp::set_allocated_op(::acvm::acir::circuit::MemOp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.op_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.op_ = reinterpret_cast<::acvm::acir::circuit::MemOp*>(value);
  // @@protoc_insertion_point(field_set_allocated:acvm.acir.circuit.Opcode.MemoryOp.op)
}

// optional .acvm.acir.native.Expression predicate = 3;
inline bool Opcode_MemoryOp::has_predicate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.predicate_ != nullptr);
  return value;
}
inline const ::acvm::acir::native::Expression& Opcode_MemoryOp::_internal_predicate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::acvm::acir::native::Expression* p = _impl_.predicate_;
  return p != nullptr ? *p : reinterpret_cast<const ::acvm::acir::native::Expression&>(::acvm::acir::native::_Expression_default_instance_);
}
inline const ::acvm::acir::native::Expression& Opcode_MemoryOp::predicate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.Opcode.MemoryOp.predicate)
  return _internal_predicate();
}
inline void Opcode_MemoryOp::unsafe_arena_set_allocated_predicate(::acvm::acir::native::Expression* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.predicate_);
  }
  _impl_.predicate_ = reinterpret_cast<::acvm::acir::native::Expression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.Opcode.MemoryOp.predicate)
}
inline ::acvm::acir::native::Expression* Opcode_MemoryOp::release_predicate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::acvm::acir::native::Expression* released = _impl_.predicate_;
  _impl_.predicate_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::acvm::acir::native::Expression* Opcode_MemoryOp::unsafe_arena_release_predicate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.Opcode.MemoryOp.predicate)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::acvm::acir::native::Expression* temp = _impl_.predicate_;
  _impl_.predicate_ = nullptr;
  return temp;
}
inline ::acvm::acir::native::Expression* Opcode_MemoryOp::_internal_mutable_predicate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.predicate_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::acvm::acir::native::Expression>(GetArena());
    _impl_.predicate_ = reinterpret_cast<::acvm::acir::native::Expression*>(p);
  }
  return _impl_.predicate_;
}
inline ::acvm::acir::native::Expression* Opcode_MemoryOp::mutable_predicate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::acvm::acir::native::Expression* _msg = _internal_mutable_predicate();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.Opcode.MemoryOp.predicate)
  return _msg;
}
inline void Opcode_MemoryOp::set_allocated_predicate(::acvm::acir::native::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.predicate_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.predicate_ = reinterpret_cast<::acvm::acir::native::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:acvm.acir.circuit.Opcode.MemoryOp.predicate)
}

// -------------------------------------------------------------------

// Opcode_MemoryInit

// uint32 block_id = 1;
inline void Opcode_MemoryInit::clear_block_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.block_id_ = 0u;
}
inline ::uint32_t Opcode_MemoryInit::block_id() const {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.Opcode.MemoryInit.block_id)
  return _internal_block_id();
}
inline void Opcode_MemoryInit::set_block_id(::uint32_t value) {
  _internal_set_block_id(value);
  // @@protoc_insertion_point(field_set:acvm.acir.circuit.Opcode.MemoryInit.block_id)
}
inline ::uint32_t Opcode_MemoryInit::_internal_block_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.block_id_;
}
inline void Opcode_MemoryInit::_internal_set_block_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.block_id_ = value;
}

// repeated .acvm.acir.native.Witness init = 2;
inline int Opcode_MemoryInit::_internal_init_size() const {
  return _internal_init().size();
}
inline int Opcode_MemoryInit::init_size() const {
  return _internal_init_size();
}
inline ::acvm::acir::native::Witness* Opcode_MemoryInit::mutable_init(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.Opcode.MemoryInit.init)
  return _internal_mutable_init()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* Opcode_MemoryInit::mutable_init()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.Opcode.MemoryInit.init)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_init();
}
inline const ::acvm::acir::native::Witness& Opcode_MemoryInit::init(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.Opcode.MemoryInit.init)
  return _internal_init().Get(index);
}
inline ::acvm::acir::native::Witness* Opcode_MemoryInit::add_init() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::native::Witness* _add = _internal_mutable_init()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.Opcode.MemoryInit.init)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& Opcode_MemoryInit::init() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.Opcode.MemoryInit.init)
  return _internal_init();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>&
Opcode_MemoryInit::_internal_init() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.init_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>*
Opcode_MemoryInit::_internal_mutable_init() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.init_;
}

// .acvm.acir.circuit.BlockType block_type = 3;
inline bool Opcode_MemoryInit::has_block_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.block_type_ != nullptr);
  return value;
}
inline void Opcode_MemoryInit::clear_block_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.block_type_ != nullptr) _impl_.block_type_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::acvm::acir::circuit::BlockType& Opcode_MemoryInit::_internal_block_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::acvm::acir::circuit::BlockType* p = _impl_.block_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::acvm::acir::circuit::BlockType&>(::acvm::acir::circuit::_BlockType_default_instance_);
}
inline const ::acvm::acir::circuit::BlockType& Opcode_MemoryInit::block_type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.Opcode.MemoryInit.block_type)
  return _internal_block_type();
}
inline void Opcode_MemoryInit::unsafe_arena_set_allocated_block_type(::acvm::acir::circuit::BlockType* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.block_type_);
  }
  _impl_.block_type_ = reinterpret_cast<::acvm::acir::circuit::BlockType*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.Opcode.MemoryInit.block_type)
}
inline ::acvm::acir::circuit::BlockType* Opcode_MemoryInit::release_block_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::acvm::acir::circuit::BlockType* released = _impl_.block_type_;
  _impl_.block_type_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::acvm::acir::circuit::BlockType* Opcode_MemoryInit::unsafe_arena_release_block_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.Opcode.MemoryInit.block_type)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::acvm::acir::circuit::BlockType* temp = _impl_.block_type_;
  _impl_.block_type_ = nullptr;
  return temp;
}
inline ::acvm::acir::circuit::BlockType* Opcode_MemoryInit::_internal_mutable_block_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.block_type_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::BlockType>(GetArena());
    _impl_.block_type_ = reinterpret_cast<::acvm::acir::circuit::BlockType*>(p);
  }
  return _impl_.block_type_;
}
inline ::acvm::acir::circuit::BlockType* Opcode_MemoryInit::mutable_block_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::acvm::acir::circuit::BlockType* _msg = _internal_mutable_block_type();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.Opcode.MemoryInit.block_type)
  return _msg;
}
inline void Opcode_MemoryInit::set_allocated_block_type(::acvm::acir::circuit::BlockType* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.block_type_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.block_type_ = reinterpret_cast<::acvm::acir::circuit::BlockType*>(value);
  // @@protoc_insertion_point(field_set_allocated:acvm.acir.circuit.Opcode.MemoryInit.block_type)
}

// -------------------------------------------------------------------

// Opcode_BrilligCall

// uint32 id = 1;
inline void Opcode_BrilligCall::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0u;
}
inline ::uint32_t Opcode_BrilligCall::id() const {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.Opcode.BrilligCall.id)
  return _internal_id();
}
inline void Opcode_BrilligCall::set_id(::uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:acvm.acir.circuit.Opcode.BrilligCall.id)
}
inline ::uint32_t Opcode_BrilligCall::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void Opcode_BrilligCall::_internal_set_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// repeated .acvm.acir.circuit.BrilligInputs inputs = 2;
inline int Opcode_BrilligCall::_internal_inputs_size() const {
  return _internal_inputs().size();
}
inline int Opcode_BrilligCall::inputs_size() const {
  return _internal_inputs_size();
}
inline void Opcode_BrilligCall::clear_inputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inputs_.Clear();
}
inline ::acvm::acir::circuit::BrilligInputs* Opcode_BrilligCall::mutable_inputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.Opcode.BrilligCall.inputs)
  return _internal_mutable_inputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::BrilligInputs>* Opcode_BrilligCall::mutable_inputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.Opcode.BrilligCall.inputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_inputs();
}
inline const ::acvm::acir::circuit::BrilligInputs& Opcode_BrilligCall::inputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.Opcode.BrilligCall.inputs)
  return _internal_inputs().Get(index);
}
inline ::acvm::acir::circuit::BrilligInputs* Opcode_BrilligCall::add_inputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::circuit::BrilligInputs* _add = _internal_mutable_inputs()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.Opcode.BrilligCall.inputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::BrilligInputs>& Opcode_BrilligCall::inputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.Opcode.BrilligCall.inputs)
  return _internal_inputs();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::BrilligInputs>&
Opcode_BrilligCall::_internal_inputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.inputs_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::BrilligInputs>*
Opcode_BrilligCall::_internal_mutable_inputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.inputs_;
}

// repeated .acvm.acir.circuit.BrilligOutputs outputs = 3;
inline int Opcode_BrilligCall::_internal_outputs_size() const {
  return _internal_outputs().size();
}
inline int Opcode_BrilligCall::outputs_size() const {
  return _internal_outputs_size();
}
inline void Opcode_BrilligCall::clear_outputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.outputs_.Clear();
}
inline ::acvm::acir::circuit::BrilligOutputs* Opcode_BrilligCall::mutable_outputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.Opcode.BrilligCall.outputs)
  return _internal_mutable_outputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::BrilligOutputs>* Opcode_BrilligCall::mutable_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.Opcode.BrilligCall.outputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_outputs();
}
inline const ::acvm::acir::circuit::BrilligOutputs& Opcode_BrilligCall::outputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.Opcode.BrilligCall.outputs)
  return _internal_outputs().Get(index);
}
inline ::acvm::acir::circuit::BrilligOutputs* Opcode_BrilligCall::add_outputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::circuit::BrilligOutputs* _add = _internal_mutable_outputs()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.Opcode.BrilligCall.outputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::BrilligOutputs>& Opcode_BrilligCall::outputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.Opcode.BrilligCall.outputs)
  return _internal_outputs();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::BrilligOutputs>&
Opcode_BrilligCall::_internal_outputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.outputs_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::BrilligOutputs>*
Opcode_BrilligCall::_internal_mutable_outputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.outputs_;
}

// optional .acvm.acir.native.Expression predicate = 4;
inline bool Opcode_BrilligCall::has_predicate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.predicate_ != nullptr);
  return value;
}
inline const ::acvm::acir::native::Expression& Opcode_BrilligCall::_internal_predicate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::acvm::acir::native::Expression* p = _impl_.predicate_;
  return p != nullptr ? *p : reinterpret_cast<const ::acvm::acir::native::Expression&>(::acvm::acir::native::_Expression_default_instance_);
}
inline const ::acvm::acir::native::Expression& Opcode_BrilligCall::predicate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.Opcode.BrilligCall.predicate)
  return _internal_predicate();
}
inline void Opcode_BrilligCall::unsafe_arena_set_allocated_predicate(::acvm::acir::native::Expression* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.predicate_);
  }
  _impl_.predicate_ = reinterpret_cast<::acvm::acir::native::Expression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.Opcode.BrilligCall.predicate)
}
inline ::acvm::acir::native::Expression* Opcode_BrilligCall::release_predicate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::acvm::acir::native::Expression* released = _impl_.predicate_;
  _impl_.predicate_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::acvm::acir::native::Expression* Opcode_BrilligCall::unsafe_arena_release_predicate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.Opcode.BrilligCall.predicate)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::acvm::acir::native::Expression* temp = _impl_.predicate_;
  _impl_.predicate_ = nullptr;
  return temp;
}
inline ::acvm::acir::native::Expression* Opcode_BrilligCall::_internal_mutable_predicate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.predicate_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::acvm::acir::native::Expression>(GetArena());
    _impl_.predicate_ = reinterpret_cast<::acvm::acir::native::Expression*>(p);
  }
  return _impl_.predicate_;
}
inline ::acvm::acir::native::Expression* Opcode_BrilligCall::mutable_predicate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::acvm::acir::native::Expression* _msg = _internal_mutable_predicate();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.Opcode.BrilligCall.predicate)
  return _msg;
}
inline void Opcode_BrilligCall::set_allocated_predicate(::acvm::acir::native::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.predicate_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.predicate_ = reinterpret_cast<::acvm::acir::native::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:acvm.acir.circuit.Opcode.BrilligCall.predicate)
}

// -------------------------------------------------------------------

// Opcode_Call

// uint32 id = 1;
inline void Opcode_Call::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0u;
}
inline ::uint32_t Opcode_Call::id() const {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.Opcode.Call.id)
  return _internal_id();
}
inline void Opcode_Call::set_id(::uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:acvm.acir.circuit.Opcode.Call.id)
}
inline ::uint32_t Opcode_Call::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void Opcode_Call::_internal_set_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// repeated .acvm.acir.native.Witness inputs = 2;
inline int Opcode_Call::_internal_inputs_size() const {
  return _internal_inputs().size();
}
inline int Opcode_Call::inputs_size() const {
  return _internal_inputs_size();
}
inline ::acvm::acir::native::Witness* Opcode_Call::mutable_inputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.Opcode.Call.inputs)
  return _internal_mutable_inputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* Opcode_Call::mutable_inputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.Opcode.Call.inputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_inputs();
}
inline const ::acvm::acir::native::Witness& Opcode_Call::inputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.Opcode.Call.inputs)
  return _internal_inputs().Get(index);
}
inline ::acvm::acir::native::Witness* Opcode_Call::add_inputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::native::Witness* _add = _internal_mutable_inputs()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.Opcode.Call.inputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& Opcode_Call::inputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.Opcode.Call.inputs)
  return _internal_inputs();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>&
Opcode_Call::_internal_inputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.inputs_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>*
Opcode_Call::_internal_mutable_inputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.inputs_;
}

// repeated .acvm.acir.native.Witness outputs = 3;
inline int Opcode_Call::_internal_outputs_size() const {
  return _internal_outputs().size();
}
inline int Opcode_Call::outputs_size() const {
  return _internal_outputs_size();
}
inline ::acvm::acir::native::Witness* Opcode_Call::mutable_outputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.Opcode.Call.outputs)
  return _internal_mutable_outputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* Opcode_Call::mutable_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.Opcode.Call.outputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_outputs();
}
inline const ::acvm::acir::native::Witness& Opcode_Call::outputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.Opcode.Call.outputs)
  return _internal_outputs().Get(index);
}
inline ::acvm::acir::native::Witness* Opcode_Call::add_outputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::native::Witness* _add = _internal_mutable_outputs()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.Opcode.Call.outputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& Opcode_Call::outputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.Opcode.Call.outputs)
  return _internal_outputs();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>&
Opcode_Call::_internal_outputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.outputs_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>*
Opcode_Call::_internal_mutable_outputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.outputs_;
}

// optional .acvm.acir.native.Expression predicate = 4;
inline bool Opcode_Call::has_predicate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.predicate_ != nullptr);
  return value;
}
inline const ::acvm::acir::native::Expression& Opcode_Call::_internal_predicate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::acvm::acir::native::Expression* p = _impl_.predicate_;
  return p != nullptr ? *p : reinterpret_cast<const ::acvm::acir::native::Expression&>(::acvm::acir::native::_Expression_default_instance_);
}
inline const ::acvm::acir::native::Expression& Opcode_Call::predicate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.Opcode.Call.predicate)
  return _internal_predicate();
}
inline void Opcode_Call::unsafe_arena_set_allocated_predicate(::acvm::acir::native::Expression* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.predicate_);
  }
  _impl_.predicate_ = reinterpret_cast<::acvm::acir::native::Expression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.Opcode.Call.predicate)
}
inline ::acvm::acir::native::Expression* Opcode_Call::release_predicate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::acvm::acir::native::Expression* released = _impl_.predicate_;
  _impl_.predicate_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::acvm::acir::native::Expression* Opcode_Call::unsafe_arena_release_predicate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.Opcode.Call.predicate)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::acvm::acir::native::Expression* temp = _impl_.predicate_;
  _impl_.predicate_ = nullptr;
  return temp;
}
inline ::acvm::acir::native::Expression* Opcode_Call::_internal_mutable_predicate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.predicate_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::acvm::acir::native::Expression>(GetArena());
    _impl_.predicate_ = reinterpret_cast<::acvm::acir::native::Expression*>(p);
  }
  return _impl_.predicate_;
}
inline ::acvm::acir::native::Expression* Opcode_Call::mutable_predicate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::acvm::acir::native::Expression* _msg = _internal_mutable_predicate();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.Opcode.Call.predicate)
  return _msg;
}
inline void Opcode_Call::set_allocated_predicate(::acvm::acir::native::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.predicate_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.predicate_ = reinterpret_cast<::acvm::acir::native::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:acvm.acir.circuit.Opcode.Call.predicate)
}

// -------------------------------------------------------------------

// Opcode

// .acvm.acir.native.Expression assert_zero = 1;
inline bool Opcode::has_assert_zero() const {
  return value_case() == kAssertZero;
}
inline bool Opcode::_internal_has_assert_zero() const {
  return value_case() == kAssertZero;
}
inline void Opcode::set_has_assert_zero() {
  _impl_._oneof_case_[0] = kAssertZero;
}
inline ::acvm::acir::native::Expression* Opcode::release_assert_zero() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.Opcode.assert_zero)
  if (value_case() == kAssertZero) {
    clear_has_value();
    auto* temp = _impl_.value_.assert_zero_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.assert_zero_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::native::Expression& Opcode::_internal_assert_zero() const {
  return value_case() == kAssertZero ? *_impl_.value_.assert_zero_ : reinterpret_cast<::acvm::acir::native::Expression&>(::acvm::acir::native::_Expression_default_instance_);
}
inline const ::acvm::acir::native::Expression& Opcode::assert_zero() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.Opcode.assert_zero)
  return _internal_assert_zero();
}
inline ::acvm::acir::native::Expression* Opcode::unsafe_arena_release_assert_zero() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.Opcode.assert_zero)
  if (value_case() == kAssertZero) {
    clear_has_value();
    auto* temp = _impl_.value_.assert_zero_;
    _impl_.value_.assert_zero_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Opcode::unsafe_arena_set_allocated_assert_zero(::acvm::acir::native::Expression* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_assert_zero();
    _impl_.value_.assert_zero_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.Opcode.assert_zero)
}
inline ::acvm::acir::native::Expression* Opcode::_internal_mutable_assert_zero() {
  if (value_case() != kAssertZero) {
    clear_value();
    set_has_assert_zero();
    _impl_.value_.assert_zero_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::native::Expression>(GetArena());
  }
  return _impl_.value_.assert_zero_;
}
inline ::acvm::acir::native::Expression* Opcode::mutable_assert_zero() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::native::Expression* _msg = _internal_mutable_assert_zero();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.Opcode.assert_zero)
  return _msg;
}

// .acvm.acir.circuit.BlackBoxFuncCall blackbox_func_call = 2;
inline bool Opcode::has_blackbox_func_call() const {
  return value_case() == kBlackboxFuncCall;
}
inline bool Opcode::_internal_has_blackbox_func_call() const {
  return value_case() == kBlackboxFuncCall;
}
inline void Opcode::set_has_blackbox_func_call() {
  _impl_._oneof_case_[0] = kBlackboxFuncCall;
}
inline void Opcode::clear_blackbox_func_call() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kBlackboxFuncCall) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.blackbox_func_call_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.blackbox_func_call_);
    }
    clear_has_value();
  }
}
inline ::acvm::acir::circuit::BlackBoxFuncCall* Opcode::release_blackbox_func_call() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.Opcode.blackbox_func_call)
  if (value_case() == kBlackboxFuncCall) {
    clear_has_value();
    auto* temp = _impl_.value_.blackbox_func_call_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.blackbox_func_call_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall& Opcode::_internal_blackbox_func_call() const {
  return value_case() == kBlackboxFuncCall ? *_impl_.value_.blackbox_func_call_ : reinterpret_cast<::acvm::acir::circuit::BlackBoxFuncCall&>(::acvm::acir::circuit::_BlackBoxFuncCall_default_instance_);
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall& Opcode::blackbox_func_call() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.Opcode.blackbox_func_call)
  return _internal_blackbox_func_call();
}
inline ::acvm::acir::circuit::BlackBoxFuncCall* Opcode::unsafe_arena_release_blackbox_func_call() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.Opcode.blackbox_func_call)
  if (value_case() == kBlackboxFuncCall) {
    clear_has_value();
    auto* temp = _impl_.value_.blackbox_func_call_;
    _impl_.value_.blackbox_func_call_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Opcode::unsafe_arena_set_allocated_blackbox_func_call(::acvm::acir::circuit::BlackBoxFuncCall* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_blackbox_func_call();
    _impl_.value_.blackbox_func_call_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.Opcode.blackbox_func_call)
}
inline ::acvm::acir::circuit::BlackBoxFuncCall* Opcode::_internal_mutable_blackbox_func_call() {
  if (value_case() != kBlackboxFuncCall) {
    clear_value();
    set_has_blackbox_func_call();
    _impl_.value_.blackbox_func_call_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::BlackBoxFuncCall>(GetArena());
  }
  return _impl_.value_.blackbox_func_call_;
}
inline ::acvm::acir::circuit::BlackBoxFuncCall* Opcode::mutable_blackbox_func_call() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::circuit::BlackBoxFuncCall* _msg = _internal_mutable_blackbox_func_call();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.Opcode.blackbox_func_call)
  return _msg;
}

// .acvm.acir.circuit.Opcode.MemoryOp memory_op = 3;
inline bool Opcode::has_memory_op() const {
  return value_case() == kMemoryOp;
}
inline bool Opcode::_internal_has_memory_op() const {
  return value_case() == kMemoryOp;
}
inline void Opcode::set_has_memory_op() {
  _impl_._oneof_case_[0] = kMemoryOp;
}
inline void Opcode::clear_memory_op() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kMemoryOp) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.memory_op_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.memory_op_);
    }
    clear_has_value();
  }
}
inline ::acvm::acir::circuit::Opcode_MemoryOp* Opcode::release_memory_op() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.Opcode.memory_op)
  if (value_case() == kMemoryOp) {
    clear_has_value();
    auto* temp = _impl_.value_.memory_op_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.memory_op_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::circuit::Opcode_MemoryOp& Opcode::_internal_memory_op() const {
  return value_case() == kMemoryOp ? *_impl_.value_.memory_op_ : reinterpret_cast<::acvm::acir::circuit::Opcode_MemoryOp&>(::acvm::acir::circuit::_Opcode_MemoryOp_default_instance_);
}
inline const ::acvm::acir::circuit::Opcode_MemoryOp& Opcode::memory_op() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.Opcode.memory_op)
  return _internal_memory_op();
}
inline ::acvm::acir::circuit::Opcode_MemoryOp* Opcode::unsafe_arena_release_memory_op() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.Opcode.memory_op)
  if (value_case() == kMemoryOp) {
    clear_has_value();
    auto* temp = _impl_.value_.memory_op_;
    _impl_.value_.memory_op_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Opcode::unsafe_arena_set_allocated_memory_op(::acvm::acir::circuit::Opcode_MemoryOp* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_memory_op();
    _impl_.value_.memory_op_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.Opcode.memory_op)
}
inline ::acvm::acir::circuit::Opcode_MemoryOp* Opcode::_internal_mutable_memory_op() {
  if (value_case() != kMemoryOp) {
    clear_value();
    set_has_memory_op();
    _impl_.value_.memory_op_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::Opcode_MemoryOp>(GetArena());
  }
  return _impl_.value_.memory_op_;
}
inline ::acvm::acir::circuit::Opcode_MemoryOp* Opcode::mutable_memory_op() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::circuit::Opcode_MemoryOp* _msg = _internal_mutable_memory_op();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.Opcode.memory_op)
  return _msg;
}

// .acvm.acir.circuit.Opcode.MemoryInit memory_init = 4;
inline bool Opcode::has_memory_init() const {
  return value_case() == kMemoryInit;
}
inline bool Opcode::_internal_has_memory_init() const {
  return value_case() == kMemoryInit;
}
inline void Opcode::set_has_memory_init() {
  _impl_._oneof_case_[0] = kMemoryInit;
}
inline void Opcode::clear_memory_init() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kMemoryInit) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.memory_init_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.memory_init_);
    }
    clear_has_value();
  }
}
inline ::acvm::acir::circuit::Opcode_MemoryInit* Opcode::release_memory_init() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.Opcode.memory_init)
  if (value_case() == kMemoryInit) {
    clear_has_value();
    auto* temp = _impl_.value_.memory_init_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.memory_init_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::circuit::Opcode_MemoryInit& Opcode::_internal_memory_init() const {
  return value_case() == kMemoryInit ? *_impl_.value_.memory_init_ : reinterpret_cast<::acvm::acir::circuit::Opcode_MemoryInit&>(::acvm::acir::circuit::_Opcode_MemoryInit_default_instance_);
}
inline const ::acvm::acir::circuit::Opcode_MemoryInit& Opcode::memory_init() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.Opcode.memory_init)
  return _internal_memory_init();
}
inline ::acvm::acir::circuit::Opcode_MemoryInit* Opcode::unsafe_arena_release_memory_init() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.Opcode.memory_init)
  if (value_case() == kMemoryInit) {
    clear_has_value();
    auto* temp = _impl_.value_.memory_init_;
    _impl_.value_.memory_init_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Opcode::unsafe_arena_set_allocated_memory_init(::acvm::acir::circuit::Opcode_MemoryInit* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_memory_init();
    _impl_.value_.memory_init_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.Opcode.memory_init)
}
inline ::acvm::acir::circuit::Opcode_MemoryInit* Opcode::_internal_mutable_memory_init() {
  if (value_case() != kMemoryInit) {
    clear_value();
    set_has_memory_init();
    _impl_.value_.memory_init_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::Opcode_MemoryInit>(GetArena());
  }
  return _impl_.value_.memory_init_;
}
inline ::acvm::acir::circuit::Opcode_MemoryInit* Opcode::mutable_memory_init() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::circuit::Opcode_MemoryInit* _msg = _internal_mutable_memory_init();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.Opcode.memory_init)
  return _msg;
}

// .acvm.acir.circuit.Opcode.BrilligCall brillig_call = 5;
inline bool Opcode::has_brillig_call() const {
  return value_case() == kBrilligCall;
}
inline bool Opcode::_internal_has_brillig_call() const {
  return value_case() == kBrilligCall;
}
inline void Opcode::set_has_brillig_call() {
  _impl_._oneof_case_[0] = kBrilligCall;
}
inline void Opcode::clear_brillig_call() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kBrilligCall) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.brillig_call_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.brillig_call_);
    }
    clear_has_value();
  }
}
inline ::acvm::acir::circuit::Opcode_BrilligCall* Opcode::release_brillig_call() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.Opcode.brillig_call)
  if (value_case() == kBrilligCall) {
    clear_has_value();
    auto* temp = _impl_.value_.brillig_call_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.brillig_call_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::circuit::Opcode_BrilligCall& Opcode::_internal_brillig_call() const {
  return value_case() == kBrilligCall ? *_impl_.value_.brillig_call_ : reinterpret_cast<::acvm::acir::circuit::Opcode_BrilligCall&>(::acvm::acir::circuit::_Opcode_BrilligCall_default_instance_);
}
inline const ::acvm::acir::circuit::Opcode_BrilligCall& Opcode::brillig_call() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.Opcode.brillig_call)
  return _internal_brillig_call();
}
inline ::acvm::acir::circuit::Opcode_BrilligCall* Opcode::unsafe_arena_release_brillig_call() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.Opcode.brillig_call)
  if (value_case() == kBrilligCall) {
    clear_has_value();
    auto* temp = _impl_.value_.brillig_call_;
    _impl_.value_.brillig_call_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Opcode::unsafe_arena_set_allocated_brillig_call(::acvm::acir::circuit::Opcode_BrilligCall* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_brillig_call();
    _impl_.value_.brillig_call_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.Opcode.brillig_call)
}
inline ::acvm::acir::circuit::Opcode_BrilligCall* Opcode::_internal_mutable_brillig_call() {
  if (value_case() != kBrilligCall) {
    clear_value();
    set_has_brillig_call();
    _impl_.value_.brillig_call_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::Opcode_BrilligCall>(GetArena());
  }
  return _impl_.value_.brillig_call_;
}
inline ::acvm::acir::circuit::Opcode_BrilligCall* Opcode::mutable_brillig_call() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::circuit::Opcode_BrilligCall* _msg = _internal_mutable_brillig_call();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.Opcode.brillig_call)
  return _msg;
}

// .acvm.acir.circuit.Opcode.Call call = 6;
inline bool Opcode::has_call() const {
  return value_case() == kCall;
}
inline bool Opcode::_internal_has_call() const {
  return value_case() == kCall;
}
inline void Opcode::set_has_call() {
  _impl_._oneof_case_[0] = kCall;
}
inline void Opcode::clear_call() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kCall) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.call_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.call_);
    }
    clear_has_value();
  }
}
inline ::acvm::acir::circuit::Opcode_Call* Opcode::release_call() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.Opcode.call)
  if (value_case() == kCall) {
    clear_has_value();
    auto* temp = _impl_.value_.call_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.call_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::circuit::Opcode_Call& Opcode::_internal_call() const {
  return value_case() == kCall ? *_impl_.value_.call_ : reinterpret_cast<::acvm::acir::circuit::Opcode_Call&>(::acvm::acir::circuit::_Opcode_Call_default_instance_);
}
inline const ::acvm::acir::circuit::Opcode_Call& Opcode::call() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.Opcode.call)
  return _internal_call();
}
inline ::acvm::acir::circuit::Opcode_Call* Opcode::unsafe_arena_release_call() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.Opcode.call)
  if (value_case() == kCall) {
    clear_has_value();
    auto* temp = _impl_.value_.call_;
    _impl_.value_.call_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Opcode::unsafe_arena_set_allocated_call(::acvm::acir::circuit::Opcode_Call* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_call();
    _impl_.value_.call_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.Opcode.call)
}
inline ::acvm::acir::circuit::Opcode_Call* Opcode::_internal_mutable_call() {
  if (value_case() != kCall) {
    clear_value();
    set_has_call();
    _impl_.value_.call_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::Opcode_Call>(GetArena());
  }
  return _impl_.value_.call_;
}
inline ::acvm::acir::circuit::Opcode_Call* Opcode::mutable_call() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::circuit::Opcode_Call* _msg = _internal_mutable_call();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.Opcode.call)
  return _msg;
}

inline bool Opcode::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Opcode::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline Opcode::ValueCase Opcode::value_case() const {
  return Opcode::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// BlackBoxFuncCall_AES128Encrypt

// repeated .acvm.acir.circuit.FunctionInput inputs = 1;
inline int BlackBoxFuncCall_AES128Encrypt::_internal_inputs_size() const {
  return _internal_inputs().size();
}
inline int BlackBoxFuncCall_AES128Encrypt::inputs_size() const {
  return _internal_inputs_size();
}
inline void BlackBoxFuncCall_AES128Encrypt::clear_inputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inputs_.Clear();
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_AES128Encrypt::mutable_inputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.AES128Encrypt.inputs)
  return _internal_mutable_inputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* BlackBoxFuncCall_AES128Encrypt::mutable_inputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BlackBoxFuncCall.AES128Encrypt.inputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_inputs();
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_AES128Encrypt::inputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.AES128Encrypt.inputs)
  return _internal_inputs().Get(index);
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_AES128Encrypt::add_inputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::circuit::FunctionInput* _add = _internal_mutable_inputs()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BlackBoxFuncCall.AES128Encrypt.inputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& BlackBoxFuncCall_AES128Encrypt::inputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BlackBoxFuncCall.AES128Encrypt.inputs)
  return _internal_inputs();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>&
BlackBoxFuncCall_AES128Encrypt::_internal_inputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.inputs_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>*
BlackBoxFuncCall_AES128Encrypt::_internal_mutable_inputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.inputs_;
}

// repeated .acvm.acir.circuit.FunctionInput iv = 2;
inline int BlackBoxFuncCall_AES128Encrypt::_internal_iv_size() const {
  return _internal_iv().size();
}
inline int BlackBoxFuncCall_AES128Encrypt::iv_size() const {
  return _internal_iv_size();
}
inline void BlackBoxFuncCall_AES128Encrypt::clear_iv() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.iv_.Clear();
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_AES128Encrypt::mutable_iv(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.AES128Encrypt.iv)
  return _internal_mutable_iv()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* BlackBoxFuncCall_AES128Encrypt::mutable_iv()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BlackBoxFuncCall.AES128Encrypt.iv)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_iv();
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_AES128Encrypt::iv(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.AES128Encrypt.iv)
  return _internal_iv().Get(index);
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_AES128Encrypt::add_iv() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::circuit::FunctionInput* _add = _internal_mutable_iv()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BlackBoxFuncCall.AES128Encrypt.iv)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& BlackBoxFuncCall_AES128Encrypt::iv() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BlackBoxFuncCall.AES128Encrypt.iv)
  return _internal_iv();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>&
BlackBoxFuncCall_AES128Encrypt::_internal_iv() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.iv_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>*
BlackBoxFuncCall_AES128Encrypt::_internal_mutable_iv() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.iv_;
}

// repeated .acvm.acir.circuit.FunctionInput key = 3;
inline int BlackBoxFuncCall_AES128Encrypt::_internal_key_size() const {
  return _internal_key().size();
}
inline int BlackBoxFuncCall_AES128Encrypt::key_size() const {
  return _internal_key_size();
}
inline void BlackBoxFuncCall_AES128Encrypt::clear_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Clear();
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_AES128Encrypt::mutable_key(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.AES128Encrypt.key)
  return _internal_mutable_key()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* BlackBoxFuncCall_AES128Encrypt::mutable_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BlackBoxFuncCall.AES128Encrypt.key)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_key();
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_AES128Encrypt::key(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.AES128Encrypt.key)
  return _internal_key().Get(index);
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_AES128Encrypt::add_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::circuit::FunctionInput* _add = _internal_mutable_key()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BlackBoxFuncCall.AES128Encrypt.key)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& BlackBoxFuncCall_AES128Encrypt::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BlackBoxFuncCall.AES128Encrypt.key)
  return _internal_key();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>&
BlackBoxFuncCall_AES128Encrypt::_internal_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>*
BlackBoxFuncCall_AES128Encrypt::_internal_mutable_key() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.key_;
}

// repeated .acvm.acir.native.Witness outputs = 4;
inline int BlackBoxFuncCall_AES128Encrypt::_internal_outputs_size() const {
  return _internal_outputs().size();
}
inline int BlackBoxFuncCall_AES128Encrypt::outputs_size() const {
  return _internal_outputs_size();
}
inline ::acvm::acir::native::Witness* BlackBoxFuncCall_AES128Encrypt::mutable_outputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.AES128Encrypt.outputs)
  return _internal_mutable_outputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* BlackBoxFuncCall_AES128Encrypt::mutable_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BlackBoxFuncCall.AES128Encrypt.outputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_outputs();
}
inline const ::acvm::acir::native::Witness& BlackBoxFuncCall_AES128Encrypt::outputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.AES128Encrypt.outputs)
  return _internal_outputs().Get(index);
}
inline ::acvm::acir::native::Witness* BlackBoxFuncCall_AES128Encrypt::add_outputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::native::Witness* _add = _internal_mutable_outputs()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BlackBoxFuncCall.AES128Encrypt.outputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& BlackBoxFuncCall_AES128Encrypt::outputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BlackBoxFuncCall.AES128Encrypt.outputs)
  return _internal_outputs();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>&
BlackBoxFuncCall_AES128Encrypt::_internal_outputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.outputs_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>*
BlackBoxFuncCall_AES128Encrypt::_internal_mutable_outputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.outputs_;
}

// -------------------------------------------------------------------

// BlackBoxFuncCall_AND

// .acvm.acir.circuit.FunctionInput lhs = 1;
inline bool BlackBoxFuncCall_AND::has_lhs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lhs_ != nullptr);
  return value;
}
inline void BlackBoxFuncCall_AND::clear_lhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lhs_ != nullptr) _impl_.lhs_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_AND::_internal_lhs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::acvm::acir::circuit::FunctionInput* p = _impl_.lhs_;
  return p != nullptr ? *p : reinterpret_cast<const ::acvm::acir::circuit::FunctionInput&>(::acvm::acir::circuit::_FunctionInput_default_instance_);
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_AND::lhs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.AND.lhs)
  return _internal_lhs();
}
inline void BlackBoxFuncCall_AND::unsafe_arena_set_allocated_lhs(::acvm::acir::circuit::FunctionInput* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lhs_);
  }
  _impl_.lhs_ = reinterpret_cast<::acvm::acir::circuit::FunctionInput*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.AND.lhs)
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_AND::release_lhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::acvm::acir::circuit::FunctionInput* released = _impl_.lhs_;
  _impl_.lhs_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_AND::unsafe_arena_release_lhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BlackBoxFuncCall.AND.lhs)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::acvm::acir::circuit::FunctionInput* temp = _impl_.lhs_;
  _impl_.lhs_ = nullptr;
  return temp;
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_AND::_internal_mutable_lhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lhs_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::FunctionInput>(GetArena());
    _impl_.lhs_ = reinterpret_cast<::acvm::acir::circuit::FunctionInput*>(p);
  }
  return _impl_.lhs_;
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_AND::mutable_lhs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::acvm::acir::circuit::FunctionInput* _msg = _internal_mutable_lhs();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.AND.lhs)
  return _msg;
}
inline void BlackBoxFuncCall_AND::set_allocated_lhs(::acvm::acir::circuit::FunctionInput* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.lhs_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.lhs_ = reinterpret_cast<::acvm::acir::circuit::FunctionInput*>(value);
  // @@protoc_insertion_point(field_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.AND.lhs)
}

// .acvm.acir.circuit.FunctionInput rhs = 2;
inline bool BlackBoxFuncCall_AND::has_rhs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rhs_ != nullptr);
  return value;
}
inline void BlackBoxFuncCall_AND::clear_rhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rhs_ != nullptr) _impl_.rhs_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_AND::_internal_rhs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::acvm::acir::circuit::FunctionInput* p = _impl_.rhs_;
  return p != nullptr ? *p : reinterpret_cast<const ::acvm::acir::circuit::FunctionInput&>(::acvm::acir::circuit::_FunctionInput_default_instance_);
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_AND::rhs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.AND.rhs)
  return _internal_rhs();
}
inline void BlackBoxFuncCall_AND::unsafe_arena_set_allocated_rhs(::acvm::acir::circuit::FunctionInput* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rhs_);
  }
  _impl_.rhs_ = reinterpret_cast<::acvm::acir::circuit::FunctionInput*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.AND.rhs)
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_AND::release_rhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::acvm::acir::circuit::FunctionInput* released = _impl_.rhs_;
  _impl_.rhs_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_AND::unsafe_arena_release_rhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BlackBoxFuncCall.AND.rhs)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::acvm::acir::circuit::FunctionInput* temp = _impl_.rhs_;
  _impl_.rhs_ = nullptr;
  return temp;
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_AND::_internal_mutable_rhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rhs_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::FunctionInput>(GetArena());
    _impl_.rhs_ = reinterpret_cast<::acvm::acir::circuit::FunctionInput*>(p);
  }
  return _impl_.rhs_;
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_AND::mutable_rhs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::acvm::acir::circuit::FunctionInput* _msg = _internal_mutable_rhs();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.AND.rhs)
  return _msg;
}
inline void BlackBoxFuncCall_AND::set_allocated_rhs(::acvm::acir::circuit::FunctionInput* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.rhs_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.rhs_ = reinterpret_cast<::acvm::acir::circuit::FunctionInput*>(value);
  // @@protoc_insertion_point(field_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.AND.rhs)
}

// .acvm.acir.native.Witness output = 3;
inline bool BlackBoxFuncCall_AND::has_output() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.output_ != nullptr);
  return value;
}
inline const ::acvm::acir::native::Witness& BlackBoxFuncCall_AND::_internal_output() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::acvm::acir::native::Witness* p = _impl_.output_;
  return p != nullptr ? *p : reinterpret_cast<const ::acvm::acir::native::Witness&>(::acvm::acir::native::_Witness_default_instance_);
}
inline const ::acvm::acir::native::Witness& BlackBoxFuncCall_AND::output() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.AND.output)
  return _internal_output();
}
inline void BlackBoxFuncCall_AND::unsafe_arena_set_allocated_output(::acvm::acir::native::Witness* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.output_);
  }
  _impl_.output_ = reinterpret_cast<::acvm::acir::native::Witness*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.AND.output)
}
inline ::acvm::acir::native::Witness* BlackBoxFuncCall_AND::release_output() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::acvm::acir::native::Witness* released = _impl_.output_;
  _impl_.output_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::acvm::acir::native::Witness* BlackBoxFuncCall_AND::unsafe_arena_release_output() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BlackBoxFuncCall.AND.output)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::acvm::acir::native::Witness* temp = _impl_.output_;
  _impl_.output_ = nullptr;
  return temp;
}
inline ::acvm::acir::native::Witness* BlackBoxFuncCall_AND::_internal_mutable_output() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.output_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::acvm::acir::native::Witness>(GetArena());
    _impl_.output_ = reinterpret_cast<::acvm::acir::native::Witness*>(p);
  }
  return _impl_.output_;
}
inline ::acvm::acir::native::Witness* BlackBoxFuncCall_AND::mutable_output() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::acvm::acir::native::Witness* _msg = _internal_mutable_output();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.AND.output)
  return _msg;
}
inline void BlackBoxFuncCall_AND::set_allocated_output(::acvm::acir::native::Witness* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.output_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.output_ = reinterpret_cast<::acvm::acir::native::Witness*>(value);
  // @@protoc_insertion_point(field_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.AND.output)
}

// -------------------------------------------------------------------

// BlackBoxFuncCall_XOR

// .acvm.acir.circuit.FunctionInput lhs = 1;
inline bool BlackBoxFuncCall_XOR::has_lhs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lhs_ != nullptr);
  return value;
}
inline void BlackBoxFuncCall_XOR::clear_lhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lhs_ != nullptr) _impl_.lhs_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_XOR::_internal_lhs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::acvm::acir::circuit::FunctionInput* p = _impl_.lhs_;
  return p != nullptr ? *p : reinterpret_cast<const ::acvm::acir::circuit::FunctionInput&>(::acvm::acir::circuit::_FunctionInput_default_instance_);
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_XOR::lhs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.XOR.lhs)
  return _internal_lhs();
}
inline void BlackBoxFuncCall_XOR::unsafe_arena_set_allocated_lhs(::acvm::acir::circuit::FunctionInput* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lhs_);
  }
  _impl_.lhs_ = reinterpret_cast<::acvm::acir::circuit::FunctionInput*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.XOR.lhs)
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_XOR::release_lhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::acvm::acir::circuit::FunctionInput* released = _impl_.lhs_;
  _impl_.lhs_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_XOR::unsafe_arena_release_lhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BlackBoxFuncCall.XOR.lhs)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::acvm::acir::circuit::FunctionInput* temp = _impl_.lhs_;
  _impl_.lhs_ = nullptr;
  return temp;
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_XOR::_internal_mutable_lhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lhs_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::FunctionInput>(GetArena());
    _impl_.lhs_ = reinterpret_cast<::acvm::acir::circuit::FunctionInput*>(p);
  }
  return _impl_.lhs_;
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_XOR::mutable_lhs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::acvm::acir::circuit::FunctionInput* _msg = _internal_mutable_lhs();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.XOR.lhs)
  return _msg;
}
inline void BlackBoxFuncCall_XOR::set_allocated_lhs(::acvm::acir::circuit::FunctionInput* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.lhs_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.lhs_ = reinterpret_cast<::acvm::acir::circuit::FunctionInput*>(value);
  // @@protoc_insertion_point(field_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.XOR.lhs)
}

// .acvm.acir.circuit.FunctionInput rhs = 2;
inline bool BlackBoxFuncCall_XOR::has_rhs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rhs_ != nullptr);
  return value;
}
inline void BlackBoxFuncCall_XOR::clear_rhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rhs_ != nullptr) _impl_.rhs_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_XOR::_internal_rhs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::acvm::acir::circuit::FunctionInput* p = _impl_.rhs_;
  return p != nullptr ? *p : reinterpret_cast<const ::acvm::acir::circuit::FunctionInput&>(::acvm::acir::circuit::_FunctionInput_default_instance_);
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_XOR::rhs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.XOR.rhs)
  return _internal_rhs();
}
inline void BlackBoxFuncCall_XOR::unsafe_arena_set_allocated_rhs(::acvm::acir::circuit::FunctionInput* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rhs_);
  }
  _impl_.rhs_ = reinterpret_cast<::acvm::acir::circuit::FunctionInput*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.XOR.rhs)
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_XOR::release_rhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::acvm::acir::circuit::FunctionInput* released = _impl_.rhs_;
  _impl_.rhs_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_XOR::unsafe_arena_release_rhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BlackBoxFuncCall.XOR.rhs)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::acvm::acir::circuit::FunctionInput* temp = _impl_.rhs_;
  _impl_.rhs_ = nullptr;
  return temp;
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_XOR::_internal_mutable_rhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rhs_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::FunctionInput>(GetArena());
    _impl_.rhs_ = reinterpret_cast<::acvm::acir::circuit::FunctionInput*>(p);
  }
  return _impl_.rhs_;
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_XOR::mutable_rhs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::acvm::acir::circuit::FunctionInput* _msg = _internal_mutable_rhs();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.XOR.rhs)
  return _msg;
}
inline void BlackBoxFuncCall_XOR::set_allocated_rhs(::acvm::acir::circuit::FunctionInput* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.rhs_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.rhs_ = reinterpret_cast<::acvm::acir::circuit::FunctionInput*>(value);
  // @@protoc_insertion_point(field_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.XOR.rhs)
}

// .acvm.acir.native.Witness output = 3;
inline bool BlackBoxFuncCall_XOR::has_output() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.output_ != nullptr);
  return value;
}
inline const ::acvm::acir::native::Witness& BlackBoxFuncCall_XOR::_internal_output() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::acvm::acir::native::Witness* p = _impl_.output_;
  return p != nullptr ? *p : reinterpret_cast<const ::acvm::acir::native::Witness&>(::acvm::acir::native::_Witness_default_instance_);
}
inline const ::acvm::acir::native::Witness& BlackBoxFuncCall_XOR::output() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.XOR.output)
  return _internal_output();
}
inline void BlackBoxFuncCall_XOR::unsafe_arena_set_allocated_output(::acvm::acir::native::Witness* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.output_);
  }
  _impl_.output_ = reinterpret_cast<::acvm::acir::native::Witness*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.XOR.output)
}
inline ::acvm::acir::native::Witness* BlackBoxFuncCall_XOR::release_output() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::acvm::acir::native::Witness* released = _impl_.output_;
  _impl_.output_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::acvm::acir::native::Witness* BlackBoxFuncCall_XOR::unsafe_arena_release_output() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BlackBoxFuncCall.XOR.output)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::acvm::acir::native::Witness* temp = _impl_.output_;
  _impl_.output_ = nullptr;
  return temp;
}
inline ::acvm::acir::native::Witness* BlackBoxFuncCall_XOR::_internal_mutable_output() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.output_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::acvm::acir::native::Witness>(GetArena());
    _impl_.output_ = reinterpret_cast<::acvm::acir::native::Witness*>(p);
  }
  return _impl_.output_;
}
inline ::acvm::acir::native::Witness* BlackBoxFuncCall_XOR::mutable_output() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::acvm::acir::native::Witness* _msg = _internal_mutable_output();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.XOR.output)
  return _msg;
}
inline void BlackBoxFuncCall_XOR::set_allocated_output(::acvm::acir::native::Witness* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.output_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.output_ = reinterpret_cast<::acvm::acir::native::Witness*>(value);
  // @@protoc_insertion_point(field_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.XOR.output)
}

// -------------------------------------------------------------------

// BlackBoxFuncCall_RANGE

// .acvm.acir.circuit.FunctionInput input = 1;
inline bool BlackBoxFuncCall_RANGE::has_input() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.input_ != nullptr);
  return value;
}
inline void BlackBoxFuncCall_RANGE::clear_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_ != nullptr) _impl_.input_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_RANGE::_internal_input() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::acvm::acir::circuit::FunctionInput* p = _impl_.input_;
  return p != nullptr ? *p : reinterpret_cast<const ::acvm::acir::circuit::FunctionInput&>(::acvm::acir::circuit::_FunctionInput_default_instance_);
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_RANGE::input() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.RANGE.input)
  return _internal_input();
}
inline void BlackBoxFuncCall_RANGE::unsafe_arena_set_allocated_input(::acvm::acir::circuit::FunctionInput* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.input_);
  }
  _impl_.input_ = reinterpret_cast<::acvm::acir::circuit::FunctionInput*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.RANGE.input)
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_RANGE::release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::acvm::acir::circuit::FunctionInput* released = _impl_.input_;
  _impl_.input_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_RANGE::unsafe_arena_release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BlackBoxFuncCall.RANGE.input)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::acvm::acir::circuit::FunctionInput* temp = _impl_.input_;
  _impl_.input_ = nullptr;
  return temp;
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_RANGE::_internal_mutable_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::FunctionInput>(GetArena());
    _impl_.input_ = reinterpret_cast<::acvm::acir::circuit::FunctionInput*>(p);
  }
  return _impl_.input_;
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_RANGE::mutable_input() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::acvm::acir::circuit::FunctionInput* _msg = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.RANGE.input)
  return _msg;
}
inline void BlackBoxFuncCall_RANGE::set_allocated_input(::acvm::acir::circuit::FunctionInput* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.input_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.input_ = reinterpret_cast<::acvm::acir::circuit::FunctionInput*>(value);
  // @@protoc_insertion_point(field_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.RANGE.input)
}

// -------------------------------------------------------------------

// BlackBoxFuncCall_Blake2s

// repeated .acvm.acir.circuit.FunctionInput inputs = 1;
inline int BlackBoxFuncCall_Blake2s::_internal_inputs_size() const {
  return _internal_inputs().size();
}
inline int BlackBoxFuncCall_Blake2s::inputs_size() const {
  return _internal_inputs_size();
}
inline void BlackBoxFuncCall_Blake2s::clear_inputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inputs_.Clear();
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_Blake2s::mutable_inputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.Blake2s.inputs)
  return _internal_mutable_inputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* BlackBoxFuncCall_Blake2s::mutable_inputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BlackBoxFuncCall.Blake2s.inputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_inputs();
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_Blake2s::inputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.Blake2s.inputs)
  return _internal_inputs().Get(index);
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_Blake2s::add_inputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::circuit::FunctionInput* _add = _internal_mutable_inputs()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BlackBoxFuncCall.Blake2s.inputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& BlackBoxFuncCall_Blake2s::inputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BlackBoxFuncCall.Blake2s.inputs)
  return _internal_inputs();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>&
BlackBoxFuncCall_Blake2s::_internal_inputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.inputs_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>*
BlackBoxFuncCall_Blake2s::_internal_mutable_inputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.inputs_;
}

// repeated .acvm.acir.native.Witness outputs = 2;
inline int BlackBoxFuncCall_Blake2s::_internal_outputs_size() const {
  return _internal_outputs().size();
}
inline int BlackBoxFuncCall_Blake2s::outputs_size() const {
  return _internal_outputs_size();
}
inline ::acvm::acir::native::Witness* BlackBoxFuncCall_Blake2s::mutable_outputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.Blake2s.outputs)
  return _internal_mutable_outputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* BlackBoxFuncCall_Blake2s::mutable_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BlackBoxFuncCall.Blake2s.outputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_outputs();
}
inline const ::acvm::acir::native::Witness& BlackBoxFuncCall_Blake2s::outputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.Blake2s.outputs)
  return _internal_outputs().Get(index);
}
inline ::acvm::acir::native::Witness* BlackBoxFuncCall_Blake2s::add_outputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::native::Witness* _add = _internal_mutable_outputs()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BlackBoxFuncCall.Blake2s.outputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& BlackBoxFuncCall_Blake2s::outputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BlackBoxFuncCall.Blake2s.outputs)
  return _internal_outputs();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>&
BlackBoxFuncCall_Blake2s::_internal_outputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.outputs_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>*
BlackBoxFuncCall_Blake2s::_internal_mutable_outputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.outputs_;
}

// -------------------------------------------------------------------

// BlackBoxFuncCall_Blake3

// repeated .acvm.acir.circuit.FunctionInput inputs = 1;
inline int BlackBoxFuncCall_Blake3::_internal_inputs_size() const {
  return _internal_inputs().size();
}
inline int BlackBoxFuncCall_Blake3::inputs_size() const {
  return _internal_inputs_size();
}
inline void BlackBoxFuncCall_Blake3::clear_inputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inputs_.Clear();
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_Blake3::mutable_inputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.Blake3.inputs)
  return _internal_mutable_inputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* BlackBoxFuncCall_Blake3::mutable_inputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BlackBoxFuncCall.Blake3.inputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_inputs();
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_Blake3::inputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.Blake3.inputs)
  return _internal_inputs().Get(index);
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_Blake3::add_inputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::circuit::FunctionInput* _add = _internal_mutable_inputs()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BlackBoxFuncCall.Blake3.inputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& BlackBoxFuncCall_Blake3::inputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BlackBoxFuncCall.Blake3.inputs)
  return _internal_inputs();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>&
BlackBoxFuncCall_Blake3::_internal_inputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.inputs_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>*
BlackBoxFuncCall_Blake3::_internal_mutable_inputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.inputs_;
}

// repeated .acvm.acir.native.Witness outputs = 2;
inline int BlackBoxFuncCall_Blake3::_internal_outputs_size() const {
  return _internal_outputs().size();
}
inline int BlackBoxFuncCall_Blake3::outputs_size() const {
  return _internal_outputs_size();
}
inline ::acvm::acir::native::Witness* BlackBoxFuncCall_Blake3::mutable_outputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.Blake3.outputs)
  return _internal_mutable_outputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* BlackBoxFuncCall_Blake3::mutable_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BlackBoxFuncCall.Blake3.outputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_outputs();
}
inline const ::acvm::acir::native::Witness& BlackBoxFuncCall_Blake3::outputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.Blake3.outputs)
  return _internal_outputs().Get(index);
}
inline ::acvm::acir::native::Witness* BlackBoxFuncCall_Blake3::add_outputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::native::Witness* _add = _internal_mutable_outputs()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BlackBoxFuncCall.Blake3.outputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& BlackBoxFuncCall_Blake3::outputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BlackBoxFuncCall.Blake3.outputs)
  return _internal_outputs();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>&
BlackBoxFuncCall_Blake3::_internal_outputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.outputs_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>*
BlackBoxFuncCall_Blake3::_internal_mutable_outputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.outputs_;
}

// -------------------------------------------------------------------

// BlackBoxFuncCall_EcdsaSecp256k1

// repeated .acvm.acir.circuit.FunctionInput public_key_x = 1;
inline int BlackBoxFuncCall_EcdsaSecp256k1::_internal_public_key_x_size() const {
  return _internal_public_key_x().size();
}
inline int BlackBoxFuncCall_EcdsaSecp256k1::public_key_x_size() const {
  return _internal_public_key_x_size();
}
inline void BlackBoxFuncCall_EcdsaSecp256k1::clear_public_key_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.public_key_x_.Clear();
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_EcdsaSecp256k1::mutable_public_key_x(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256k1.public_key_x)
  return _internal_mutable_public_key_x()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* BlackBoxFuncCall_EcdsaSecp256k1::mutable_public_key_x()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256k1.public_key_x)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_public_key_x();
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_EcdsaSecp256k1::public_key_x(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256k1.public_key_x)
  return _internal_public_key_x().Get(index);
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_EcdsaSecp256k1::add_public_key_x() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::circuit::FunctionInput* _add = _internal_mutable_public_key_x()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256k1.public_key_x)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& BlackBoxFuncCall_EcdsaSecp256k1::public_key_x() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256k1.public_key_x)
  return _internal_public_key_x();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>&
BlackBoxFuncCall_EcdsaSecp256k1::_internal_public_key_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.public_key_x_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>*
BlackBoxFuncCall_EcdsaSecp256k1::_internal_mutable_public_key_x() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.public_key_x_;
}

// repeated .acvm.acir.circuit.FunctionInput public_key_y = 2;
inline int BlackBoxFuncCall_EcdsaSecp256k1::_internal_public_key_y_size() const {
  return _internal_public_key_y().size();
}
inline int BlackBoxFuncCall_EcdsaSecp256k1::public_key_y_size() const {
  return _internal_public_key_y_size();
}
inline void BlackBoxFuncCall_EcdsaSecp256k1::clear_public_key_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.public_key_y_.Clear();
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_EcdsaSecp256k1::mutable_public_key_y(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256k1.public_key_y)
  return _internal_mutable_public_key_y()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* BlackBoxFuncCall_EcdsaSecp256k1::mutable_public_key_y()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256k1.public_key_y)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_public_key_y();
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_EcdsaSecp256k1::public_key_y(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256k1.public_key_y)
  return _internal_public_key_y().Get(index);
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_EcdsaSecp256k1::add_public_key_y() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::circuit::FunctionInput* _add = _internal_mutable_public_key_y()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256k1.public_key_y)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& BlackBoxFuncCall_EcdsaSecp256k1::public_key_y() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256k1.public_key_y)
  return _internal_public_key_y();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>&
BlackBoxFuncCall_EcdsaSecp256k1::_internal_public_key_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.public_key_y_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>*
BlackBoxFuncCall_EcdsaSecp256k1::_internal_mutable_public_key_y() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.public_key_y_;
}

// repeated .acvm.acir.circuit.FunctionInput signature = 3;
inline int BlackBoxFuncCall_EcdsaSecp256k1::_internal_signature_size() const {
  return _internal_signature().size();
}
inline int BlackBoxFuncCall_EcdsaSecp256k1::signature_size() const {
  return _internal_signature_size();
}
inline void BlackBoxFuncCall_EcdsaSecp256k1::clear_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signature_.Clear();
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_EcdsaSecp256k1::mutable_signature(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256k1.signature)
  return _internal_mutable_signature()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* BlackBoxFuncCall_EcdsaSecp256k1::mutable_signature()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256k1.signature)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_signature();
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_EcdsaSecp256k1::signature(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256k1.signature)
  return _internal_signature().Get(index);
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_EcdsaSecp256k1::add_signature() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::circuit::FunctionInput* _add = _internal_mutable_signature()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256k1.signature)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& BlackBoxFuncCall_EcdsaSecp256k1::signature() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256k1.signature)
  return _internal_signature();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>&
BlackBoxFuncCall_EcdsaSecp256k1::_internal_signature() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.signature_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>*
BlackBoxFuncCall_EcdsaSecp256k1::_internal_mutable_signature() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.signature_;
}

// repeated .acvm.acir.circuit.FunctionInput hashed_message = 4;
inline int BlackBoxFuncCall_EcdsaSecp256k1::_internal_hashed_message_size() const {
  return _internal_hashed_message().size();
}
inline int BlackBoxFuncCall_EcdsaSecp256k1::hashed_message_size() const {
  return _internal_hashed_message_size();
}
inline void BlackBoxFuncCall_EcdsaSecp256k1::clear_hashed_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hashed_message_.Clear();
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_EcdsaSecp256k1::mutable_hashed_message(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256k1.hashed_message)
  return _internal_mutable_hashed_message()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* BlackBoxFuncCall_EcdsaSecp256k1::mutable_hashed_message()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256k1.hashed_message)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_hashed_message();
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_EcdsaSecp256k1::hashed_message(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256k1.hashed_message)
  return _internal_hashed_message().Get(index);
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_EcdsaSecp256k1::add_hashed_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::circuit::FunctionInput* _add = _internal_mutable_hashed_message()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256k1.hashed_message)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& BlackBoxFuncCall_EcdsaSecp256k1::hashed_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256k1.hashed_message)
  return _internal_hashed_message();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>&
BlackBoxFuncCall_EcdsaSecp256k1::_internal_hashed_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hashed_message_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>*
BlackBoxFuncCall_EcdsaSecp256k1::_internal_mutable_hashed_message() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.hashed_message_;
}

// .acvm.acir.native.Witness output = 5;
inline bool BlackBoxFuncCall_EcdsaSecp256k1::has_output() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.output_ != nullptr);
  return value;
}
inline const ::acvm::acir::native::Witness& BlackBoxFuncCall_EcdsaSecp256k1::_internal_output() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::acvm::acir::native::Witness* p = _impl_.output_;
  return p != nullptr ? *p : reinterpret_cast<const ::acvm::acir::native::Witness&>(::acvm::acir::native::_Witness_default_instance_);
}
inline const ::acvm::acir::native::Witness& BlackBoxFuncCall_EcdsaSecp256k1::output() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256k1.output)
  return _internal_output();
}
inline void BlackBoxFuncCall_EcdsaSecp256k1::unsafe_arena_set_allocated_output(::acvm::acir::native::Witness* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.output_);
  }
  _impl_.output_ = reinterpret_cast<::acvm::acir::native::Witness*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256k1.output)
}
inline ::acvm::acir::native::Witness* BlackBoxFuncCall_EcdsaSecp256k1::release_output() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::acvm::acir::native::Witness* released = _impl_.output_;
  _impl_.output_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::acvm::acir::native::Witness* BlackBoxFuncCall_EcdsaSecp256k1::unsafe_arena_release_output() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256k1.output)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::acvm::acir::native::Witness* temp = _impl_.output_;
  _impl_.output_ = nullptr;
  return temp;
}
inline ::acvm::acir::native::Witness* BlackBoxFuncCall_EcdsaSecp256k1::_internal_mutable_output() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.output_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::acvm::acir::native::Witness>(GetArena());
    _impl_.output_ = reinterpret_cast<::acvm::acir::native::Witness*>(p);
  }
  return _impl_.output_;
}
inline ::acvm::acir::native::Witness* BlackBoxFuncCall_EcdsaSecp256k1::mutable_output() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::acvm::acir::native::Witness* _msg = _internal_mutable_output();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256k1.output)
  return _msg;
}
inline void BlackBoxFuncCall_EcdsaSecp256k1::set_allocated_output(::acvm::acir::native::Witness* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.output_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.output_ = reinterpret_cast<::acvm::acir::native::Witness*>(value);
  // @@protoc_insertion_point(field_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256k1.output)
}

// -------------------------------------------------------------------

// BlackBoxFuncCall_EcdsaSecp256r1

// repeated .acvm.acir.circuit.FunctionInput public_key_x = 1;
inline int BlackBoxFuncCall_EcdsaSecp256r1::_internal_public_key_x_size() const {
  return _internal_public_key_x().size();
}
inline int BlackBoxFuncCall_EcdsaSecp256r1::public_key_x_size() const {
  return _internal_public_key_x_size();
}
inline void BlackBoxFuncCall_EcdsaSecp256r1::clear_public_key_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.public_key_x_.Clear();
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_EcdsaSecp256r1::mutable_public_key_x(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256r1.public_key_x)
  return _internal_mutable_public_key_x()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* BlackBoxFuncCall_EcdsaSecp256r1::mutable_public_key_x()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256r1.public_key_x)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_public_key_x();
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_EcdsaSecp256r1::public_key_x(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256r1.public_key_x)
  return _internal_public_key_x().Get(index);
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_EcdsaSecp256r1::add_public_key_x() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::circuit::FunctionInput* _add = _internal_mutable_public_key_x()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256r1.public_key_x)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& BlackBoxFuncCall_EcdsaSecp256r1::public_key_x() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256r1.public_key_x)
  return _internal_public_key_x();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>&
BlackBoxFuncCall_EcdsaSecp256r1::_internal_public_key_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.public_key_x_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>*
BlackBoxFuncCall_EcdsaSecp256r1::_internal_mutable_public_key_x() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.public_key_x_;
}

// repeated .acvm.acir.circuit.FunctionInput public_key_y = 2;
inline int BlackBoxFuncCall_EcdsaSecp256r1::_internal_public_key_y_size() const {
  return _internal_public_key_y().size();
}
inline int BlackBoxFuncCall_EcdsaSecp256r1::public_key_y_size() const {
  return _internal_public_key_y_size();
}
inline void BlackBoxFuncCall_EcdsaSecp256r1::clear_public_key_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.public_key_y_.Clear();
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_EcdsaSecp256r1::mutable_public_key_y(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256r1.public_key_y)
  return _internal_mutable_public_key_y()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* BlackBoxFuncCall_EcdsaSecp256r1::mutable_public_key_y()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256r1.public_key_y)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_public_key_y();
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_EcdsaSecp256r1::public_key_y(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256r1.public_key_y)
  return _internal_public_key_y().Get(index);
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_EcdsaSecp256r1::add_public_key_y() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::circuit::FunctionInput* _add = _internal_mutable_public_key_y()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256r1.public_key_y)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& BlackBoxFuncCall_EcdsaSecp256r1::public_key_y() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256r1.public_key_y)
  return _internal_public_key_y();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>&
BlackBoxFuncCall_EcdsaSecp256r1::_internal_public_key_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.public_key_y_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>*
BlackBoxFuncCall_EcdsaSecp256r1::_internal_mutable_public_key_y() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.public_key_y_;
}

// repeated .acvm.acir.circuit.FunctionInput signature = 3;
inline int BlackBoxFuncCall_EcdsaSecp256r1::_internal_signature_size() const {
  return _internal_signature().size();
}
inline int BlackBoxFuncCall_EcdsaSecp256r1::signature_size() const {
  return _internal_signature_size();
}
inline void BlackBoxFuncCall_EcdsaSecp256r1::clear_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signature_.Clear();
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_EcdsaSecp256r1::mutable_signature(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256r1.signature)
  return _internal_mutable_signature()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* BlackBoxFuncCall_EcdsaSecp256r1::mutable_signature()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256r1.signature)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_signature();
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_EcdsaSecp256r1::signature(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256r1.signature)
  return _internal_signature().Get(index);
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_EcdsaSecp256r1::add_signature() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::circuit::FunctionInput* _add = _internal_mutable_signature()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256r1.signature)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& BlackBoxFuncCall_EcdsaSecp256r1::signature() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256r1.signature)
  return _internal_signature();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>&
BlackBoxFuncCall_EcdsaSecp256r1::_internal_signature() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.signature_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>*
BlackBoxFuncCall_EcdsaSecp256r1::_internal_mutable_signature() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.signature_;
}

// repeated .acvm.acir.circuit.FunctionInput hashed_message = 4;
inline int BlackBoxFuncCall_EcdsaSecp256r1::_internal_hashed_message_size() const {
  return _internal_hashed_message().size();
}
inline int BlackBoxFuncCall_EcdsaSecp256r1::hashed_message_size() const {
  return _internal_hashed_message_size();
}
inline void BlackBoxFuncCall_EcdsaSecp256r1::clear_hashed_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hashed_message_.Clear();
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_EcdsaSecp256r1::mutable_hashed_message(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256r1.hashed_message)
  return _internal_mutable_hashed_message()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* BlackBoxFuncCall_EcdsaSecp256r1::mutable_hashed_message()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256r1.hashed_message)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_hashed_message();
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_EcdsaSecp256r1::hashed_message(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256r1.hashed_message)
  return _internal_hashed_message().Get(index);
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_EcdsaSecp256r1::add_hashed_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::circuit::FunctionInput* _add = _internal_mutable_hashed_message()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256r1.hashed_message)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& BlackBoxFuncCall_EcdsaSecp256r1::hashed_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256r1.hashed_message)
  return _internal_hashed_message();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>&
BlackBoxFuncCall_EcdsaSecp256r1::_internal_hashed_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hashed_message_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>*
BlackBoxFuncCall_EcdsaSecp256r1::_internal_mutable_hashed_message() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.hashed_message_;
}

// .acvm.acir.native.Witness output = 5;
inline bool BlackBoxFuncCall_EcdsaSecp256r1::has_output() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.output_ != nullptr);
  return value;
}
inline const ::acvm::acir::native::Witness& BlackBoxFuncCall_EcdsaSecp256r1::_internal_output() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::acvm::acir::native::Witness* p = _impl_.output_;
  return p != nullptr ? *p : reinterpret_cast<const ::acvm::acir::native::Witness&>(::acvm::acir::native::_Witness_default_instance_);
}
inline const ::acvm::acir::native::Witness& BlackBoxFuncCall_EcdsaSecp256r1::output() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256r1.output)
  return _internal_output();
}
inline void BlackBoxFuncCall_EcdsaSecp256r1::unsafe_arena_set_allocated_output(::acvm::acir::native::Witness* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.output_);
  }
  _impl_.output_ = reinterpret_cast<::acvm::acir::native::Witness*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256r1.output)
}
inline ::acvm::acir::native::Witness* BlackBoxFuncCall_EcdsaSecp256r1::release_output() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::acvm::acir::native::Witness* released = _impl_.output_;
  _impl_.output_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::acvm::acir::native::Witness* BlackBoxFuncCall_EcdsaSecp256r1::unsafe_arena_release_output() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256r1.output)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::acvm::acir::native::Witness* temp = _impl_.output_;
  _impl_.output_ = nullptr;
  return temp;
}
inline ::acvm::acir::native::Witness* BlackBoxFuncCall_EcdsaSecp256r1::_internal_mutable_output() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.output_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::acvm::acir::native::Witness>(GetArena());
    _impl_.output_ = reinterpret_cast<::acvm::acir::native::Witness*>(p);
  }
  return _impl_.output_;
}
inline ::acvm::acir::native::Witness* BlackBoxFuncCall_EcdsaSecp256r1::mutable_output() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::acvm::acir::native::Witness* _msg = _internal_mutable_output();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256r1.output)
  return _msg;
}
inline void BlackBoxFuncCall_EcdsaSecp256r1::set_allocated_output(::acvm::acir::native::Witness* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.output_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.output_ = reinterpret_cast<::acvm::acir::native::Witness*>(value);
  // @@protoc_insertion_point(field_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256r1.output)
}

// -------------------------------------------------------------------

// BlackBoxFuncCall_MultiScalarMul

// repeated .acvm.acir.circuit.FunctionInput points = 1;
inline int BlackBoxFuncCall_MultiScalarMul::_internal_points_size() const {
  return _internal_points().size();
}
inline int BlackBoxFuncCall_MultiScalarMul::points_size() const {
  return _internal_points_size();
}
inline void BlackBoxFuncCall_MultiScalarMul::clear_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.points_.Clear();
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_MultiScalarMul::mutable_points(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.MultiScalarMul.points)
  return _internal_mutable_points()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* BlackBoxFuncCall_MultiScalarMul::mutable_points()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BlackBoxFuncCall.MultiScalarMul.points)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_points();
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_MultiScalarMul::points(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.MultiScalarMul.points)
  return _internal_points().Get(index);
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_MultiScalarMul::add_points() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::circuit::FunctionInput* _add = _internal_mutable_points()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BlackBoxFuncCall.MultiScalarMul.points)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& BlackBoxFuncCall_MultiScalarMul::points() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BlackBoxFuncCall.MultiScalarMul.points)
  return _internal_points();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>&
BlackBoxFuncCall_MultiScalarMul::_internal_points() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.points_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>*
BlackBoxFuncCall_MultiScalarMul::_internal_mutable_points() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.points_;
}

// repeated .acvm.acir.circuit.FunctionInput scalars = 2;
inline int BlackBoxFuncCall_MultiScalarMul::_internal_scalars_size() const {
  return _internal_scalars().size();
}
inline int BlackBoxFuncCall_MultiScalarMul::scalars_size() const {
  return _internal_scalars_size();
}
inline void BlackBoxFuncCall_MultiScalarMul::clear_scalars() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scalars_.Clear();
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_MultiScalarMul::mutable_scalars(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.MultiScalarMul.scalars)
  return _internal_mutable_scalars()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* BlackBoxFuncCall_MultiScalarMul::mutable_scalars()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BlackBoxFuncCall.MultiScalarMul.scalars)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_scalars();
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_MultiScalarMul::scalars(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.MultiScalarMul.scalars)
  return _internal_scalars().Get(index);
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_MultiScalarMul::add_scalars() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::circuit::FunctionInput* _add = _internal_mutable_scalars()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BlackBoxFuncCall.MultiScalarMul.scalars)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& BlackBoxFuncCall_MultiScalarMul::scalars() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BlackBoxFuncCall.MultiScalarMul.scalars)
  return _internal_scalars();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>&
BlackBoxFuncCall_MultiScalarMul::_internal_scalars() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.scalars_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>*
BlackBoxFuncCall_MultiScalarMul::_internal_mutable_scalars() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.scalars_;
}

// repeated .acvm.acir.native.Witness outputs = 3;
inline int BlackBoxFuncCall_MultiScalarMul::_internal_outputs_size() const {
  return _internal_outputs().size();
}
inline int BlackBoxFuncCall_MultiScalarMul::outputs_size() const {
  return _internal_outputs_size();
}
inline ::acvm::acir::native::Witness* BlackBoxFuncCall_MultiScalarMul::mutable_outputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.MultiScalarMul.outputs)
  return _internal_mutable_outputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* BlackBoxFuncCall_MultiScalarMul::mutable_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BlackBoxFuncCall.MultiScalarMul.outputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_outputs();
}
inline const ::acvm::acir::native::Witness& BlackBoxFuncCall_MultiScalarMul::outputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.MultiScalarMul.outputs)
  return _internal_outputs().Get(index);
}
inline ::acvm::acir::native::Witness* BlackBoxFuncCall_MultiScalarMul::add_outputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::native::Witness* _add = _internal_mutable_outputs()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BlackBoxFuncCall.MultiScalarMul.outputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& BlackBoxFuncCall_MultiScalarMul::outputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BlackBoxFuncCall.MultiScalarMul.outputs)
  return _internal_outputs();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>&
BlackBoxFuncCall_MultiScalarMul::_internal_outputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.outputs_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>*
BlackBoxFuncCall_MultiScalarMul::_internal_mutable_outputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.outputs_;
}

// -------------------------------------------------------------------

// BlackBoxFuncCall_EmbeddedCurveAdd

// repeated .acvm.acir.circuit.FunctionInput input1 = 1;
inline int BlackBoxFuncCall_EmbeddedCurveAdd::_internal_input1_size() const {
  return _internal_input1().size();
}
inline int BlackBoxFuncCall_EmbeddedCurveAdd::input1_size() const {
  return _internal_input1_size();
}
inline void BlackBoxFuncCall_EmbeddedCurveAdd::clear_input1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input1_.Clear();
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_EmbeddedCurveAdd::mutable_input1(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.EmbeddedCurveAdd.input1)
  return _internal_mutable_input1()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* BlackBoxFuncCall_EmbeddedCurveAdd::mutable_input1()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BlackBoxFuncCall.EmbeddedCurveAdd.input1)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_input1();
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_EmbeddedCurveAdd::input1(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.EmbeddedCurveAdd.input1)
  return _internal_input1().Get(index);
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_EmbeddedCurveAdd::add_input1() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::circuit::FunctionInput* _add = _internal_mutable_input1()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BlackBoxFuncCall.EmbeddedCurveAdd.input1)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& BlackBoxFuncCall_EmbeddedCurveAdd::input1() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BlackBoxFuncCall.EmbeddedCurveAdd.input1)
  return _internal_input1();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>&
BlackBoxFuncCall_EmbeddedCurveAdd::_internal_input1() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.input1_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>*
BlackBoxFuncCall_EmbeddedCurveAdd::_internal_mutable_input1() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.input1_;
}

// repeated .acvm.acir.circuit.FunctionInput input2 = 2;
inline int BlackBoxFuncCall_EmbeddedCurveAdd::_internal_input2_size() const {
  return _internal_input2().size();
}
inline int BlackBoxFuncCall_EmbeddedCurveAdd::input2_size() const {
  return _internal_input2_size();
}
inline void BlackBoxFuncCall_EmbeddedCurveAdd::clear_input2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input2_.Clear();
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_EmbeddedCurveAdd::mutable_input2(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.EmbeddedCurveAdd.input2)
  return _internal_mutable_input2()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* BlackBoxFuncCall_EmbeddedCurveAdd::mutable_input2()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BlackBoxFuncCall.EmbeddedCurveAdd.input2)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_input2();
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_EmbeddedCurveAdd::input2(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.EmbeddedCurveAdd.input2)
  return _internal_input2().Get(index);
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_EmbeddedCurveAdd::add_input2() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::circuit::FunctionInput* _add = _internal_mutable_input2()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BlackBoxFuncCall.EmbeddedCurveAdd.input2)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& BlackBoxFuncCall_EmbeddedCurveAdd::input2() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BlackBoxFuncCall.EmbeddedCurveAdd.input2)
  return _internal_input2();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>&
BlackBoxFuncCall_EmbeddedCurveAdd::_internal_input2() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.input2_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>*
BlackBoxFuncCall_EmbeddedCurveAdd::_internal_mutable_input2() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.input2_;
}

// repeated .acvm.acir.native.Witness outputs = 3;
inline int BlackBoxFuncCall_EmbeddedCurveAdd::_internal_outputs_size() const {
  return _internal_outputs().size();
}
inline int BlackBoxFuncCall_EmbeddedCurveAdd::outputs_size() const {
  return _internal_outputs_size();
}
inline ::acvm::acir::native::Witness* BlackBoxFuncCall_EmbeddedCurveAdd::mutable_outputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.EmbeddedCurveAdd.outputs)
  return _internal_mutable_outputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* BlackBoxFuncCall_EmbeddedCurveAdd::mutable_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BlackBoxFuncCall.EmbeddedCurveAdd.outputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_outputs();
}
inline const ::acvm::acir::native::Witness& BlackBoxFuncCall_EmbeddedCurveAdd::outputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.EmbeddedCurveAdd.outputs)
  return _internal_outputs().Get(index);
}
inline ::acvm::acir::native::Witness* BlackBoxFuncCall_EmbeddedCurveAdd::add_outputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::native::Witness* _add = _internal_mutable_outputs()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BlackBoxFuncCall.EmbeddedCurveAdd.outputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& BlackBoxFuncCall_EmbeddedCurveAdd::outputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BlackBoxFuncCall.EmbeddedCurveAdd.outputs)
  return _internal_outputs();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>&
BlackBoxFuncCall_EmbeddedCurveAdd::_internal_outputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.outputs_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>*
BlackBoxFuncCall_EmbeddedCurveAdd::_internal_mutable_outputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.outputs_;
}

// -------------------------------------------------------------------

// BlackBoxFuncCall_Keccakf1600

// repeated .acvm.acir.circuit.FunctionInput inputs = 1;
inline int BlackBoxFuncCall_Keccakf1600::_internal_inputs_size() const {
  return _internal_inputs().size();
}
inline int BlackBoxFuncCall_Keccakf1600::inputs_size() const {
  return _internal_inputs_size();
}
inline void BlackBoxFuncCall_Keccakf1600::clear_inputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inputs_.Clear();
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_Keccakf1600::mutable_inputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.Keccakf1600.inputs)
  return _internal_mutable_inputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* BlackBoxFuncCall_Keccakf1600::mutable_inputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BlackBoxFuncCall.Keccakf1600.inputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_inputs();
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_Keccakf1600::inputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.Keccakf1600.inputs)
  return _internal_inputs().Get(index);
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_Keccakf1600::add_inputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::circuit::FunctionInput* _add = _internal_mutable_inputs()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BlackBoxFuncCall.Keccakf1600.inputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& BlackBoxFuncCall_Keccakf1600::inputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BlackBoxFuncCall.Keccakf1600.inputs)
  return _internal_inputs();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>&
BlackBoxFuncCall_Keccakf1600::_internal_inputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.inputs_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>*
BlackBoxFuncCall_Keccakf1600::_internal_mutable_inputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.inputs_;
}

// repeated .acvm.acir.native.Witness outputs = 2;
inline int BlackBoxFuncCall_Keccakf1600::_internal_outputs_size() const {
  return _internal_outputs().size();
}
inline int BlackBoxFuncCall_Keccakf1600::outputs_size() const {
  return _internal_outputs_size();
}
inline ::acvm::acir::native::Witness* BlackBoxFuncCall_Keccakf1600::mutable_outputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.Keccakf1600.outputs)
  return _internal_mutable_outputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* BlackBoxFuncCall_Keccakf1600::mutable_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BlackBoxFuncCall.Keccakf1600.outputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_outputs();
}
inline const ::acvm::acir::native::Witness& BlackBoxFuncCall_Keccakf1600::outputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.Keccakf1600.outputs)
  return _internal_outputs().Get(index);
}
inline ::acvm::acir::native::Witness* BlackBoxFuncCall_Keccakf1600::add_outputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::native::Witness* _add = _internal_mutable_outputs()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BlackBoxFuncCall.Keccakf1600.outputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& BlackBoxFuncCall_Keccakf1600::outputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BlackBoxFuncCall.Keccakf1600.outputs)
  return _internal_outputs();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>&
BlackBoxFuncCall_Keccakf1600::_internal_outputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.outputs_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>*
BlackBoxFuncCall_Keccakf1600::_internal_mutable_outputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.outputs_;
}

// -------------------------------------------------------------------

// BlackBoxFuncCall_RecursiveAggregation

// repeated .acvm.acir.circuit.FunctionInput verification_key = 1;
inline int BlackBoxFuncCall_RecursiveAggregation::_internal_verification_key_size() const {
  return _internal_verification_key().size();
}
inline int BlackBoxFuncCall_RecursiveAggregation::verification_key_size() const {
  return _internal_verification_key_size();
}
inline void BlackBoxFuncCall_RecursiveAggregation::clear_verification_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_key_.Clear();
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_RecursiveAggregation::mutable_verification_key(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.RecursiveAggregation.verification_key)
  return _internal_mutable_verification_key()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* BlackBoxFuncCall_RecursiveAggregation::mutable_verification_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BlackBoxFuncCall.RecursiveAggregation.verification_key)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_verification_key();
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_RecursiveAggregation::verification_key(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.RecursiveAggregation.verification_key)
  return _internal_verification_key().Get(index);
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_RecursiveAggregation::add_verification_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::circuit::FunctionInput* _add = _internal_mutable_verification_key()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BlackBoxFuncCall.RecursiveAggregation.verification_key)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& BlackBoxFuncCall_RecursiveAggregation::verification_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BlackBoxFuncCall.RecursiveAggregation.verification_key)
  return _internal_verification_key();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>&
BlackBoxFuncCall_RecursiveAggregation::_internal_verification_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.verification_key_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>*
BlackBoxFuncCall_RecursiveAggregation::_internal_mutable_verification_key() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.verification_key_;
}

// repeated .acvm.acir.circuit.FunctionInput proof = 2;
inline int BlackBoxFuncCall_RecursiveAggregation::_internal_proof_size() const {
  return _internal_proof().size();
}
inline int BlackBoxFuncCall_RecursiveAggregation::proof_size() const {
  return _internal_proof_size();
}
inline void BlackBoxFuncCall_RecursiveAggregation::clear_proof() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.proof_.Clear();
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_RecursiveAggregation::mutable_proof(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.RecursiveAggregation.proof)
  return _internal_mutable_proof()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* BlackBoxFuncCall_RecursiveAggregation::mutable_proof()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BlackBoxFuncCall.RecursiveAggregation.proof)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_proof();
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_RecursiveAggregation::proof(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.RecursiveAggregation.proof)
  return _internal_proof().Get(index);
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_RecursiveAggregation::add_proof() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::circuit::FunctionInput* _add = _internal_mutable_proof()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BlackBoxFuncCall.RecursiveAggregation.proof)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& BlackBoxFuncCall_RecursiveAggregation::proof() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BlackBoxFuncCall.RecursiveAggregation.proof)
  return _internal_proof();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>&
BlackBoxFuncCall_RecursiveAggregation::_internal_proof() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.proof_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>*
BlackBoxFuncCall_RecursiveAggregation::_internal_mutable_proof() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.proof_;
}

// repeated .acvm.acir.circuit.FunctionInput public_inputs = 3;
inline int BlackBoxFuncCall_RecursiveAggregation::_internal_public_inputs_size() const {
  return _internal_public_inputs().size();
}
inline int BlackBoxFuncCall_RecursiveAggregation::public_inputs_size() const {
  return _internal_public_inputs_size();
}
inline void BlackBoxFuncCall_RecursiveAggregation::clear_public_inputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.public_inputs_.Clear();
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_RecursiveAggregation::mutable_public_inputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.RecursiveAggregation.public_inputs)
  return _internal_mutable_public_inputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* BlackBoxFuncCall_RecursiveAggregation::mutable_public_inputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BlackBoxFuncCall.RecursiveAggregation.public_inputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_public_inputs();
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_RecursiveAggregation::public_inputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.RecursiveAggregation.public_inputs)
  return _internal_public_inputs().Get(index);
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_RecursiveAggregation::add_public_inputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::circuit::FunctionInput* _add = _internal_mutable_public_inputs()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BlackBoxFuncCall.RecursiveAggregation.public_inputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& BlackBoxFuncCall_RecursiveAggregation::public_inputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BlackBoxFuncCall.RecursiveAggregation.public_inputs)
  return _internal_public_inputs();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>&
BlackBoxFuncCall_RecursiveAggregation::_internal_public_inputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.public_inputs_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>*
BlackBoxFuncCall_RecursiveAggregation::_internal_mutable_public_inputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.public_inputs_;
}

// .acvm.acir.circuit.FunctionInput key_hash = 4;
inline bool BlackBoxFuncCall_RecursiveAggregation::has_key_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.key_hash_ != nullptr);
  return value;
}
inline void BlackBoxFuncCall_RecursiveAggregation::clear_key_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.key_hash_ != nullptr) _impl_.key_hash_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_RecursiveAggregation::_internal_key_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::acvm::acir::circuit::FunctionInput* p = _impl_.key_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::acvm::acir::circuit::FunctionInput&>(::acvm::acir::circuit::_FunctionInput_default_instance_);
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_RecursiveAggregation::key_hash() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.RecursiveAggregation.key_hash)
  return _internal_key_hash();
}
inline void BlackBoxFuncCall_RecursiveAggregation::unsafe_arena_set_allocated_key_hash(::acvm::acir::circuit::FunctionInput* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.key_hash_);
  }
  _impl_.key_hash_ = reinterpret_cast<::acvm::acir::circuit::FunctionInput*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.RecursiveAggregation.key_hash)
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_RecursiveAggregation::release_key_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::acvm::acir::circuit::FunctionInput* released = _impl_.key_hash_;
  _impl_.key_hash_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_RecursiveAggregation::unsafe_arena_release_key_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BlackBoxFuncCall.RecursiveAggregation.key_hash)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::acvm::acir::circuit::FunctionInput* temp = _impl_.key_hash_;
  _impl_.key_hash_ = nullptr;
  return temp;
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_RecursiveAggregation::_internal_mutable_key_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.key_hash_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::FunctionInput>(GetArena());
    _impl_.key_hash_ = reinterpret_cast<::acvm::acir::circuit::FunctionInput*>(p);
  }
  return _impl_.key_hash_;
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_RecursiveAggregation::mutable_key_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::acvm::acir::circuit::FunctionInput* _msg = _internal_mutable_key_hash();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.RecursiveAggregation.key_hash)
  return _msg;
}
inline void BlackBoxFuncCall_RecursiveAggregation::set_allocated_key_hash(::acvm::acir::circuit::FunctionInput* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.key_hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.key_hash_ = reinterpret_cast<::acvm::acir::circuit::FunctionInput*>(value);
  // @@protoc_insertion_point(field_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.RecursiveAggregation.key_hash)
}

// uint32 proof_type = 5;
inline void BlackBoxFuncCall_RecursiveAggregation::clear_proof_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.proof_type_ = 0u;
}
inline ::uint32_t BlackBoxFuncCall_RecursiveAggregation::proof_type() const {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.RecursiveAggregation.proof_type)
  return _internal_proof_type();
}
inline void BlackBoxFuncCall_RecursiveAggregation::set_proof_type(::uint32_t value) {
  _internal_set_proof_type(value);
  // @@protoc_insertion_point(field_set:acvm.acir.circuit.BlackBoxFuncCall.RecursiveAggregation.proof_type)
}
inline ::uint32_t BlackBoxFuncCall_RecursiveAggregation::_internal_proof_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.proof_type_;
}
inline void BlackBoxFuncCall_RecursiveAggregation::_internal_set_proof_type(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.proof_type_ = value;
}

// -------------------------------------------------------------------

// BlackBoxFuncCall_BigIntAdd

// uint32 lhs = 1;
inline void BlackBoxFuncCall_BigIntAdd::clear_lhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lhs_ = 0u;
}
inline ::uint32_t BlackBoxFuncCall_BigIntAdd::lhs() const {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.BigIntAdd.lhs)
  return _internal_lhs();
}
inline void BlackBoxFuncCall_BigIntAdd::set_lhs(::uint32_t value) {
  _internal_set_lhs(value);
  // @@protoc_insertion_point(field_set:acvm.acir.circuit.BlackBoxFuncCall.BigIntAdd.lhs)
}
inline ::uint32_t BlackBoxFuncCall_BigIntAdd::_internal_lhs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lhs_;
}
inline void BlackBoxFuncCall_BigIntAdd::_internal_set_lhs(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lhs_ = value;
}

// uint32 rhs = 2;
inline void BlackBoxFuncCall_BigIntAdd::clear_rhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rhs_ = 0u;
}
inline ::uint32_t BlackBoxFuncCall_BigIntAdd::rhs() const {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.BigIntAdd.rhs)
  return _internal_rhs();
}
inline void BlackBoxFuncCall_BigIntAdd::set_rhs(::uint32_t value) {
  _internal_set_rhs(value);
  // @@protoc_insertion_point(field_set:acvm.acir.circuit.BlackBoxFuncCall.BigIntAdd.rhs)
}
inline ::uint32_t BlackBoxFuncCall_BigIntAdd::_internal_rhs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rhs_;
}
inline void BlackBoxFuncCall_BigIntAdd::_internal_set_rhs(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rhs_ = value;
}

// uint32 output = 3;
inline void BlackBoxFuncCall_BigIntAdd::clear_output() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.output_ = 0u;
}
inline ::uint32_t BlackBoxFuncCall_BigIntAdd::output() const {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.BigIntAdd.output)
  return _internal_output();
}
inline void BlackBoxFuncCall_BigIntAdd::set_output(::uint32_t value) {
  _internal_set_output(value);
  // @@protoc_insertion_point(field_set:acvm.acir.circuit.BlackBoxFuncCall.BigIntAdd.output)
}
inline ::uint32_t BlackBoxFuncCall_BigIntAdd::_internal_output() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.output_;
}
inline void BlackBoxFuncCall_BigIntAdd::_internal_set_output(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.output_ = value;
}

// -------------------------------------------------------------------

// BlackBoxFuncCall_BigIntSub

// uint32 lhs = 1;
inline void BlackBoxFuncCall_BigIntSub::clear_lhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lhs_ = 0u;
}
inline ::uint32_t BlackBoxFuncCall_BigIntSub::lhs() const {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.BigIntSub.lhs)
  return _internal_lhs();
}
inline void BlackBoxFuncCall_BigIntSub::set_lhs(::uint32_t value) {
  _internal_set_lhs(value);
  // @@protoc_insertion_point(field_set:acvm.acir.circuit.BlackBoxFuncCall.BigIntSub.lhs)
}
inline ::uint32_t BlackBoxFuncCall_BigIntSub::_internal_lhs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lhs_;
}
inline void BlackBoxFuncCall_BigIntSub::_internal_set_lhs(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lhs_ = value;
}

// uint32 rhs = 2;
inline void BlackBoxFuncCall_BigIntSub::clear_rhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rhs_ = 0u;
}
inline ::uint32_t BlackBoxFuncCall_BigIntSub::rhs() const {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.BigIntSub.rhs)
  return _internal_rhs();
}
inline void BlackBoxFuncCall_BigIntSub::set_rhs(::uint32_t value) {
  _internal_set_rhs(value);
  // @@protoc_insertion_point(field_set:acvm.acir.circuit.BlackBoxFuncCall.BigIntSub.rhs)
}
inline ::uint32_t BlackBoxFuncCall_BigIntSub::_internal_rhs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rhs_;
}
inline void BlackBoxFuncCall_BigIntSub::_internal_set_rhs(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rhs_ = value;
}

// uint32 output = 3;
inline void BlackBoxFuncCall_BigIntSub::clear_output() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.output_ = 0u;
}
inline ::uint32_t BlackBoxFuncCall_BigIntSub::output() const {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.BigIntSub.output)
  return _internal_output();
}
inline void BlackBoxFuncCall_BigIntSub::set_output(::uint32_t value) {
  _internal_set_output(value);
  // @@protoc_insertion_point(field_set:acvm.acir.circuit.BlackBoxFuncCall.BigIntSub.output)
}
inline ::uint32_t BlackBoxFuncCall_BigIntSub::_internal_output() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.output_;
}
inline void BlackBoxFuncCall_BigIntSub::_internal_set_output(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.output_ = value;
}

// -------------------------------------------------------------------

// BlackBoxFuncCall_BigIntMul

// uint32 lhs = 1;
inline void BlackBoxFuncCall_BigIntMul::clear_lhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lhs_ = 0u;
}
inline ::uint32_t BlackBoxFuncCall_BigIntMul::lhs() const {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.BigIntMul.lhs)
  return _internal_lhs();
}
inline void BlackBoxFuncCall_BigIntMul::set_lhs(::uint32_t value) {
  _internal_set_lhs(value);
  // @@protoc_insertion_point(field_set:acvm.acir.circuit.BlackBoxFuncCall.BigIntMul.lhs)
}
inline ::uint32_t BlackBoxFuncCall_BigIntMul::_internal_lhs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lhs_;
}
inline void BlackBoxFuncCall_BigIntMul::_internal_set_lhs(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lhs_ = value;
}

// uint32 rhs = 2;
inline void BlackBoxFuncCall_BigIntMul::clear_rhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rhs_ = 0u;
}
inline ::uint32_t BlackBoxFuncCall_BigIntMul::rhs() const {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.BigIntMul.rhs)
  return _internal_rhs();
}
inline void BlackBoxFuncCall_BigIntMul::set_rhs(::uint32_t value) {
  _internal_set_rhs(value);
  // @@protoc_insertion_point(field_set:acvm.acir.circuit.BlackBoxFuncCall.BigIntMul.rhs)
}
inline ::uint32_t BlackBoxFuncCall_BigIntMul::_internal_rhs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rhs_;
}
inline void BlackBoxFuncCall_BigIntMul::_internal_set_rhs(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rhs_ = value;
}

// uint32 output = 3;
inline void BlackBoxFuncCall_BigIntMul::clear_output() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.output_ = 0u;
}
inline ::uint32_t BlackBoxFuncCall_BigIntMul::output() const {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.BigIntMul.output)
  return _internal_output();
}
inline void BlackBoxFuncCall_BigIntMul::set_output(::uint32_t value) {
  _internal_set_output(value);
  // @@protoc_insertion_point(field_set:acvm.acir.circuit.BlackBoxFuncCall.BigIntMul.output)
}
inline ::uint32_t BlackBoxFuncCall_BigIntMul::_internal_output() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.output_;
}
inline void BlackBoxFuncCall_BigIntMul::_internal_set_output(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.output_ = value;
}

// -------------------------------------------------------------------

// BlackBoxFuncCall_BigIntDiv

// uint32 lhs = 1;
inline void BlackBoxFuncCall_BigIntDiv::clear_lhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lhs_ = 0u;
}
inline ::uint32_t BlackBoxFuncCall_BigIntDiv::lhs() const {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.BigIntDiv.lhs)
  return _internal_lhs();
}
inline void BlackBoxFuncCall_BigIntDiv::set_lhs(::uint32_t value) {
  _internal_set_lhs(value);
  // @@protoc_insertion_point(field_set:acvm.acir.circuit.BlackBoxFuncCall.BigIntDiv.lhs)
}
inline ::uint32_t BlackBoxFuncCall_BigIntDiv::_internal_lhs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lhs_;
}
inline void BlackBoxFuncCall_BigIntDiv::_internal_set_lhs(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lhs_ = value;
}

// uint32 rhs = 2;
inline void BlackBoxFuncCall_BigIntDiv::clear_rhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rhs_ = 0u;
}
inline ::uint32_t BlackBoxFuncCall_BigIntDiv::rhs() const {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.BigIntDiv.rhs)
  return _internal_rhs();
}
inline void BlackBoxFuncCall_BigIntDiv::set_rhs(::uint32_t value) {
  _internal_set_rhs(value);
  // @@protoc_insertion_point(field_set:acvm.acir.circuit.BlackBoxFuncCall.BigIntDiv.rhs)
}
inline ::uint32_t BlackBoxFuncCall_BigIntDiv::_internal_rhs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rhs_;
}
inline void BlackBoxFuncCall_BigIntDiv::_internal_set_rhs(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rhs_ = value;
}

// uint32 output = 3;
inline void BlackBoxFuncCall_BigIntDiv::clear_output() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.output_ = 0u;
}
inline ::uint32_t BlackBoxFuncCall_BigIntDiv::output() const {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.BigIntDiv.output)
  return _internal_output();
}
inline void BlackBoxFuncCall_BigIntDiv::set_output(::uint32_t value) {
  _internal_set_output(value);
  // @@protoc_insertion_point(field_set:acvm.acir.circuit.BlackBoxFuncCall.BigIntDiv.output)
}
inline ::uint32_t BlackBoxFuncCall_BigIntDiv::_internal_output() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.output_;
}
inline void BlackBoxFuncCall_BigIntDiv::_internal_set_output(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.output_ = value;
}

// -------------------------------------------------------------------

// BlackBoxFuncCall_BigIntFromLeBytes

// repeated .acvm.acir.circuit.FunctionInput inputs = 1;
inline int BlackBoxFuncCall_BigIntFromLeBytes::_internal_inputs_size() const {
  return _internal_inputs().size();
}
inline int BlackBoxFuncCall_BigIntFromLeBytes::inputs_size() const {
  return _internal_inputs_size();
}
inline void BlackBoxFuncCall_BigIntFromLeBytes::clear_inputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inputs_.Clear();
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_BigIntFromLeBytes::mutable_inputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.BigIntFromLeBytes.inputs)
  return _internal_mutable_inputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* BlackBoxFuncCall_BigIntFromLeBytes::mutable_inputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BlackBoxFuncCall.BigIntFromLeBytes.inputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_inputs();
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_BigIntFromLeBytes::inputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.BigIntFromLeBytes.inputs)
  return _internal_inputs().Get(index);
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_BigIntFromLeBytes::add_inputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::circuit::FunctionInput* _add = _internal_mutable_inputs()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BlackBoxFuncCall.BigIntFromLeBytes.inputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& BlackBoxFuncCall_BigIntFromLeBytes::inputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BlackBoxFuncCall.BigIntFromLeBytes.inputs)
  return _internal_inputs();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>&
BlackBoxFuncCall_BigIntFromLeBytes::_internal_inputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.inputs_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>*
BlackBoxFuncCall_BigIntFromLeBytes::_internal_mutable_inputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.inputs_;
}

// bytes modulus = 2;
inline void BlackBoxFuncCall_BigIntFromLeBytes::clear_modulus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.modulus_.ClearToEmpty();
}
inline const std::string& BlackBoxFuncCall_BigIntFromLeBytes::modulus() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.BigIntFromLeBytes.modulus)
  return _internal_modulus();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlackBoxFuncCall_BigIntFromLeBytes::set_modulus(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.modulus_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:acvm.acir.circuit.BlackBoxFuncCall.BigIntFromLeBytes.modulus)
}
inline std::string* BlackBoxFuncCall_BigIntFromLeBytes::mutable_modulus() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_modulus();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.BigIntFromLeBytes.modulus)
  return _s;
}
inline const std::string& BlackBoxFuncCall_BigIntFromLeBytes::_internal_modulus() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.modulus_.Get();
}
inline void BlackBoxFuncCall_BigIntFromLeBytes::_internal_set_modulus(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.modulus_.Set(value, GetArena());
}
inline std::string* BlackBoxFuncCall_BigIntFromLeBytes::_internal_mutable_modulus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.modulus_.Mutable( GetArena());
}
inline std::string* BlackBoxFuncCall_BigIntFromLeBytes::release_modulus() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BlackBoxFuncCall.BigIntFromLeBytes.modulus)
  return _impl_.modulus_.Release();
}
inline void BlackBoxFuncCall_BigIntFromLeBytes::set_allocated_modulus(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.modulus_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.modulus_.IsDefault()) {
    _impl_.modulus_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.BigIntFromLeBytes.modulus)
}

// uint32 output = 3;
inline void BlackBoxFuncCall_BigIntFromLeBytes::clear_output() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.output_ = 0u;
}
inline ::uint32_t BlackBoxFuncCall_BigIntFromLeBytes::output() const {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.BigIntFromLeBytes.output)
  return _internal_output();
}
inline void BlackBoxFuncCall_BigIntFromLeBytes::set_output(::uint32_t value) {
  _internal_set_output(value);
  // @@protoc_insertion_point(field_set:acvm.acir.circuit.BlackBoxFuncCall.BigIntFromLeBytes.output)
}
inline ::uint32_t BlackBoxFuncCall_BigIntFromLeBytes::_internal_output() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.output_;
}
inline void BlackBoxFuncCall_BigIntFromLeBytes::_internal_set_output(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.output_ = value;
}

// -------------------------------------------------------------------

// BlackBoxFuncCall_BigIntToLeBytes

// uint32 input = 1;
inline void BlackBoxFuncCall_BigIntToLeBytes::clear_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_ = 0u;
}
inline ::uint32_t BlackBoxFuncCall_BigIntToLeBytes::input() const {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.BigIntToLeBytes.input)
  return _internal_input();
}
inline void BlackBoxFuncCall_BigIntToLeBytes::set_input(::uint32_t value) {
  _internal_set_input(value);
  // @@protoc_insertion_point(field_set:acvm.acir.circuit.BlackBoxFuncCall.BigIntToLeBytes.input)
}
inline ::uint32_t BlackBoxFuncCall_BigIntToLeBytes::_internal_input() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.input_;
}
inline void BlackBoxFuncCall_BigIntToLeBytes::_internal_set_input(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_ = value;
}

// repeated .acvm.acir.native.Witness outputs = 2;
inline int BlackBoxFuncCall_BigIntToLeBytes::_internal_outputs_size() const {
  return _internal_outputs().size();
}
inline int BlackBoxFuncCall_BigIntToLeBytes::outputs_size() const {
  return _internal_outputs_size();
}
inline ::acvm::acir::native::Witness* BlackBoxFuncCall_BigIntToLeBytes::mutable_outputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.BigIntToLeBytes.outputs)
  return _internal_mutable_outputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* BlackBoxFuncCall_BigIntToLeBytes::mutable_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BlackBoxFuncCall.BigIntToLeBytes.outputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_outputs();
}
inline const ::acvm::acir::native::Witness& BlackBoxFuncCall_BigIntToLeBytes::outputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.BigIntToLeBytes.outputs)
  return _internal_outputs().Get(index);
}
inline ::acvm::acir::native::Witness* BlackBoxFuncCall_BigIntToLeBytes::add_outputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::native::Witness* _add = _internal_mutable_outputs()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BlackBoxFuncCall.BigIntToLeBytes.outputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& BlackBoxFuncCall_BigIntToLeBytes::outputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BlackBoxFuncCall.BigIntToLeBytes.outputs)
  return _internal_outputs();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>&
BlackBoxFuncCall_BigIntToLeBytes::_internal_outputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.outputs_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>*
BlackBoxFuncCall_BigIntToLeBytes::_internal_mutable_outputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.outputs_;
}

// -------------------------------------------------------------------

// BlackBoxFuncCall_Poseidon2Permutation

// repeated .acvm.acir.circuit.FunctionInput inputs = 1;
inline int BlackBoxFuncCall_Poseidon2Permutation::_internal_inputs_size() const {
  return _internal_inputs().size();
}
inline int BlackBoxFuncCall_Poseidon2Permutation::inputs_size() const {
  return _internal_inputs_size();
}
inline void BlackBoxFuncCall_Poseidon2Permutation::clear_inputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inputs_.Clear();
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_Poseidon2Permutation::mutable_inputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.Poseidon2Permutation.inputs)
  return _internal_mutable_inputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* BlackBoxFuncCall_Poseidon2Permutation::mutable_inputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BlackBoxFuncCall.Poseidon2Permutation.inputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_inputs();
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_Poseidon2Permutation::inputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.Poseidon2Permutation.inputs)
  return _internal_inputs().Get(index);
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_Poseidon2Permutation::add_inputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::circuit::FunctionInput* _add = _internal_mutable_inputs()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BlackBoxFuncCall.Poseidon2Permutation.inputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& BlackBoxFuncCall_Poseidon2Permutation::inputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BlackBoxFuncCall.Poseidon2Permutation.inputs)
  return _internal_inputs();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>&
BlackBoxFuncCall_Poseidon2Permutation::_internal_inputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.inputs_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>*
BlackBoxFuncCall_Poseidon2Permutation::_internal_mutable_inputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.inputs_;
}

// repeated .acvm.acir.native.Witness outputs = 2;
inline int BlackBoxFuncCall_Poseidon2Permutation::_internal_outputs_size() const {
  return _internal_outputs().size();
}
inline int BlackBoxFuncCall_Poseidon2Permutation::outputs_size() const {
  return _internal_outputs_size();
}
inline ::acvm::acir::native::Witness* BlackBoxFuncCall_Poseidon2Permutation::mutable_outputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.Poseidon2Permutation.outputs)
  return _internal_mutable_outputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* BlackBoxFuncCall_Poseidon2Permutation::mutable_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BlackBoxFuncCall.Poseidon2Permutation.outputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_outputs();
}
inline const ::acvm::acir::native::Witness& BlackBoxFuncCall_Poseidon2Permutation::outputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.Poseidon2Permutation.outputs)
  return _internal_outputs().Get(index);
}
inline ::acvm::acir::native::Witness* BlackBoxFuncCall_Poseidon2Permutation::add_outputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::native::Witness* _add = _internal_mutable_outputs()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BlackBoxFuncCall.Poseidon2Permutation.outputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& BlackBoxFuncCall_Poseidon2Permutation::outputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BlackBoxFuncCall.Poseidon2Permutation.outputs)
  return _internal_outputs();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>&
BlackBoxFuncCall_Poseidon2Permutation::_internal_outputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.outputs_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>*
BlackBoxFuncCall_Poseidon2Permutation::_internal_mutable_outputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.outputs_;
}

// uint32 len = 3;
inline void BlackBoxFuncCall_Poseidon2Permutation::clear_len() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.len_ = 0u;
}
inline ::uint32_t BlackBoxFuncCall_Poseidon2Permutation::len() const {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.Poseidon2Permutation.len)
  return _internal_len();
}
inline void BlackBoxFuncCall_Poseidon2Permutation::set_len(::uint32_t value) {
  _internal_set_len(value);
  // @@protoc_insertion_point(field_set:acvm.acir.circuit.BlackBoxFuncCall.Poseidon2Permutation.len)
}
inline ::uint32_t BlackBoxFuncCall_Poseidon2Permutation::_internal_len() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.len_;
}
inline void BlackBoxFuncCall_Poseidon2Permutation::_internal_set_len(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.len_ = value;
}

// -------------------------------------------------------------------

// BlackBoxFuncCall_Sha256Compression

// repeated .acvm.acir.circuit.FunctionInput inputs = 1;
inline int BlackBoxFuncCall_Sha256Compression::_internal_inputs_size() const {
  return _internal_inputs().size();
}
inline int BlackBoxFuncCall_Sha256Compression::inputs_size() const {
  return _internal_inputs_size();
}
inline void BlackBoxFuncCall_Sha256Compression::clear_inputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inputs_.Clear();
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_Sha256Compression::mutable_inputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.Sha256Compression.inputs)
  return _internal_mutable_inputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* BlackBoxFuncCall_Sha256Compression::mutable_inputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BlackBoxFuncCall.Sha256Compression.inputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_inputs();
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_Sha256Compression::inputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.Sha256Compression.inputs)
  return _internal_inputs().Get(index);
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_Sha256Compression::add_inputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::circuit::FunctionInput* _add = _internal_mutable_inputs()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BlackBoxFuncCall.Sha256Compression.inputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& BlackBoxFuncCall_Sha256Compression::inputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BlackBoxFuncCall.Sha256Compression.inputs)
  return _internal_inputs();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>&
BlackBoxFuncCall_Sha256Compression::_internal_inputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.inputs_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>*
BlackBoxFuncCall_Sha256Compression::_internal_mutable_inputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.inputs_;
}

// repeated .acvm.acir.circuit.FunctionInput hash_values = 2;
inline int BlackBoxFuncCall_Sha256Compression::_internal_hash_values_size() const {
  return _internal_hash_values().size();
}
inline int BlackBoxFuncCall_Sha256Compression::hash_values_size() const {
  return _internal_hash_values_size();
}
inline void BlackBoxFuncCall_Sha256Compression::clear_hash_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_values_.Clear();
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_Sha256Compression::mutable_hash_values(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.Sha256Compression.hash_values)
  return _internal_mutable_hash_values()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>* BlackBoxFuncCall_Sha256Compression::mutable_hash_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BlackBoxFuncCall.Sha256Compression.hash_values)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_hash_values();
}
inline const ::acvm::acir::circuit::FunctionInput& BlackBoxFuncCall_Sha256Compression::hash_values(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.Sha256Compression.hash_values)
  return _internal_hash_values().Get(index);
}
inline ::acvm::acir::circuit::FunctionInput* BlackBoxFuncCall_Sha256Compression::add_hash_values() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::circuit::FunctionInput* _add = _internal_mutable_hash_values()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BlackBoxFuncCall.Sha256Compression.hash_values)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>& BlackBoxFuncCall_Sha256Compression::hash_values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BlackBoxFuncCall.Sha256Compression.hash_values)
  return _internal_hash_values();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>&
BlackBoxFuncCall_Sha256Compression::_internal_hash_values() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hash_values_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::circuit::FunctionInput>*
BlackBoxFuncCall_Sha256Compression::_internal_mutable_hash_values() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.hash_values_;
}

// repeated .acvm.acir.native.Witness outputs = 3;
inline int BlackBoxFuncCall_Sha256Compression::_internal_outputs_size() const {
  return _internal_outputs().size();
}
inline int BlackBoxFuncCall_Sha256Compression::outputs_size() const {
  return _internal_outputs_size();
}
inline ::acvm::acir::native::Witness* BlackBoxFuncCall_Sha256Compression::mutable_outputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.Sha256Compression.outputs)
  return _internal_mutable_outputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* BlackBoxFuncCall_Sha256Compression::mutable_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BlackBoxFuncCall.Sha256Compression.outputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_outputs();
}
inline const ::acvm::acir::native::Witness& BlackBoxFuncCall_Sha256Compression::outputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.Sha256Compression.outputs)
  return _internal_outputs().Get(index);
}
inline ::acvm::acir::native::Witness* BlackBoxFuncCall_Sha256Compression::add_outputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::native::Witness* _add = _internal_mutable_outputs()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BlackBoxFuncCall.Sha256Compression.outputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& BlackBoxFuncCall_Sha256Compression::outputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BlackBoxFuncCall.Sha256Compression.outputs)
  return _internal_outputs();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>&
BlackBoxFuncCall_Sha256Compression::_internal_outputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.outputs_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>*
BlackBoxFuncCall_Sha256Compression::_internal_mutable_outputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.outputs_;
}

// -------------------------------------------------------------------

// BlackBoxFuncCall

// .acvm.acir.circuit.BlackBoxFuncCall.AES128Encrypt aes128_encrypt = 1;
inline bool BlackBoxFuncCall::has_aes128_encrypt() const {
  return value_case() == kAes128Encrypt;
}
inline bool BlackBoxFuncCall::_internal_has_aes128_encrypt() const {
  return value_case() == kAes128Encrypt;
}
inline void BlackBoxFuncCall::set_has_aes128_encrypt() {
  _impl_._oneof_case_[0] = kAes128Encrypt;
}
inline void BlackBoxFuncCall::clear_aes128_encrypt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kAes128Encrypt) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.aes128_encrypt_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.aes128_encrypt_);
    }
    clear_has_value();
  }
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_AES128Encrypt* BlackBoxFuncCall::release_aes128_encrypt() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BlackBoxFuncCall.aes128_encrypt)
  if (value_case() == kAes128Encrypt) {
    clear_has_value();
    auto* temp = _impl_.value_.aes128_encrypt_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.aes128_encrypt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_AES128Encrypt& BlackBoxFuncCall::_internal_aes128_encrypt() const {
  return value_case() == kAes128Encrypt ? *_impl_.value_.aes128_encrypt_ : reinterpret_cast<::acvm::acir::circuit::BlackBoxFuncCall_AES128Encrypt&>(::acvm::acir::circuit::_BlackBoxFuncCall_AES128Encrypt_default_instance_);
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_AES128Encrypt& BlackBoxFuncCall::aes128_encrypt() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.aes128_encrypt)
  return _internal_aes128_encrypt();
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_AES128Encrypt* BlackBoxFuncCall::unsafe_arena_release_aes128_encrypt() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.BlackBoxFuncCall.aes128_encrypt)
  if (value_case() == kAes128Encrypt) {
    clear_has_value();
    auto* temp = _impl_.value_.aes128_encrypt_;
    _impl_.value_.aes128_encrypt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlackBoxFuncCall::unsafe_arena_set_allocated_aes128_encrypt(::acvm::acir::circuit::BlackBoxFuncCall_AES128Encrypt* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_aes128_encrypt();
    _impl_.value_.aes128_encrypt_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.aes128_encrypt)
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_AES128Encrypt* BlackBoxFuncCall::_internal_mutable_aes128_encrypt() {
  if (value_case() != kAes128Encrypt) {
    clear_value();
    set_has_aes128_encrypt();
    _impl_.value_.aes128_encrypt_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::BlackBoxFuncCall_AES128Encrypt>(GetArena());
  }
  return _impl_.value_.aes128_encrypt_;
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_AES128Encrypt* BlackBoxFuncCall::mutable_aes128_encrypt() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::circuit::BlackBoxFuncCall_AES128Encrypt* _msg = _internal_mutable_aes128_encrypt();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.aes128_encrypt)
  return _msg;
}

// .acvm.acir.circuit.BlackBoxFuncCall.AND and = 2;
inline bool BlackBoxFuncCall::has_and_() const {
  return value_case() == kAnd;
}
inline bool BlackBoxFuncCall::_internal_has_and_() const {
  return value_case() == kAnd;
}
inline void BlackBoxFuncCall::set_has_and_() {
  _impl_._oneof_case_[0] = kAnd;
}
inline void BlackBoxFuncCall::clear_and_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kAnd) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.and__;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.and__);
    }
    clear_has_value();
  }
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_AND* BlackBoxFuncCall::release_and_() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BlackBoxFuncCall.and)
  if (value_case() == kAnd) {
    clear_has_value();
    auto* temp = _impl_.value_.and__;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.and__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_AND& BlackBoxFuncCall::_internal_and_() const {
  return value_case() == kAnd ? *_impl_.value_.and__ : reinterpret_cast<::acvm::acir::circuit::BlackBoxFuncCall_AND&>(::acvm::acir::circuit::_BlackBoxFuncCall_AND_default_instance_);
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_AND& BlackBoxFuncCall::and_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.and)
  return _internal_and_();
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_AND* BlackBoxFuncCall::unsafe_arena_release_and_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.BlackBoxFuncCall.and)
  if (value_case() == kAnd) {
    clear_has_value();
    auto* temp = _impl_.value_.and__;
    _impl_.value_.and__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlackBoxFuncCall::unsafe_arena_set_allocated_and_(::acvm::acir::circuit::BlackBoxFuncCall_AND* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_and_();
    _impl_.value_.and__ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.and)
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_AND* BlackBoxFuncCall::_internal_mutable_and_() {
  if (value_case() != kAnd) {
    clear_value();
    set_has_and_();
    _impl_.value_.and__ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::BlackBoxFuncCall_AND>(GetArena());
  }
  return _impl_.value_.and__;
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_AND* BlackBoxFuncCall::mutable_and_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::circuit::BlackBoxFuncCall_AND* _msg = _internal_mutable_and_();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.and)
  return _msg;
}

// .acvm.acir.circuit.BlackBoxFuncCall.XOR xor = 3;
inline bool BlackBoxFuncCall::has_xor_() const {
  return value_case() == kXor;
}
inline bool BlackBoxFuncCall::_internal_has_xor_() const {
  return value_case() == kXor;
}
inline void BlackBoxFuncCall::set_has_xor_() {
  _impl_._oneof_case_[0] = kXor;
}
inline void BlackBoxFuncCall::clear_xor_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kXor) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.xor__;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.xor__);
    }
    clear_has_value();
  }
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_XOR* BlackBoxFuncCall::release_xor_() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BlackBoxFuncCall.xor)
  if (value_case() == kXor) {
    clear_has_value();
    auto* temp = _impl_.value_.xor__;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.xor__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_XOR& BlackBoxFuncCall::_internal_xor_() const {
  return value_case() == kXor ? *_impl_.value_.xor__ : reinterpret_cast<::acvm::acir::circuit::BlackBoxFuncCall_XOR&>(::acvm::acir::circuit::_BlackBoxFuncCall_XOR_default_instance_);
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_XOR& BlackBoxFuncCall::xor_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.xor)
  return _internal_xor_();
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_XOR* BlackBoxFuncCall::unsafe_arena_release_xor_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.BlackBoxFuncCall.xor)
  if (value_case() == kXor) {
    clear_has_value();
    auto* temp = _impl_.value_.xor__;
    _impl_.value_.xor__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlackBoxFuncCall::unsafe_arena_set_allocated_xor_(::acvm::acir::circuit::BlackBoxFuncCall_XOR* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_xor_();
    _impl_.value_.xor__ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.xor)
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_XOR* BlackBoxFuncCall::_internal_mutable_xor_() {
  if (value_case() != kXor) {
    clear_value();
    set_has_xor_();
    _impl_.value_.xor__ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::BlackBoxFuncCall_XOR>(GetArena());
  }
  return _impl_.value_.xor__;
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_XOR* BlackBoxFuncCall::mutable_xor_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::circuit::BlackBoxFuncCall_XOR* _msg = _internal_mutable_xor_();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.xor)
  return _msg;
}

// .acvm.acir.circuit.BlackBoxFuncCall.RANGE range = 4;
inline bool BlackBoxFuncCall::has_range() const {
  return value_case() == kRange;
}
inline bool BlackBoxFuncCall::_internal_has_range() const {
  return value_case() == kRange;
}
inline void BlackBoxFuncCall::set_has_range() {
  _impl_._oneof_case_[0] = kRange;
}
inline void BlackBoxFuncCall::clear_range() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kRange) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.range_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.range_);
    }
    clear_has_value();
  }
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_RANGE* BlackBoxFuncCall::release_range() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BlackBoxFuncCall.range)
  if (value_case() == kRange) {
    clear_has_value();
    auto* temp = _impl_.value_.range_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_RANGE& BlackBoxFuncCall::_internal_range() const {
  return value_case() == kRange ? *_impl_.value_.range_ : reinterpret_cast<::acvm::acir::circuit::BlackBoxFuncCall_RANGE&>(::acvm::acir::circuit::_BlackBoxFuncCall_RANGE_default_instance_);
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_RANGE& BlackBoxFuncCall::range() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.range)
  return _internal_range();
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_RANGE* BlackBoxFuncCall::unsafe_arena_release_range() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.BlackBoxFuncCall.range)
  if (value_case() == kRange) {
    clear_has_value();
    auto* temp = _impl_.value_.range_;
    _impl_.value_.range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlackBoxFuncCall::unsafe_arena_set_allocated_range(::acvm::acir::circuit::BlackBoxFuncCall_RANGE* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_range();
    _impl_.value_.range_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.range)
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_RANGE* BlackBoxFuncCall::_internal_mutable_range() {
  if (value_case() != kRange) {
    clear_value();
    set_has_range();
    _impl_.value_.range_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::BlackBoxFuncCall_RANGE>(GetArena());
  }
  return _impl_.value_.range_;
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_RANGE* BlackBoxFuncCall::mutable_range() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::circuit::BlackBoxFuncCall_RANGE* _msg = _internal_mutable_range();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.range)
  return _msg;
}

// .acvm.acir.circuit.BlackBoxFuncCall.Blake2s blake2s = 5;
inline bool BlackBoxFuncCall::has_blake2s() const {
  return value_case() == kBlake2S;
}
inline bool BlackBoxFuncCall::_internal_has_blake2s() const {
  return value_case() == kBlake2S;
}
inline void BlackBoxFuncCall::set_has_blake2s() {
  _impl_._oneof_case_[0] = kBlake2S;
}
inline void BlackBoxFuncCall::clear_blake2s() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kBlake2S) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.blake2s_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.blake2s_);
    }
    clear_has_value();
  }
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_Blake2s* BlackBoxFuncCall::release_blake2s() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BlackBoxFuncCall.blake2s)
  if (value_case() == kBlake2S) {
    clear_has_value();
    auto* temp = _impl_.value_.blake2s_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.blake2s_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_Blake2s& BlackBoxFuncCall::_internal_blake2s() const {
  return value_case() == kBlake2S ? *_impl_.value_.blake2s_ : reinterpret_cast<::acvm::acir::circuit::BlackBoxFuncCall_Blake2s&>(::acvm::acir::circuit::_BlackBoxFuncCall_Blake2s_default_instance_);
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_Blake2s& BlackBoxFuncCall::blake2s() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.blake2s)
  return _internal_blake2s();
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_Blake2s* BlackBoxFuncCall::unsafe_arena_release_blake2s() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.BlackBoxFuncCall.blake2s)
  if (value_case() == kBlake2S) {
    clear_has_value();
    auto* temp = _impl_.value_.blake2s_;
    _impl_.value_.blake2s_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlackBoxFuncCall::unsafe_arena_set_allocated_blake2s(::acvm::acir::circuit::BlackBoxFuncCall_Blake2s* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_blake2s();
    _impl_.value_.blake2s_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.blake2s)
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_Blake2s* BlackBoxFuncCall::_internal_mutable_blake2s() {
  if (value_case() != kBlake2S) {
    clear_value();
    set_has_blake2s();
    _impl_.value_.blake2s_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::BlackBoxFuncCall_Blake2s>(GetArena());
  }
  return _impl_.value_.blake2s_;
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_Blake2s* BlackBoxFuncCall::mutable_blake2s() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::circuit::BlackBoxFuncCall_Blake2s* _msg = _internal_mutable_blake2s();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.blake2s)
  return _msg;
}

// .acvm.acir.circuit.BlackBoxFuncCall.Blake3 blake3 = 6;
inline bool BlackBoxFuncCall::has_blake3() const {
  return value_case() == kBlake3;
}
inline bool BlackBoxFuncCall::_internal_has_blake3() const {
  return value_case() == kBlake3;
}
inline void BlackBoxFuncCall::set_has_blake3() {
  _impl_._oneof_case_[0] = kBlake3;
}
inline void BlackBoxFuncCall::clear_blake3() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kBlake3) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.blake3_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.blake3_);
    }
    clear_has_value();
  }
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_Blake3* BlackBoxFuncCall::release_blake3() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BlackBoxFuncCall.blake3)
  if (value_case() == kBlake3) {
    clear_has_value();
    auto* temp = _impl_.value_.blake3_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.blake3_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_Blake3& BlackBoxFuncCall::_internal_blake3() const {
  return value_case() == kBlake3 ? *_impl_.value_.blake3_ : reinterpret_cast<::acvm::acir::circuit::BlackBoxFuncCall_Blake3&>(::acvm::acir::circuit::_BlackBoxFuncCall_Blake3_default_instance_);
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_Blake3& BlackBoxFuncCall::blake3() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.blake3)
  return _internal_blake3();
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_Blake3* BlackBoxFuncCall::unsafe_arena_release_blake3() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.BlackBoxFuncCall.blake3)
  if (value_case() == kBlake3) {
    clear_has_value();
    auto* temp = _impl_.value_.blake3_;
    _impl_.value_.blake3_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlackBoxFuncCall::unsafe_arena_set_allocated_blake3(::acvm::acir::circuit::BlackBoxFuncCall_Blake3* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_blake3();
    _impl_.value_.blake3_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.blake3)
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_Blake3* BlackBoxFuncCall::_internal_mutable_blake3() {
  if (value_case() != kBlake3) {
    clear_value();
    set_has_blake3();
    _impl_.value_.blake3_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::BlackBoxFuncCall_Blake3>(GetArena());
  }
  return _impl_.value_.blake3_;
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_Blake3* BlackBoxFuncCall::mutable_blake3() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::circuit::BlackBoxFuncCall_Blake3* _msg = _internal_mutable_blake3();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.blake3)
  return _msg;
}

// .acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256k1 ecdsa_secp256k1 = 7;
inline bool BlackBoxFuncCall::has_ecdsa_secp256k1() const {
  return value_case() == kEcdsaSecp256K1;
}
inline bool BlackBoxFuncCall::_internal_has_ecdsa_secp256k1() const {
  return value_case() == kEcdsaSecp256K1;
}
inline void BlackBoxFuncCall::set_has_ecdsa_secp256k1() {
  _impl_._oneof_case_[0] = kEcdsaSecp256K1;
}
inline void BlackBoxFuncCall::clear_ecdsa_secp256k1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kEcdsaSecp256K1) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.ecdsa_secp256k1_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.ecdsa_secp256k1_);
    }
    clear_has_value();
  }
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256k1* BlackBoxFuncCall::release_ecdsa_secp256k1() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BlackBoxFuncCall.ecdsa_secp256k1)
  if (value_case() == kEcdsaSecp256K1) {
    clear_has_value();
    auto* temp = _impl_.value_.ecdsa_secp256k1_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.ecdsa_secp256k1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256k1& BlackBoxFuncCall::_internal_ecdsa_secp256k1() const {
  return value_case() == kEcdsaSecp256K1 ? *_impl_.value_.ecdsa_secp256k1_ : reinterpret_cast<::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256k1&>(::acvm::acir::circuit::_BlackBoxFuncCall_EcdsaSecp256k1_default_instance_);
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256k1& BlackBoxFuncCall::ecdsa_secp256k1() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.ecdsa_secp256k1)
  return _internal_ecdsa_secp256k1();
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256k1* BlackBoxFuncCall::unsafe_arena_release_ecdsa_secp256k1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.BlackBoxFuncCall.ecdsa_secp256k1)
  if (value_case() == kEcdsaSecp256K1) {
    clear_has_value();
    auto* temp = _impl_.value_.ecdsa_secp256k1_;
    _impl_.value_.ecdsa_secp256k1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlackBoxFuncCall::unsafe_arena_set_allocated_ecdsa_secp256k1(::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256k1* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_ecdsa_secp256k1();
    _impl_.value_.ecdsa_secp256k1_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.ecdsa_secp256k1)
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256k1* BlackBoxFuncCall::_internal_mutable_ecdsa_secp256k1() {
  if (value_case() != kEcdsaSecp256K1) {
    clear_value();
    set_has_ecdsa_secp256k1();
    _impl_.value_.ecdsa_secp256k1_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256k1>(GetArena());
  }
  return _impl_.value_.ecdsa_secp256k1_;
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256k1* BlackBoxFuncCall::mutable_ecdsa_secp256k1() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256k1* _msg = _internal_mutable_ecdsa_secp256k1();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.ecdsa_secp256k1)
  return _msg;
}

// .acvm.acir.circuit.BlackBoxFuncCall.EcdsaSecp256r1 ecdsa_secp256r1 = 8;
inline bool BlackBoxFuncCall::has_ecdsa_secp256r1() const {
  return value_case() == kEcdsaSecp256R1;
}
inline bool BlackBoxFuncCall::_internal_has_ecdsa_secp256r1() const {
  return value_case() == kEcdsaSecp256R1;
}
inline void BlackBoxFuncCall::set_has_ecdsa_secp256r1() {
  _impl_._oneof_case_[0] = kEcdsaSecp256R1;
}
inline void BlackBoxFuncCall::clear_ecdsa_secp256r1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kEcdsaSecp256R1) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.ecdsa_secp256r1_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.ecdsa_secp256r1_);
    }
    clear_has_value();
  }
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256r1* BlackBoxFuncCall::release_ecdsa_secp256r1() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BlackBoxFuncCall.ecdsa_secp256r1)
  if (value_case() == kEcdsaSecp256R1) {
    clear_has_value();
    auto* temp = _impl_.value_.ecdsa_secp256r1_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.ecdsa_secp256r1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256r1& BlackBoxFuncCall::_internal_ecdsa_secp256r1() const {
  return value_case() == kEcdsaSecp256R1 ? *_impl_.value_.ecdsa_secp256r1_ : reinterpret_cast<::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256r1&>(::acvm::acir::circuit::_BlackBoxFuncCall_EcdsaSecp256r1_default_instance_);
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256r1& BlackBoxFuncCall::ecdsa_secp256r1() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.ecdsa_secp256r1)
  return _internal_ecdsa_secp256r1();
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256r1* BlackBoxFuncCall::unsafe_arena_release_ecdsa_secp256r1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.BlackBoxFuncCall.ecdsa_secp256r1)
  if (value_case() == kEcdsaSecp256R1) {
    clear_has_value();
    auto* temp = _impl_.value_.ecdsa_secp256r1_;
    _impl_.value_.ecdsa_secp256r1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlackBoxFuncCall::unsafe_arena_set_allocated_ecdsa_secp256r1(::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256r1* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_ecdsa_secp256r1();
    _impl_.value_.ecdsa_secp256r1_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.ecdsa_secp256r1)
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256r1* BlackBoxFuncCall::_internal_mutable_ecdsa_secp256r1() {
  if (value_case() != kEcdsaSecp256R1) {
    clear_value();
    set_has_ecdsa_secp256r1();
    _impl_.value_.ecdsa_secp256r1_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256r1>(GetArena());
  }
  return _impl_.value_.ecdsa_secp256r1_;
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256r1* BlackBoxFuncCall::mutable_ecdsa_secp256r1() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::circuit::BlackBoxFuncCall_EcdsaSecp256r1* _msg = _internal_mutable_ecdsa_secp256r1();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.ecdsa_secp256r1)
  return _msg;
}

// .acvm.acir.circuit.BlackBoxFuncCall.MultiScalarMul multi_scalar_mul = 9;
inline bool BlackBoxFuncCall::has_multi_scalar_mul() const {
  return value_case() == kMultiScalarMul;
}
inline bool BlackBoxFuncCall::_internal_has_multi_scalar_mul() const {
  return value_case() == kMultiScalarMul;
}
inline void BlackBoxFuncCall::set_has_multi_scalar_mul() {
  _impl_._oneof_case_[0] = kMultiScalarMul;
}
inline void BlackBoxFuncCall::clear_multi_scalar_mul() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kMultiScalarMul) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.multi_scalar_mul_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.multi_scalar_mul_);
    }
    clear_has_value();
  }
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_MultiScalarMul* BlackBoxFuncCall::release_multi_scalar_mul() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BlackBoxFuncCall.multi_scalar_mul)
  if (value_case() == kMultiScalarMul) {
    clear_has_value();
    auto* temp = _impl_.value_.multi_scalar_mul_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.multi_scalar_mul_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_MultiScalarMul& BlackBoxFuncCall::_internal_multi_scalar_mul() const {
  return value_case() == kMultiScalarMul ? *_impl_.value_.multi_scalar_mul_ : reinterpret_cast<::acvm::acir::circuit::BlackBoxFuncCall_MultiScalarMul&>(::acvm::acir::circuit::_BlackBoxFuncCall_MultiScalarMul_default_instance_);
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_MultiScalarMul& BlackBoxFuncCall::multi_scalar_mul() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.multi_scalar_mul)
  return _internal_multi_scalar_mul();
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_MultiScalarMul* BlackBoxFuncCall::unsafe_arena_release_multi_scalar_mul() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.BlackBoxFuncCall.multi_scalar_mul)
  if (value_case() == kMultiScalarMul) {
    clear_has_value();
    auto* temp = _impl_.value_.multi_scalar_mul_;
    _impl_.value_.multi_scalar_mul_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlackBoxFuncCall::unsafe_arena_set_allocated_multi_scalar_mul(::acvm::acir::circuit::BlackBoxFuncCall_MultiScalarMul* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_multi_scalar_mul();
    _impl_.value_.multi_scalar_mul_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.multi_scalar_mul)
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_MultiScalarMul* BlackBoxFuncCall::_internal_mutable_multi_scalar_mul() {
  if (value_case() != kMultiScalarMul) {
    clear_value();
    set_has_multi_scalar_mul();
    _impl_.value_.multi_scalar_mul_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::BlackBoxFuncCall_MultiScalarMul>(GetArena());
  }
  return _impl_.value_.multi_scalar_mul_;
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_MultiScalarMul* BlackBoxFuncCall::mutable_multi_scalar_mul() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::circuit::BlackBoxFuncCall_MultiScalarMul* _msg = _internal_mutable_multi_scalar_mul();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.multi_scalar_mul)
  return _msg;
}

// .acvm.acir.circuit.BlackBoxFuncCall.EmbeddedCurveAdd embedded_curve_add = 10;
inline bool BlackBoxFuncCall::has_embedded_curve_add() const {
  return value_case() == kEmbeddedCurveAdd;
}
inline bool BlackBoxFuncCall::_internal_has_embedded_curve_add() const {
  return value_case() == kEmbeddedCurveAdd;
}
inline void BlackBoxFuncCall::set_has_embedded_curve_add() {
  _impl_._oneof_case_[0] = kEmbeddedCurveAdd;
}
inline void BlackBoxFuncCall::clear_embedded_curve_add() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kEmbeddedCurveAdd) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.embedded_curve_add_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.embedded_curve_add_);
    }
    clear_has_value();
  }
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_EmbeddedCurveAdd* BlackBoxFuncCall::release_embedded_curve_add() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BlackBoxFuncCall.embedded_curve_add)
  if (value_case() == kEmbeddedCurveAdd) {
    clear_has_value();
    auto* temp = _impl_.value_.embedded_curve_add_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.embedded_curve_add_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_EmbeddedCurveAdd& BlackBoxFuncCall::_internal_embedded_curve_add() const {
  return value_case() == kEmbeddedCurveAdd ? *_impl_.value_.embedded_curve_add_ : reinterpret_cast<::acvm::acir::circuit::BlackBoxFuncCall_EmbeddedCurveAdd&>(::acvm::acir::circuit::_BlackBoxFuncCall_EmbeddedCurveAdd_default_instance_);
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_EmbeddedCurveAdd& BlackBoxFuncCall::embedded_curve_add() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.embedded_curve_add)
  return _internal_embedded_curve_add();
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_EmbeddedCurveAdd* BlackBoxFuncCall::unsafe_arena_release_embedded_curve_add() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.BlackBoxFuncCall.embedded_curve_add)
  if (value_case() == kEmbeddedCurveAdd) {
    clear_has_value();
    auto* temp = _impl_.value_.embedded_curve_add_;
    _impl_.value_.embedded_curve_add_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlackBoxFuncCall::unsafe_arena_set_allocated_embedded_curve_add(::acvm::acir::circuit::BlackBoxFuncCall_EmbeddedCurveAdd* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_embedded_curve_add();
    _impl_.value_.embedded_curve_add_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.embedded_curve_add)
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_EmbeddedCurveAdd* BlackBoxFuncCall::_internal_mutable_embedded_curve_add() {
  if (value_case() != kEmbeddedCurveAdd) {
    clear_value();
    set_has_embedded_curve_add();
    _impl_.value_.embedded_curve_add_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::BlackBoxFuncCall_EmbeddedCurveAdd>(GetArena());
  }
  return _impl_.value_.embedded_curve_add_;
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_EmbeddedCurveAdd* BlackBoxFuncCall::mutable_embedded_curve_add() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::circuit::BlackBoxFuncCall_EmbeddedCurveAdd* _msg = _internal_mutable_embedded_curve_add();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.embedded_curve_add)
  return _msg;
}

// .acvm.acir.circuit.BlackBoxFuncCall.Keccakf1600 keccak_f1600 = 11;
inline bool BlackBoxFuncCall::has_keccak_f1600() const {
  return value_case() == kKeccakF1600;
}
inline bool BlackBoxFuncCall::_internal_has_keccak_f1600() const {
  return value_case() == kKeccakF1600;
}
inline void BlackBoxFuncCall::set_has_keccak_f1600() {
  _impl_._oneof_case_[0] = kKeccakF1600;
}
inline void BlackBoxFuncCall::clear_keccak_f1600() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kKeccakF1600) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.keccak_f1600_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.keccak_f1600_);
    }
    clear_has_value();
  }
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_Keccakf1600* BlackBoxFuncCall::release_keccak_f1600() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BlackBoxFuncCall.keccak_f1600)
  if (value_case() == kKeccakF1600) {
    clear_has_value();
    auto* temp = _impl_.value_.keccak_f1600_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.keccak_f1600_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_Keccakf1600& BlackBoxFuncCall::_internal_keccak_f1600() const {
  return value_case() == kKeccakF1600 ? *_impl_.value_.keccak_f1600_ : reinterpret_cast<::acvm::acir::circuit::BlackBoxFuncCall_Keccakf1600&>(::acvm::acir::circuit::_BlackBoxFuncCall_Keccakf1600_default_instance_);
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_Keccakf1600& BlackBoxFuncCall::keccak_f1600() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.keccak_f1600)
  return _internal_keccak_f1600();
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_Keccakf1600* BlackBoxFuncCall::unsafe_arena_release_keccak_f1600() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.BlackBoxFuncCall.keccak_f1600)
  if (value_case() == kKeccakF1600) {
    clear_has_value();
    auto* temp = _impl_.value_.keccak_f1600_;
    _impl_.value_.keccak_f1600_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlackBoxFuncCall::unsafe_arena_set_allocated_keccak_f1600(::acvm::acir::circuit::BlackBoxFuncCall_Keccakf1600* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_keccak_f1600();
    _impl_.value_.keccak_f1600_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.keccak_f1600)
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_Keccakf1600* BlackBoxFuncCall::_internal_mutable_keccak_f1600() {
  if (value_case() != kKeccakF1600) {
    clear_value();
    set_has_keccak_f1600();
    _impl_.value_.keccak_f1600_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::BlackBoxFuncCall_Keccakf1600>(GetArena());
  }
  return _impl_.value_.keccak_f1600_;
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_Keccakf1600* BlackBoxFuncCall::mutable_keccak_f1600() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::circuit::BlackBoxFuncCall_Keccakf1600* _msg = _internal_mutable_keccak_f1600();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.keccak_f1600)
  return _msg;
}

// .acvm.acir.circuit.BlackBoxFuncCall.RecursiveAggregation recursive_aggregation = 12;
inline bool BlackBoxFuncCall::has_recursive_aggregation() const {
  return value_case() == kRecursiveAggregation;
}
inline bool BlackBoxFuncCall::_internal_has_recursive_aggregation() const {
  return value_case() == kRecursiveAggregation;
}
inline void BlackBoxFuncCall::set_has_recursive_aggregation() {
  _impl_._oneof_case_[0] = kRecursiveAggregation;
}
inline void BlackBoxFuncCall::clear_recursive_aggregation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kRecursiveAggregation) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.recursive_aggregation_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.recursive_aggregation_);
    }
    clear_has_value();
  }
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_RecursiveAggregation* BlackBoxFuncCall::release_recursive_aggregation() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BlackBoxFuncCall.recursive_aggregation)
  if (value_case() == kRecursiveAggregation) {
    clear_has_value();
    auto* temp = _impl_.value_.recursive_aggregation_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.recursive_aggregation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_RecursiveAggregation& BlackBoxFuncCall::_internal_recursive_aggregation() const {
  return value_case() == kRecursiveAggregation ? *_impl_.value_.recursive_aggregation_ : reinterpret_cast<::acvm::acir::circuit::BlackBoxFuncCall_RecursiveAggregation&>(::acvm::acir::circuit::_BlackBoxFuncCall_RecursiveAggregation_default_instance_);
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_RecursiveAggregation& BlackBoxFuncCall::recursive_aggregation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.recursive_aggregation)
  return _internal_recursive_aggregation();
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_RecursiveAggregation* BlackBoxFuncCall::unsafe_arena_release_recursive_aggregation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.BlackBoxFuncCall.recursive_aggregation)
  if (value_case() == kRecursiveAggregation) {
    clear_has_value();
    auto* temp = _impl_.value_.recursive_aggregation_;
    _impl_.value_.recursive_aggregation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlackBoxFuncCall::unsafe_arena_set_allocated_recursive_aggregation(::acvm::acir::circuit::BlackBoxFuncCall_RecursiveAggregation* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_recursive_aggregation();
    _impl_.value_.recursive_aggregation_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.recursive_aggregation)
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_RecursiveAggregation* BlackBoxFuncCall::_internal_mutable_recursive_aggregation() {
  if (value_case() != kRecursiveAggregation) {
    clear_value();
    set_has_recursive_aggregation();
    _impl_.value_.recursive_aggregation_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::BlackBoxFuncCall_RecursiveAggregation>(GetArena());
  }
  return _impl_.value_.recursive_aggregation_;
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_RecursiveAggregation* BlackBoxFuncCall::mutable_recursive_aggregation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::circuit::BlackBoxFuncCall_RecursiveAggregation* _msg = _internal_mutable_recursive_aggregation();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.recursive_aggregation)
  return _msg;
}

// .acvm.acir.circuit.BlackBoxFuncCall.BigIntAdd big_int_add = 13;
inline bool BlackBoxFuncCall::has_big_int_add() const {
  return value_case() == kBigIntAdd;
}
inline bool BlackBoxFuncCall::_internal_has_big_int_add() const {
  return value_case() == kBigIntAdd;
}
inline void BlackBoxFuncCall::set_has_big_int_add() {
  _impl_._oneof_case_[0] = kBigIntAdd;
}
inline void BlackBoxFuncCall::clear_big_int_add() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kBigIntAdd) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.big_int_add_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.big_int_add_);
    }
    clear_has_value();
  }
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_BigIntAdd* BlackBoxFuncCall::release_big_int_add() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BlackBoxFuncCall.big_int_add)
  if (value_case() == kBigIntAdd) {
    clear_has_value();
    auto* temp = _impl_.value_.big_int_add_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.big_int_add_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_BigIntAdd& BlackBoxFuncCall::_internal_big_int_add() const {
  return value_case() == kBigIntAdd ? *_impl_.value_.big_int_add_ : reinterpret_cast<::acvm::acir::circuit::BlackBoxFuncCall_BigIntAdd&>(::acvm::acir::circuit::_BlackBoxFuncCall_BigIntAdd_default_instance_);
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_BigIntAdd& BlackBoxFuncCall::big_int_add() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.big_int_add)
  return _internal_big_int_add();
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_BigIntAdd* BlackBoxFuncCall::unsafe_arena_release_big_int_add() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.BlackBoxFuncCall.big_int_add)
  if (value_case() == kBigIntAdd) {
    clear_has_value();
    auto* temp = _impl_.value_.big_int_add_;
    _impl_.value_.big_int_add_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlackBoxFuncCall::unsafe_arena_set_allocated_big_int_add(::acvm::acir::circuit::BlackBoxFuncCall_BigIntAdd* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_big_int_add();
    _impl_.value_.big_int_add_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.big_int_add)
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_BigIntAdd* BlackBoxFuncCall::_internal_mutable_big_int_add() {
  if (value_case() != kBigIntAdd) {
    clear_value();
    set_has_big_int_add();
    _impl_.value_.big_int_add_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::BlackBoxFuncCall_BigIntAdd>(GetArena());
  }
  return _impl_.value_.big_int_add_;
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_BigIntAdd* BlackBoxFuncCall::mutable_big_int_add() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::circuit::BlackBoxFuncCall_BigIntAdd* _msg = _internal_mutable_big_int_add();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.big_int_add)
  return _msg;
}

// .acvm.acir.circuit.BlackBoxFuncCall.BigIntSub big_int_sub = 14;
inline bool BlackBoxFuncCall::has_big_int_sub() const {
  return value_case() == kBigIntSub;
}
inline bool BlackBoxFuncCall::_internal_has_big_int_sub() const {
  return value_case() == kBigIntSub;
}
inline void BlackBoxFuncCall::set_has_big_int_sub() {
  _impl_._oneof_case_[0] = kBigIntSub;
}
inline void BlackBoxFuncCall::clear_big_int_sub() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kBigIntSub) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.big_int_sub_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.big_int_sub_);
    }
    clear_has_value();
  }
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_BigIntSub* BlackBoxFuncCall::release_big_int_sub() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BlackBoxFuncCall.big_int_sub)
  if (value_case() == kBigIntSub) {
    clear_has_value();
    auto* temp = _impl_.value_.big_int_sub_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.big_int_sub_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_BigIntSub& BlackBoxFuncCall::_internal_big_int_sub() const {
  return value_case() == kBigIntSub ? *_impl_.value_.big_int_sub_ : reinterpret_cast<::acvm::acir::circuit::BlackBoxFuncCall_BigIntSub&>(::acvm::acir::circuit::_BlackBoxFuncCall_BigIntSub_default_instance_);
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_BigIntSub& BlackBoxFuncCall::big_int_sub() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.big_int_sub)
  return _internal_big_int_sub();
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_BigIntSub* BlackBoxFuncCall::unsafe_arena_release_big_int_sub() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.BlackBoxFuncCall.big_int_sub)
  if (value_case() == kBigIntSub) {
    clear_has_value();
    auto* temp = _impl_.value_.big_int_sub_;
    _impl_.value_.big_int_sub_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlackBoxFuncCall::unsafe_arena_set_allocated_big_int_sub(::acvm::acir::circuit::BlackBoxFuncCall_BigIntSub* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_big_int_sub();
    _impl_.value_.big_int_sub_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.big_int_sub)
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_BigIntSub* BlackBoxFuncCall::_internal_mutable_big_int_sub() {
  if (value_case() != kBigIntSub) {
    clear_value();
    set_has_big_int_sub();
    _impl_.value_.big_int_sub_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::BlackBoxFuncCall_BigIntSub>(GetArena());
  }
  return _impl_.value_.big_int_sub_;
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_BigIntSub* BlackBoxFuncCall::mutable_big_int_sub() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::circuit::BlackBoxFuncCall_BigIntSub* _msg = _internal_mutable_big_int_sub();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.big_int_sub)
  return _msg;
}

// .acvm.acir.circuit.BlackBoxFuncCall.BigIntMul big_int_mul = 15;
inline bool BlackBoxFuncCall::has_big_int_mul() const {
  return value_case() == kBigIntMul;
}
inline bool BlackBoxFuncCall::_internal_has_big_int_mul() const {
  return value_case() == kBigIntMul;
}
inline void BlackBoxFuncCall::set_has_big_int_mul() {
  _impl_._oneof_case_[0] = kBigIntMul;
}
inline void BlackBoxFuncCall::clear_big_int_mul() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kBigIntMul) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.big_int_mul_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.big_int_mul_);
    }
    clear_has_value();
  }
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_BigIntMul* BlackBoxFuncCall::release_big_int_mul() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BlackBoxFuncCall.big_int_mul)
  if (value_case() == kBigIntMul) {
    clear_has_value();
    auto* temp = _impl_.value_.big_int_mul_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.big_int_mul_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_BigIntMul& BlackBoxFuncCall::_internal_big_int_mul() const {
  return value_case() == kBigIntMul ? *_impl_.value_.big_int_mul_ : reinterpret_cast<::acvm::acir::circuit::BlackBoxFuncCall_BigIntMul&>(::acvm::acir::circuit::_BlackBoxFuncCall_BigIntMul_default_instance_);
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_BigIntMul& BlackBoxFuncCall::big_int_mul() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.big_int_mul)
  return _internal_big_int_mul();
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_BigIntMul* BlackBoxFuncCall::unsafe_arena_release_big_int_mul() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.BlackBoxFuncCall.big_int_mul)
  if (value_case() == kBigIntMul) {
    clear_has_value();
    auto* temp = _impl_.value_.big_int_mul_;
    _impl_.value_.big_int_mul_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlackBoxFuncCall::unsafe_arena_set_allocated_big_int_mul(::acvm::acir::circuit::BlackBoxFuncCall_BigIntMul* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_big_int_mul();
    _impl_.value_.big_int_mul_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.big_int_mul)
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_BigIntMul* BlackBoxFuncCall::_internal_mutable_big_int_mul() {
  if (value_case() != kBigIntMul) {
    clear_value();
    set_has_big_int_mul();
    _impl_.value_.big_int_mul_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::BlackBoxFuncCall_BigIntMul>(GetArena());
  }
  return _impl_.value_.big_int_mul_;
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_BigIntMul* BlackBoxFuncCall::mutable_big_int_mul() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::circuit::BlackBoxFuncCall_BigIntMul* _msg = _internal_mutable_big_int_mul();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.big_int_mul)
  return _msg;
}

// .acvm.acir.circuit.BlackBoxFuncCall.BigIntDiv big_int_div = 16;
inline bool BlackBoxFuncCall::has_big_int_div() const {
  return value_case() == kBigIntDiv;
}
inline bool BlackBoxFuncCall::_internal_has_big_int_div() const {
  return value_case() == kBigIntDiv;
}
inline void BlackBoxFuncCall::set_has_big_int_div() {
  _impl_._oneof_case_[0] = kBigIntDiv;
}
inline void BlackBoxFuncCall::clear_big_int_div() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kBigIntDiv) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.big_int_div_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.big_int_div_);
    }
    clear_has_value();
  }
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_BigIntDiv* BlackBoxFuncCall::release_big_int_div() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BlackBoxFuncCall.big_int_div)
  if (value_case() == kBigIntDiv) {
    clear_has_value();
    auto* temp = _impl_.value_.big_int_div_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.big_int_div_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_BigIntDiv& BlackBoxFuncCall::_internal_big_int_div() const {
  return value_case() == kBigIntDiv ? *_impl_.value_.big_int_div_ : reinterpret_cast<::acvm::acir::circuit::BlackBoxFuncCall_BigIntDiv&>(::acvm::acir::circuit::_BlackBoxFuncCall_BigIntDiv_default_instance_);
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_BigIntDiv& BlackBoxFuncCall::big_int_div() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.big_int_div)
  return _internal_big_int_div();
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_BigIntDiv* BlackBoxFuncCall::unsafe_arena_release_big_int_div() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.BlackBoxFuncCall.big_int_div)
  if (value_case() == kBigIntDiv) {
    clear_has_value();
    auto* temp = _impl_.value_.big_int_div_;
    _impl_.value_.big_int_div_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlackBoxFuncCall::unsafe_arena_set_allocated_big_int_div(::acvm::acir::circuit::BlackBoxFuncCall_BigIntDiv* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_big_int_div();
    _impl_.value_.big_int_div_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.big_int_div)
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_BigIntDiv* BlackBoxFuncCall::_internal_mutable_big_int_div() {
  if (value_case() != kBigIntDiv) {
    clear_value();
    set_has_big_int_div();
    _impl_.value_.big_int_div_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::BlackBoxFuncCall_BigIntDiv>(GetArena());
  }
  return _impl_.value_.big_int_div_;
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_BigIntDiv* BlackBoxFuncCall::mutable_big_int_div() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::circuit::BlackBoxFuncCall_BigIntDiv* _msg = _internal_mutable_big_int_div();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.big_int_div)
  return _msg;
}

// .acvm.acir.circuit.BlackBoxFuncCall.BigIntFromLeBytes big_int_from_le_bytes = 17;
inline bool BlackBoxFuncCall::has_big_int_from_le_bytes() const {
  return value_case() == kBigIntFromLeBytes;
}
inline bool BlackBoxFuncCall::_internal_has_big_int_from_le_bytes() const {
  return value_case() == kBigIntFromLeBytes;
}
inline void BlackBoxFuncCall::set_has_big_int_from_le_bytes() {
  _impl_._oneof_case_[0] = kBigIntFromLeBytes;
}
inline void BlackBoxFuncCall::clear_big_int_from_le_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kBigIntFromLeBytes) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.big_int_from_le_bytes_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.big_int_from_le_bytes_);
    }
    clear_has_value();
  }
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_BigIntFromLeBytes* BlackBoxFuncCall::release_big_int_from_le_bytes() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BlackBoxFuncCall.big_int_from_le_bytes)
  if (value_case() == kBigIntFromLeBytes) {
    clear_has_value();
    auto* temp = _impl_.value_.big_int_from_le_bytes_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.big_int_from_le_bytes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_BigIntFromLeBytes& BlackBoxFuncCall::_internal_big_int_from_le_bytes() const {
  return value_case() == kBigIntFromLeBytes ? *_impl_.value_.big_int_from_le_bytes_ : reinterpret_cast<::acvm::acir::circuit::BlackBoxFuncCall_BigIntFromLeBytes&>(::acvm::acir::circuit::_BlackBoxFuncCall_BigIntFromLeBytes_default_instance_);
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_BigIntFromLeBytes& BlackBoxFuncCall::big_int_from_le_bytes() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.big_int_from_le_bytes)
  return _internal_big_int_from_le_bytes();
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_BigIntFromLeBytes* BlackBoxFuncCall::unsafe_arena_release_big_int_from_le_bytes() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.BlackBoxFuncCall.big_int_from_le_bytes)
  if (value_case() == kBigIntFromLeBytes) {
    clear_has_value();
    auto* temp = _impl_.value_.big_int_from_le_bytes_;
    _impl_.value_.big_int_from_le_bytes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlackBoxFuncCall::unsafe_arena_set_allocated_big_int_from_le_bytes(::acvm::acir::circuit::BlackBoxFuncCall_BigIntFromLeBytes* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_big_int_from_le_bytes();
    _impl_.value_.big_int_from_le_bytes_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.big_int_from_le_bytes)
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_BigIntFromLeBytes* BlackBoxFuncCall::_internal_mutable_big_int_from_le_bytes() {
  if (value_case() != kBigIntFromLeBytes) {
    clear_value();
    set_has_big_int_from_le_bytes();
    _impl_.value_.big_int_from_le_bytes_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::BlackBoxFuncCall_BigIntFromLeBytes>(GetArena());
  }
  return _impl_.value_.big_int_from_le_bytes_;
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_BigIntFromLeBytes* BlackBoxFuncCall::mutable_big_int_from_le_bytes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::circuit::BlackBoxFuncCall_BigIntFromLeBytes* _msg = _internal_mutable_big_int_from_le_bytes();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.big_int_from_le_bytes)
  return _msg;
}

// .acvm.acir.circuit.BlackBoxFuncCall.BigIntToLeBytes big_int_to_le_bytes = 18;
inline bool BlackBoxFuncCall::has_big_int_to_le_bytes() const {
  return value_case() == kBigIntToLeBytes;
}
inline bool BlackBoxFuncCall::_internal_has_big_int_to_le_bytes() const {
  return value_case() == kBigIntToLeBytes;
}
inline void BlackBoxFuncCall::set_has_big_int_to_le_bytes() {
  _impl_._oneof_case_[0] = kBigIntToLeBytes;
}
inline void BlackBoxFuncCall::clear_big_int_to_le_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kBigIntToLeBytes) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.big_int_to_le_bytes_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.big_int_to_le_bytes_);
    }
    clear_has_value();
  }
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_BigIntToLeBytes* BlackBoxFuncCall::release_big_int_to_le_bytes() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BlackBoxFuncCall.big_int_to_le_bytes)
  if (value_case() == kBigIntToLeBytes) {
    clear_has_value();
    auto* temp = _impl_.value_.big_int_to_le_bytes_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.big_int_to_le_bytes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_BigIntToLeBytes& BlackBoxFuncCall::_internal_big_int_to_le_bytes() const {
  return value_case() == kBigIntToLeBytes ? *_impl_.value_.big_int_to_le_bytes_ : reinterpret_cast<::acvm::acir::circuit::BlackBoxFuncCall_BigIntToLeBytes&>(::acvm::acir::circuit::_BlackBoxFuncCall_BigIntToLeBytes_default_instance_);
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_BigIntToLeBytes& BlackBoxFuncCall::big_int_to_le_bytes() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.big_int_to_le_bytes)
  return _internal_big_int_to_le_bytes();
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_BigIntToLeBytes* BlackBoxFuncCall::unsafe_arena_release_big_int_to_le_bytes() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.BlackBoxFuncCall.big_int_to_le_bytes)
  if (value_case() == kBigIntToLeBytes) {
    clear_has_value();
    auto* temp = _impl_.value_.big_int_to_le_bytes_;
    _impl_.value_.big_int_to_le_bytes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlackBoxFuncCall::unsafe_arena_set_allocated_big_int_to_le_bytes(::acvm::acir::circuit::BlackBoxFuncCall_BigIntToLeBytes* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_big_int_to_le_bytes();
    _impl_.value_.big_int_to_le_bytes_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.big_int_to_le_bytes)
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_BigIntToLeBytes* BlackBoxFuncCall::_internal_mutable_big_int_to_le_bytes() {
  if (value_case() != kBigIntToLeBytes) {
    clear_value();
    set_has_big_int_to_le_bytes();
    _impl_.value_.big_int_to_le_bytes_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::BlackBoxFuncCall_BigIntToLeBytes>(GetArena());
  }
  return _impl_.value_.big_int_to_le_bytes_;
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_BigIntToLeBytes* BlackBoxFuncCall::mutable_big_int_to_le_bytes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::circuit::BlackBoxFuncCall_BigIntToLeBytes* _msg = _internal_mutable_big_int_to_le_bytes();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.big_int_to_le_bytes)
  return _msg;
}

// .acvm.acir.circuit.BlackBoxFuncCall.Poseidon2Permutation poseidon2_permutation = 19;
inline bool BlackBoxFuncCall::has_poseidon2_permutation() const {
  return value_case() == kPoseidon2Permutation;
}
inline bool BlackBoxFuncCall::_internal_has_poseidon2_permutation() const {
  return value_case() == kPoseidon2Permutation;
}
inline void BlackBoxFuncCall::set_has_poseidon2_permutation() {
  _impl_._oneof_case_[0] = kPoseidon2Permutation;
}
inline void BlackBoxFuncCall::clear_poseidon2_permutation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kPoseidon2Permutation) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.poseidon2_permutation_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.poseidon2_permutation_);
    }
    clear_has_value();
  }
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_Poseidon2Permutation* BlackBoxFuncCall::release_poseidon2_permutation() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BlackBoxFuncCall.poseidon2_permutation)
  if (value_case() == kPoseidon2Permutation) {
    clear_has_value();
    auto* temp = _impl_.value_.poseidon2_permutation_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.poseidon2_permutation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_Poseidon2Permutation& BlackBoxFuncCall::_internal_poseidon2_permutation() const {
  return value_case() == kPoseidon2Permutation ? *_impl_.value_.poseidon2_permutation_ : reinterpret_cast<::acvm::acir::circuit::BlackBoxFuncCall_Poseidon2Permutation&>(::acvm::acir::circuit::_BlackBoxFuncCall_Poseidon2Permutation_default_instance_);
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_Poseidon2Permutation& BlackBoxFuncCall::poseidon2_permutation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.poseidon2_permutation)
  return _internal_poseidon2_permutation();
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_Poseidon2Permutation* BlackBoxFuncCall::unsafe_arena_release_poseidon2_permutation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.BlackBoxFuncCall.poseidon2_permutation)
  if (value_case() == kPoseidon2Permutation) {
    clear_has_value();
    auto* temp = _impl_.value_.poseidon2_permutation_;
    _impl_.value_.poseidon2_permutation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlackBoxFuncCall::unsafe_arena_set_allocated_poseidon2_permutation(::acvm::acir::circuit::BlackBoxFuncCall_Poseidon2Permutation* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_poseidon2_permutation();
    _impl_.value_.poseidon2_permutation_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.poseidon2_permutation)
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_Poseidon2Permutation* BlackBoxFuncCall::_internal_mutable_poseidon2_permutation() {
  if (value_case() != kPoseidon2Permutation) {
    clear_value();
    set_has_poseidon2_permutation();
    _impl_.value_.poseidon2_permutation_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::BlackBoxFuncCall_Poseidon2Permutation>(GetArena());
  }
  return _impl_.value_.poseidon2_permutation_;
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_Poseidon2Permutation* BlackBoxFuncCall::mutable_poseidon2_permutation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::circuit::BlackBoxFuncCall_Poseidon2Permutation* _msg = _internal_mutable_poseidon2_permutation();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.poseidon2_permutation)
  return _msg;
}

// .acvm.acir.circuit.BlackBoxFuncCall.Sha256Compression sha256_compression = 20;
inline bool BlackBoxFuncCall::has_sha256_compression() const {
  return value_case() == kSha256Compression;
}
inline bool BlackBoxFuncCall::_internal_has_sha256_compression() const {
  return value_case() == kSha256Compression;
}
inline void BlackBoxFuncCall::set_has_sha256_compression() {
  _impl_._oneof_case_[0] = kSha256Compression;
}
inline void BlackBoxFuncCall::clear_sha256_compression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kSha256Compression) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.sha256_compression_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.sha256_compression_);
    }
    clear_has_value();
  }
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_Sha256Compression* BlackBoxFuncCall::release_sha256_compression() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BlackBoxFuncCall.sha256_compression)
  if (value_case() == kSha256Compression) {
    clear_has_value();
    auto* temp = _impl_.value_.sha256_compression_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.sha256_compression_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_Sha256Compression& BlackBoxFuncCall::_internal_sha256_compression() const {
  return value_case() == kSha256Compression ? *_impl_.value_.sha256_compression_ : reinterpret_cast<::acvm::acir::circuit::BlackBoxFuncCall_Sha256Compression&>(::acvm::acir::circuit::_BlackBoxFuncCall_Sha256Compression_default_instance_);
}
inline const ::acvm::acir::circuit::BlackBoxFuncCall_Sha256Compression& BlackBoxFuncCall::sha256_compression() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlackBoxFuncCall.sha256_compression)
  return _internal_sha256_compression();
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_Sha256Compression* BlackBoxFuncCall::unsafe_arena_release_sha256_compression() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.BlackBoxFuncCall.sha256_compression)
  if (value_case() == kSha256Compression) {
    clear_has_value();
    auto* temp = _impl_.value_.sha256_compression_;
    _impl_.value_.sha256_compression_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlackBoxFuncCall::unsafe_arena_set_allocated_sha256_compression(::acvm::acir::circuit::BlackBoxFuncCall_Sha256Compression* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_sha256_compression();
    _impl_.value_.sha256_compression_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BlackBoxFuncCall.sha256_compression)
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_Sha256Compression* BlackBoxFuncCall::_internal_mutable_sha256_compression() {
  if (value_case() != kSha256Compression) {
    clear_value();
    set_has_sha256_compression();
    _impl_.value_.sha256_compression_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::BlackBoxFuncCall_Sha256Compression>(GetArena());
  }
  return _impl_.value_.sha256_compression_;
}
inline ::acvm::acir::circuit::BlackBoxFuncCall_Sha256Compression* BlackBoxFuncCall::mutable_sha256_compression() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::circuit::BlackBoxFuncCall_Sha256Compression* _msg = _internal_mutable_sha256_compression();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlackBoxFuncCall.sha256_compression)
  return _msg;
}

inline bool BlackBoxFuncCall::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void BlackBoxFuncCall::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline BlackBoxFuncCall::ValueCase BlackBoxFuncCall::value_case() const {
  return BlackBoxFuncCall::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// FunctionInput

// .acvm.acir.circuit.ConstantOrWitnessEnum input = 1;
inline bool FunctionInput::has_input() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.input_ != nullptr);
  return value;
}
inline void FunctionInput::clear_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_ != nullptr) _impl_.input_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::acvm::acir::circuit::ConstantOrWitnessEnum& FunctionInput::_internal_input() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::acvm::acir::circuit::ConstantOrWitnessEnum* p = _impl_.input_;
  return p != nullptr ? *p : reinterpret_cast<const ::acvm::acir::circuit::ConstantOrWitnessEnum&>(::acvm::acir::circuit::_ConstantOrWitnessEnum_default_instance_);
}
inline const ::acvm::acir::circuit::ConstantOrWitnessEnum& FunctionInput::input() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.FunctionInput.input)
  return _internal_input();
}
inline void FunctionInput::unsafe_arena_set_allocated_input(::acvm::acir::circuit::ConstantOrWitnessEnum* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.input_);
  }
  _impl_.input_ = reinterpret_cast<::acvm::acir::circuit::ConstantOrWitnessEnum*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.FunctionInput.input)
}
inline ::acvm::acir::circuit::ConstantOrWitnessEnum* FunctionInput::release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::acvm::acir::circuit::ConstantOrWitnessEnum* released = _impl_.input_;
  _impl_.input_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::acvm::acir::circuit::ConstantOrWitnessEnum* FunctionInput::unsafe_arena_release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.FunctionInput.input)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::acvm::acir::circuit::ConstantOrWitnessEnum* temp = _impl_.input_;
  _impl_.input_ = nullptr;
  return temp;
}
inline ::acvm::acir::circuit::ConstantOrWitnessEnum* FunctionInput::_internal_mutable_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::ConstantOrWitnessEnum>(GetArena());
    _impl_.input_ = reinterpret_cast<::acvm::acir::circuit::ConstantOrWitnessEnum*>(p);
  }
  return _impl_.input_;
}
inline ::acvm::acir::circuit::ConstantOrWitnessEnum* FunctionInput::mutable_input() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::acvm::acir::circuit::ConstantOrWitnessEnum* _msg = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.FunctionInput.input)
  return _msg;
}
inline void FunctionInput::set_allocated_input(::acvm::acir::circuit::ConstantOrWitnessEnum* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.input_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.input_ = reinterpret_cast<::acvm::acir::circuit::ConstantOrWitnessEnum*>(value);
  // @@protoc_insertion_point(field_set_allocated:acvm.acir.circuit.FunctionInput.input)
}

// uint32 num_bits = 2;
inline void FunctionInput::clear_num_bits() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_bits_ = 0u;
}
inline ::uint32_t FunctionInput::num_bits() const {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.FunctionInput.num_bits)
  return _internal_num_bits();
}
inline void FunctionInput::set_num_bits(::uint32_t value) {
  _internal_set_num_bits(value);
  // @@protoc_insertion_point(field_set:acvm.acir.circuit.FunctionInput.num_bits)
}
inline ::uint32_t FunctionInput::_internal_num_bits() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.num_bits_;
}
inline void FunctionInput::_internal_set_num_bits(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_bits_ = value;
}

// -------------------------------------------------------------------

// ConstantOrWitnessEnum

// .acvm.acir.native.Field constant = 1;
inline bool ConstantOrWitnessEnum::has_constant() const {
  return value_case() == kConstant;
}
inline bool ConstantOrWitnessEnum::_internal_has_constant() const {
  return value_case() == kConstant;
}
inline void ConstantOrWitnessEnum::set_has_constant() {
  _impl_._oneof_case_[0] = kConstant;
}
inline ::acvm::acir::native::Field* ConstantOrWitnessEnum::release_constant() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.ConstantOrWitnessEnum.constant)
  if (value_case() == kConstant) {
    clear_has_value();
    auto* temp = _impl_.value_.constant_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.constant_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::native::Field& ConstantOrWitnessEnum::_internal_constant() const {
  return value_case() == kConstant ? *_impl_.value_.constant_ : reinterpret_cast<::acvm::acir::native::Field&>(::acvm::acir::native::_Field_default_instance_);
}
inline const ::acvm::acir::native::Field& ConstantOrWitnessEnum::constant() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.ConstantOrWitnessEnum.constant)
  return _internal_constant();
}
inline ::acvm::acir::native::Field* ConstantOrWitnessEnum::unsafe_arena_release_constant() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.ConstantOrWitnessEnum.constant)
  if (value_case() == kConstant) {
    clear_has_value();
    auto* temp = _impl_.value_.constant_;
    _impl_.value_.constant_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConstantOrWitnessEnum::unsafe_arena_set_allocated_constant(::acvm::acir::native::Field* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_constant();
    _impl_.value_.constant_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.ConstantOrWitnessEnum.constant)
}
inline ::acvm::acir::native::Field* ConstantOrWitnessEnum::_internal_mutable_constant() {
  if (value_case() != kConstant) {
    clear_value();
    set_has_constant();
    _impl_.value_.constant_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::native::Field>(GetArena());
  }
  return _impl_.value_.constant_;
}
inline ::acvm::acir::native::Field* ConstantOrWitnessEnum::mutable_constant() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::native::Field* _msg = _internal_mutable_constant();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.ConstantOrWitnessEnum.constant)
  return _msg;
}

// .acvm.acir.native.Witness witness = 2;
inline bool ConstantOrWitnessEnum::has_witness() const {
  return value_case() == kWitness;
}
inline bool ConstantOrWitnessEnum::_internal_has_witness() const {
  return value_case() == kWitness;
}
inline void ConstantOrWitnessEnum::set_has_witness() {
  _impl_._oneof_case_[0] = kWitness;
}
inline ::acvm::acir::native::Witness* ConstantOrWitnessEnum::release_witness() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.ConstantOrWitnessEnum.witness)
  if (value_case() == kWitness) {
    clear_has_value();
    auto* temp = _impl_.value_.witness_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.witness_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::native::Witness& ConstantOrWitnessEnum::_internal_witness() const {
  return value_case() == kWitness ? *_impl_.value_.witness_ : reinterpret_cast<::acvm::acir::native::Witness&>(::acvm::acir::native::_Witness_default_instance_);
}
inline const ::acvm::acir::native::Witness& ConstantOrWitnessEnum::witness() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.ConstantOrWitnessEnum.witness)
  return _internal_witness();
}
inline ::acvm::acir::native::Witness* ConstantOrWitnessEnum::unsafe_arena_release_witness() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.ConstantOrWitnessEnum.witness)
  if (value_case() == kWitness) {
    clear_has_value();
    auto* temp = _impl_.value_.witness_;
    _impl_.value_.witness_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConstantOrWitnessEnum::unsafe_arena_set_allocated_witness(::acvm::acir::native::Witness* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_witness();
    _impl_.value_.witness_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.ConstantOrWitnessEnum.witness)
}
inline ::acvm::acir::native::Witness* ConstantOrWitnessEnum::_internal_mutable_witness() {
  if (value_case() != kWitness) {
    clear_value();
    set_has_witness();
    _impl_.value_.witness_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::native::Witness>(GetArena());
  }
  return _impl_.value_.witness_;
}
inline ::acvm::acir::native::Witness* ConstantOrWitnessEnum::mutable_witness() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::native::Witness* _msg = _internal_mutable_witness();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.ConstantOrWitnessEnum.witness)
  return _msg;
}

inline bool ConstantOrWitnessEnum::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void ConstantOrWitnessEnum::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline ConstantOrWitnessEnum::ValueCase ConstantOrWitnessEnum::value_case() const {
  return ConstantOrWitnessEnum::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// MemOp

// .acvm.acir.native.Expression operation = 1;
inline bool MemOp::has_operation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.operation_ != nullptr);
  return value;
}
inline const ::acvm::acir::native::Expression& MemOp::_internal_operation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::acvm::acir::native::Expression* p = _impl_.operation_;
  return p != nullptr ? *p : reinterpret_cast<const ::acvm::acir::native::Expression&>(::acvm::acir::native::_Expression_default_instance_);
}
inline const ::acvm::acir::native::Expression& MemOp::operation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.MemOp.operation)
  return _internal_operation();
}
inline void MemOp::unsafe_arena_set_allocated_operation(::acvm::acir::native::Expression* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.operation_);
  }
  _impl_.operation_ = reinterpret_cast<::acvm::acir::native::Expression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.MemOp.operation)
}
inline ::acvm::acir::native::Expression* MemOp::release_operation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::acvm::acir::native::Expression* released = _impl_.operation_;
  _impl_.operation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::acvm::acir::native::Expression* MemOp::unsafe_arena_release_operation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.MemOp.operation)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::acvm::acir::native::Expression* temp = _impl_.operation_;
  _impl_.operation_ = nullptr;
  return temp;
}
inline ::acvm::acir::native::Expression* MemOp::_internal_mutable_operation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.operation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::acvm::acir::native::Expression>(GetArena());
    _impl_.operation_ = reinterpret_cast<::acvm::acir::native::Expression*>(p);
  }
  return _impl_.operation_;
}
inline ::acvm::acir::native::Expression* MemOp::mutable_operation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::acvm::acir::native::Expression* _msg = _internal_mutable_operation();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.MemOp.operation)
  return _msg;
}
inline void MemOp::set_allocated_operation(::acvm::acir::native::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.operation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.operation_ = reinterpret_cast<::acvm::acir::native::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:acvm.acir.circuit.MemOp.operation)
}

// .acvm.acir.native.Expression index = 2;
inline bool MemOp::has_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.index_ != nullptr);
  return value;
}
inline const ::acvm::acir::native::Expression& MemOp::_internal_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::acvm::acir::native::Expression* p = _impl_.index_;
  return p != nullptr ? *p : reinterpret_cast<const ::acvm::acir::native::Expression&>(::acvm::acir::native::_Expression_default_instance_);
}
inline const ::acvm::acir::native::Expression& MemOp::index() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.MemOp.index)
  return _internal_index();
}
inline void MemOp::unsafe_arena_set_allocated_index(::acvm::acir::native::Expression* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.index_);
  }
  _impl_.index_ = reinterpret_cast<::acvm::acir::native::Expression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.MemOp.index)
}
inline ::acvm::acir::native::Expression* MemOp::release_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::acvm::acir::native::Expression* released = _impl_.index_;
  _impl_.index_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::acvm::acir::native::Expression* MemOp::unsafe_arena_release_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.MemOp.index)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::acvm::acir::native::Expression* temp = _impl_.index_;
  _impl_.index_ = nullptr;
  return temp;
}
inline ::acvm::acir::native::Expression* MemOp::_internal_mutable_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.index_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::acvm::acir::native::Expression>(GetArena());
    _impl_.index_ = reinterpret_cast<::acvm::acir::native::Expression*>(p);
  }
  return _impl_.index_;
}
inline ::acvm::acir::native::Expression* MemOp::mutable_index() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::acvm::acir::native::Expression* _msg = _internal_mutable_index();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.MemOp.index)
  return _msg;
}
inline void MemOp::set_allocated_index(::acvm::acir::native::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.index_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.index_ = reinterpret_cast<::acvm::acir::native::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:acvm.acir.circuit.MemOp.index)
}

// .acvm.acir.native.Expression value = 3;
inline bool MemOp::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.value_ != nullptr);
  return value;
}
inline const ::acvm::acir::native::Expression& MemOp::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::acvm::acir::native::Expression* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::acvm::acir::native::Expression&>(::acvm::acir::native::_Expression_default_instance_);
}
inline const ::acvm::acir::native::Expression& MemOp::value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.MemOp.value)
  return _internal_value();
}
inline void MemOp::unsafe_arena_set_allocated_value(::acvm::acir::native::Expression* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = reinterpret_cast<::acvm::acir::native::Expression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.MemOp.value)
}
inline ::acvm::acir::native::Expression* MemOp::release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::acvm::acir::native::Expression* released = _impl_.value_;
  _impl_.value_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::acvm::acir::native::Expression* MemOp::unsafe_arena_release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.MemOp.value)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::acvm::acir::native::Expression* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::acvm::acir::native::Expression* MemOp::_internal_mutable_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.value_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::acvm::acir::native::Expression>(GetArena());
    _impl_.value_ = reinterpret_cast<::acvm::acir::native::Expression*>(p);
  }
  return _impl_.value_;
}
inline ::acvm::acir::native::Expression* MemOp::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::acvm::acir::native::Expression* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.MemOp.value)
  return _msg;
}
inline void MemOp::set_allocated_value(::acvm::acir::native::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.value_ = reinterpret_cast<::acvm::acir::native::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:acvm.acir.circuit.MemOp.value)
}

// -------------------------------------------------------------------

// BlockType_Memory

// -------------------------------------------------------------------

// BlockType_CallData

// uint32 value = 1;
inline void BlockType_CallData::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = 0u;
}
inline ::uint32_t BlockType_CallData::value() const {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlockType.CallData.value)
  return _internal_value();
}
inline void BlockType_CallData::set_value(::uint32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:acvm.acir.circuit.BlockType.CallData.value)
}
inline ::uint32_t BlockType_CallData::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline void BlockType_CallData::_internal_set_value(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// BlockType_ReturnData

// -------------------------------------------------------------------

// BlockType

// .acvm.acir.circuit.BlockType.Memory memory = 1;
inline bool BlockType::has_memory() const {
  return value_case() == kMemory;
}
inline bool BlockType::_internal_has_memory() const {
  return value_case() == kMemory;
}
inline void BlockType::set_has_memory() {
  _impl_._oneof_case_[0] = kMemory;
}
inline void BlockType::clear_memory() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kMemory) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.memory_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.memory_);
    }
    clear_has_value();
  }
}
inline ::acvm::acir::circuit::BlockType_Memory* BlockType::release_memory() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BlockType.memory)
  if (value_case() == kMemory) {
    clear_has_value();
    auto* temp = _impl_.value_.memory_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.memory_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::circuit::BlockType_Memory& BlockType::_internal_memory() const {
  return value_case() == kMemory ? *_impl_.value_.memory_ : reinterpret_cast<::acvm::acir::circuit::BlockType_Memory&>(::acvm::acir::circuit::_BlockType_Memory_default_instance_);
}
inline const ::acvm::acir::circuit::BlockType_Memory& BlockType::memory() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlockType.memory)
  return _internal_memory();
}
inline ::acvm::acir::circuit::BlockType_Memory* BlockType::unsafe_arena_release_memory() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.BlockType.memory)
  if (value_case() == kMemory) {
    clear_has_value();
    auto* temp = _impl_.value_.memory_;
    _impl_.value_.memory_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlockType::unsafe_arena_set_allocated_memory(::acvm::acir::circuit::BlockType_Memory* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_memory();
    _impl_.value_.memory_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BlockType.memory)
}
inline ::acvm::acir::circuit::BlockType_Memory* BlockType::_internal_mutable_memory() {
  if (value_case() != kMemory) {
    clear_value();
    set_has_memory();
    _impl_.value_.memory_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::BlockType_Memory>(GetArena());
  }
  return _impl_.value_.memory_;
}
inline ::acvm::acir::circuit::BlockType_Memory* BlockType::mutable_memory() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::circuit::BlockType_Memory* _msg = _internal_mutable_memory();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlockType.memory)
  return _msg;
}

// .acvm.acir.circuit.BlockType.CallData call_data = 2;
inline bool BlockType::has_call_data() const {
  return value_case() == kCallData;
}
inline bool BlockType::_internal_has_call_data() const {
  return value_case() == kCallData;
}
inline void BlockType::set_has_call_data() {
  _impl_._oneof_case_[0] = kCallData;
}
inline void BlockType::clear_call_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kCallData) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.call_data_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.call_data_);
    }
    clear_has_value();
  }
}
inline ::acvm::acir::circuit::BlockType_CallData* BlockType::release_call_data() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BlockType.call_data)
  if (value_case() == kCallData) {
    clear_has_value();
    auto* temp = _impl_.value_.call_data_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.call_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::circuit::BlockType_CallData& BlockType::_internal_call_data() const {
  return value_case() == kCallData ? *_impl_.value_.call_data_ : reinterpret_cast<::acvm::acir::circuit::BlockType_CallData&>(::acvm::acir::circuit::_BlockType_CallData_default_instance_);
}
inline const ::acvm::acir::circuit::BlockType_CallData& BlockType::call_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlockType.call_data)
  return _internal_call_data();
}
inline ::acvm::acir::circuit::BlockType_CallData* BlockType::unsafe_arena_release_call_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.BlockType.call_data)
  if (value_case() == kCallData) {
    clear_has_value();
    auto* temp = _impl_.value_.call_data_;
    _impl_.value_.call_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlockType::unsafe_arena_set_allocated_call_data(::acvm::acir::circuit::BlockType_CallData* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_call_data();
    _impl_.value_.call_data_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BlockType.call_data)
}
inline ::acvm::acir::circuit::BlockType_CallData* BlockType::_internal_mutable_call_data() {
  if (value_case() != kCallData) {
    clear_value();
    set_has_call_data();
    _impl_.value_.call_data_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::BlockType_CallData>(GetArena());
  }
  return _impl_.value_.call_data_;
}
inline ::acvm::acir::circuit::BlockType_CallData* BlockType::mutable_call_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::circuit::BlockType_CallData* _msg = _internal_mutable_call_data();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlockType.call_data)
  return _msg;
}

// .acvm.acir.circuit.BlockType.ReturnData return_data = 3;
inline bool BlockType::has_return_data() const {
  return value_case() == kReturnData;
}
inline bool BlockType::_internal_has_return_data() const {
  return value_case() == kReturnData;
}
inline void BlockType::set_has_return_data() {
  _impl_._oneof_case_[0] = kReturnData;
}
inline void BlockType::clear_return_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kReturnData) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.return_data_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.return_data_);
    }
    clear_has_value();
  }
}
inline ::acvm::acir::circuit::BlockType_ReturnData* BlockType::release_return_data() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BlockType.return_data)
  if (value_case() == kReturnData) {
    clear_has_value();
    auto* temp = _impl_.value_.return_data_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.return_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::circuit::BlockType_ReturnData& BlockType::_internal_return_data() const {
  return value_case() == kReturnData ? *_impl_.value_.return_data_ : reinterpret_cast<::acvm::acir::circuit::BlockType_ReturnData&>(::acvm::acir::circuit::_BlockType_ReturnData_default_instance_);
}
inline const ::acvm::acir::circuit::BlockType_ReturnData& BlockType::return_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BlockType.return_data)
  return _internal_return_data();
}
inline ::acvm::acir::circuit::BlockType_ReturnData* BlockType::unsafe_arena_release_return_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.BlockType.return_data)
  if (value_case() == kReturnData) {
    clear_has_value();
    auto* temp = _impl_.value_.return_data_;
    _impl_.value_.return_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlockType::unsafe_arena_set_allocated_return_data(::acvm::acir::circuit::BlockType_ReturnData* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_return_data();
    _impl_.value_.return_data_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BlockType.return_data)
}
inline ::acvm::acir::circuit::BlockType_ReturnData* BlockType::_internal_mutable_return_data() {
  if (value_case() != kReturnData) {
    clear_value();
    set_has_return_data();
    _impl_.value_.return_data_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::BlockType_ReturnData>(GetArena());
  }
  return _impl_.value_.return_data_;
}
inline ::acvm::acir::circuit::BlockType_ReturnData* BlockType::mutable_return_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::circuit::BlockType_ReturnData* _msg = _internal_mutable_return_data();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BlockType.return_data)
  return _msg;
}

inline bool BlockType::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void BlockType::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline BlockType::ValueCase BlockType::value_case() const {
  return BlockType::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// BrilligInputs_Array

// repeated .acvm.acir.native.Expression values = 2;
inline int BrilligInputs_Array::_internal_values_size() const {
  return _internal_values().size();
}
inline int BrilligInputs_Array::values_size() const {
  return _internal_values_size();
}
inline ::acvm::acir::native::Expression* BrilligInputs_Array::mutable_values(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BrilligInputs.Array.values)
  return _internal_mutable_values()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Expression>* BrilligInputs_Array::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BrilligInputs.Array.values)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_values();
}
inline const ::acvm::acir::native::Expression& BrilligInputs_Array::values(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BrilligInputs.Array.values)
  return _internal_values().Get(index);
}
inline ::acvm::acir::native::Expression* BrilligInputs_Array::add_values() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::native::Expression* _add = _internal_mutable_values()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BrilligInputs.Array.values)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Expression>& BrilligInputs_Array::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BrilligInputs.Array.values)
  return _internal_values();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Expression>&
BrilligInputs_Array::_internal_values() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Expression>*
BrilligInputs_Array::_internal_mutable_values() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// BrilligInputs

// .acvm.acir.native.Expression single = 1;
inline bool BrilligInputs::has_single() const {
  return value_case() == kSingle;
}
inline bool BrilligInputs::_internal_has_single() const {
  return value_case() == kSingle;
}
inline void BrilligInputs::set_has_single() {
  _impl_._oneof_case_[0] = kSingle;
}
inline ::acvm::acir::native::Expression* BrilligInputs::release_single() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BrilligInputs.single)
  if (value_case() == kSingle) {
    clear_has_value();
    auto* temp = _impl_.value_.single_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.single_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::native::Expression& BrilligInputs::_internal_single() const {
  return value_case() == kSingle ? *_impl_.value_.single_ : reinterpret_cast<::acvm::acir::native::Expression&>(::acvm::acir::native::_Expression_default_instance_);
}
inline const ::acvm::acir::native::Expression& BrilligInputs::single() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BrilligInputs.single)
  return _internal_single();
}
inline ::acvm::acir::native::Expression* BrilligInputs::unsafe_arena_release_single() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.BrilligInputs.single)
  if (value_case() == kSingle) {
    clear_has_value();
    auto* temp = _impl_.value_.single_;
    _impl_.value_.single_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BrilligInputs::unsafe_arena_set_allocated_single(::acvm::acir::native::Expression* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_single();
    _impl_.value_.single_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BrilligInputs.single)
}
inline ::acvm::acir::native::Expression* BrilligInputs::_internal_mutable_single() {
  if (value_case() != kSingle) {
    clear_value();
    set_has_single();
    _impl_.value_.single_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::native::Expression>(GetArena());
  }
  return _impl_.value_.single_;
}
inline ::acvm::acir::native::Expression* BrilligInputs::mutable_single() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::native::Expression* _msg = _internal_mutable_single();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BrilligInputs.single)
  return _msg;
}

// .acvm.acir.circuit.BrilligInputs.Array array = 2;
inline bool BrilligInputs::has_array() const {
  return value_case() == kArray;
}
inline bool BrilligInputs::_internal_has_array() const {
  return value_case() == kArray;
}
inline void BrilligInputs::set_has_array() {
  _impl_._oneof_case_[0] = kArray;
}
inline void BrilligInputs::clear_array() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kArray) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.array_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.array_);
    }
    clear_has_value();
  }
}
inline ::acvm::acir::circuit::BrilligInputs_Array* BrilligInputs::release_array() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BrilligInputs.array)
  if (value_case() == kArray) {
    clear_has_value();
    auto* temp = _impl_.value_.array_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::circuit::BrilligInputs_Array& BrilligInputs::_internal_array() const {
  return value_case() == kArray ? *_impl_.value_.array_ : reinterpret_cast<::acvm::acir::circuit::BrilligInputs_Array&>(::acvm::acir::circuit::_BrilligInputs_Array_default_instance_);
}
inline const ::acvm::acir::circuit::BrilligInputs_Array& BrilligInputs::array() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BrilligInputs.array)
  return _internal_array();
}
inline ::acvm::acir::circuit::BrilligInputs_Array* BrilligInputs::unsafe_arena_release_array() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.BrilligInputs.array)
  if (value_case() == kArray) {
    clear_has_value();
    auto* temp = _impl_.value_.array_;
    _impl_.value_.array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BrilligInputs::unsafe_arena_set_allocated_array(::acvm::acir::circuit::BrilligInputs_Array* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_array();
    _impl_.value_.array_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BrilligInputs.array)
}
inline ::acvm::acir::circuit::BrilligInputs_Array* BrilligInputs::_internal_mutable_array() {
  if (value_case() != kArray) {
    clear_value();
    set_has_array();
    _impl_.value_.array_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::BrilligInputs_Array>(GetArena());
  }
  return _impl_.value_.array_;
}
inline ::acvm::acir::circuit::BrilligInputs_Array* BrilligInputs::mutable_array() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::circuit::BrilligInputs_Array* _msg = _internal_mutable_array();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BrilligInputs.array)
  return _msg;
}

// uint32 memory_array = 3;
inline bool BrilligInputs::has_memory_array() const {
  return value_case() == kMemoryArray;
}
inline void BrilligInputs::set_has_memory_array() {
  _impl_._oneof_case_[0] = kMemoryArray;
}
inline void BrilligInputs::clear_memory_array() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kMemoryArray) {
    _impl_.value_.memory_array_ = 0u;
    clear_has_value();
  }
}
inline ::uint32_t BrilligInputs::memory_array() const {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BrilligInputs.memory_array)
  return _internal_memory_array();
}
inline void BrilligInputs::set_memory_array(::uint32_t value) {
  if (value_case() != kMemoryArray) {
    clear_value();
    set_has_memory_array();
  }
  _impl_.value_.memory_array_ = value;
  // @@protoc_insertion_point(field_set:acvm.acir.circuit.BrilligInputs.memory_array)
}
inline ::uint32_t BrilligInputs::_internal_memory_array() const {
  if (value_case() == kMemoryArray) {
    return _impl_.value_.memory_array_;
  }
  return 0u;
}

inline bool BrilligInputs::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void BrilligInputs::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline BrilligInputs::ValueCase BrilligInputs::value_case() const {
  return BrilligInputs::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// BrilligOutputs_Array

// repeated .acvm.acir.native.Witness values = 1;
inline int BrilligOutputs_Array::_internal_values_size() const {
  return _internal_values().size();
}
inline int BrilligOutputs_Array::values_size() const {
  return _internal_values_size();
}
inline ::acvm::acir::native::Witness* BrilligOutputs_Array::mutable_values(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BrilligOutputs.Array.values)
  return _internal_mutable_values()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>* BrilligOutputs_Array::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:acvm.acir.circuit.BrilligOutputs.Array.values)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_values();
}
inline const ::acvm::acir::native::Witness& BrilligOutputs_Array::values(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BrilligOutputs.Array.values)
  return _internal_values().Get(index);
}
inline ::acvm::acir::native::Witness* BrilligOutputs_Array::add_values() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::acvm::acir::native::Witness* _add = _internal_mutable_values()->Add();
  // @@protoc_insertion_point(field_add:acvm.acir.circuit.BrilligOutputs.Array.values)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>& BrilligOutputs_Array::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:acvm.acir.circuit.BrilligOutputs.Array.values)
  return _internal_values();
}
inline const ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>&
BrilligOutputs_Array::_internal_values() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedPtrField<::acvm::acir::native::Witness>*
BrilligOutputs_Array::_internal_mutable_values() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// BrilligOutputs

// .acvm.acir.native.Witness simple = 1;
inline bool BrilligOutputs::has_simple() const {
  return value_case() == kSimple;
}
inline bool BrilligOutputs::_internal_has_simple() const {
  return value_case() == kSimple;
}
inline void BrilligOutputs::set_has_simple() {
  _impl_._oneof_case_[0] = kSimple;
}
inline ::acvm::acir::native::Witness* BrilligOutputs::release_simple() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BrilligOutputs.simple)
  if (value_case() == kSimple) {
    clear_has_value();
    auto* temp = _impl_.value_.simple_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.simple_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::native::Witness& BrilligOutputs::_internal_simple() const {
  return value_case() == kSimple ? *_impl_.value_.simple_ : reinterpret_cast<::acvm::acir::native::Witness&>(::acvm::acir::native::_Witness_default_instance_);
}
inline const ::acvm::acir::native::Witness& BrilligOutputs::simple() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BrilligOutputs.simple)
  return _internal_simple();
}
inline ::acvm::acir::native::Witness* BrilligOutputs::unsafe_arena_release_simple() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.BrilligOutputs.simple)
  if (value_case() == kSimple) {
    clear_has_value();
    auto* temp = _impl_.value_.simple_;
    _impl_.value_.simple_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BrilligOutputs::unsafe_arena_set_allocated_simple(::acvm::acir::native::Witness* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_simple();
    _impl_.value_.simple_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BrilligOutputs.simple)
}
inline ::acvm::acir::native::Witness* BrilligOutputs::_internal_mutable_simple() {
  if (value_case() != kSimple) {
    clear_value();
    set_has_simple();
    _impl_.value_.simple_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::native::Witness>(GetArena());
  }
  return _impl_.value_.simple_;
}
inline ::acvm::acir::native::Witness* BrilligOutputs::mutable_simple() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::native::Witness* _msg = _internal_mutable_simple();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BrilligOutputs.simple)
  return _msg;
}

// .acvm.acir.circuit.BrilligOutputs.Array array = 2;
inline bool BrilligOutputs::has_array() const {
  return value_case() == kArray;
}
inline bool BrilligOutputs::_internal_has_array() const {
  return value_case() == kArray;
}
inline void BrilligOutputs::set_has_array() {
  _impl_._oneof_case_[0] = kArray;
}
inline void BrilligOutputs::clear_array() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kArray) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.array_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.array_);
    }
    clear_has_value();
  }
}
inline ::acvm::acir::circuit::BrilligOutputs_Array* BrilligOutputs::release_array() {
  // @@protoc_insertion_point(field_release:acvm.acir.circuit.BrilligOutputs.array)
  if (value_case() == kArray) {
    clear_has_value();
    auto* temp = _impl_.value_.array_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::acvm::acir::circuit::BrilligOutputs_Array& BrilligOutputs::_internal_array() const {
  return value_case() == kArray ? *_impl_.value_.array_ : reinterpret_cast<::acvm::acir::circuit::BrilligOutputs_Array&>(::acvm::acir::circuit::_BrilligOutputs_Array_default_instance_);
}
inline const ::acvm::acir::circuit::BrilligOutputs_Array& BrilligOutputs::array() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:acvm.acir.circuit.BrilligOutputs.array)
  return _internal_array();
}
inline ::acvm::acir::circuit::BrilligOutputs_Array* BrilligOutputs::unsafe_arena_release_array() {
  // @@protoc_insertion_point(field_unsafe_arena_release:acvm.acir.circuit.BrilligOutputs.array)
  if (value_case() == kArray) {
    clear_has_value();
    auto* temp = _impl_.value_.array_;
    _impl_.value_.array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BrilligOutputs::unsafe_arena_set_allocated_array(::acvm::acir::circuit::BrilligOutputs_Array* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_array();
    _impl_.value_.array_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:acvm.acir.circuit.BrilligOutputs.array)
}
inline ::acvm::acir::circuit::BrilligOutputs_Array* BrilligOutputs::_internal_mutable_array() {
  if (value_case() != kArray) {
    clear_value();
    set_has_array();
    _impl_.value_.array_ =
        ::google::protobuf::Message::DefaultConstruct<::acvm::acir::circuit::BrilligOutputs_Array>(GetArena());
  }
  return _impl_.value_.array_;
}
inline ::acvm::acir::circuit::BrilligOutputs_Array* BrilligOutputs::mutable_array() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::acvm::acir::circuit::BrilligOutputs_Array* _msg = _internal_mutable_array();
  // @@protoc_insertion_point(field_mutable:acvm.acir.circuit.BrilligOutputs.array)
  return _msg;
}

inline bool BrilligOutputs::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void BrilligOutputs::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline BrilligOutputs::ValueCase BrilligOutputs::value_case() const {
  return BrilligOutputs::ValueCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace circuit
}  // namespace acir
}  // namespace acvm


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // acir_2fcircuit_2eproto_2epb_2eh
