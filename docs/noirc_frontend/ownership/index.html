<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This module implements the “ownership analysis” compiler pass on the monomorphized AST. It is run after monomorphization and before SSA-gen. At this point the monomorphized AST has no polymorphic types and all functions are specialized into either constrained or unconstrained versions. This pass only operates on unconstrained functions since only Noir’s unconstrained runtime Brillig has any notion of cloning a value - specifically arrays with their brillig-only reference counts."><title>noirc_frontend::ownership - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="noirc_frontend" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../noirc_frontend/index.html">noirc_<wbr>frontend</a><span class="version">1.0.0-beta.3</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module ownership</a></h2><h3><a href="#functions">Module Items</a></h3><ul class="block"><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate noirc_<wbr>frontend</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">noirc_frontend</a></span><h1>Module <span>ownership</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/noirc_frontend/ownership/mod.rs.html#1-498">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This module implements the “ownership analysis” compiler pass on the
monomorphized AST. It is run after monomorphization and before SSA-gen.
At this point the monomorphized AST has no polymorphic types and all functions
are specialized into either constrained or unconstrained versions. This pass
only operates on unconstrained functions since only Noir’s unconstrained runtime Brillig
has any notion of cloning a value - specifically arrays with their brillig-only reference counts.</p>
<p>Note that this documentation may refer to cloning a value or incrementing an array’s reference
count. These operations are equivalent on arrays. Cloning may be applied to any value and only
increments the reference counts of any arrays contained within (but not behind references or
inside nested arrays). This document also focuses on arrays but all reference count operations
on arrays are also performed on slices.</p>
<p>Arrays in brillig have copy on write semantics which relies on us incrementing their
reference counts when they are shared in multiple places. Note that while Noir has references,
arrays can also be shared by value and we want to avoid clones when possible. This pass
clones arrays (increments their reference counts) in the following situations:</p>
<ul>
<li>Function parameters:
<ul>
<li>Any arrays behind a mutable reference <code>&amp;mut [T; N]</code> will have their reference count
incremented iff there was already a prior array of the same type passed into the same
function. E.g. if there are two parameters of type <code>&amp;mut [Field; 3]</code> we increment only
the later. If there are 3 we increment the last two.
<ul>
<li>This applies within struct &amp; tuple types as well. If a function only takes 1 struct
parameter but that struct contains 2 or more mutable references to the same array
type, we increment the reference count of each instance of the type after the first.</li>
<li>In the case of references to nested arrays, only the outer array has its reference count incremented.</li>
</ul>
</li>
<li>Arrays taken by mutable value are always cloned, e.g. in <code>mut x: [u32; 3]</code>, <code>x</code> will
have its reference count incremented.</li>
</ul>
</li>
<li>Let bindings (<code>let _ = &lt;expression which returns an array&gt;;</code>):
<ul>
<li>Binding an array to a let binding increments the reference count of the array unless
the expression is an array literal in which case it is considered to be moved.</li>
</ul>
</li>
<li>Assignments (<code>x = &lt;expression which returns an array&gt;;</code>):
<ul>
<li>Similarly, assigning an array to an existing variable will also increment the reference
count of the array unless it is an array literal.</li>
</ul>
</li>
<li>Array literals:
<ul>
<li>Arrays stored inside a nested array literal (e.g. both variables in <code>[array1, array2]</code>
have their reference count incremented).</li>
<li>This does not apply to nested array literals since we know they are not referenced elsewhere.</li>
</ul>
</li>
<li>Extracting an array from another array (<code>let inner: [_; _] = array[0];</code>):
<ul>
<li>Extracting a nested array from its outer array will always increment the reference count
of the nested array.</li>
</ul>
</li>
</ul>
<p>Additionally we currently only decrement reference counts at the end of the function when
a parameter goes out of scope. These means reference counts likely trend upward over time
until the array is eventually mutated and it is reset back to 1.</p>
</div></details><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.clone_expr.html" title="fn noirc_frontend::ownership::clone_expr">clone_<wbr>expr</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Adds a <code>.clone()</code> to the given expression.
Note that this method should be careful not to actually duplicate the given expression
so that we do not duplicate any side-effects.</div></li><li><div class="item-name"><a class="fn" href="fn.collect_parameters_to_clone.html" title="fn noirc_frontend::ownership::collect_parameters_to_clone">collect_<wbr>parameters_<wbr>to_<wbr>clone</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Returns a vector of new parameters to prepend clones to a function - if any.
Note that these may be full expressions e.g. <code>*param.field</code> so they should
be stored in a let binding before being cloned to ensure that a later drop
would be to the same value.</div></li><li><div class="item-name"><a class="fn" href="fn.contains_array_or_str_type.html" title="fn noirc_frontend::ownership::contains_array_or_str_type">contains_<wbr>array_<wbr>or_<wbr>str_<wbr>type</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="fn" href="fn.create_let_bindings.html" title="fn noirc_frontend::ownership::create_let_bindings">create_<wbr>let_<wbr>bindings</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="fn" href="fn.handle_assign.html" title="fn noirc_frontend::ownership::handle_assign">handle_<wbr>assign</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Assignments (<code>x = &lt;expression which returns an array&gt;;</code>):Assigning an array to an existing variable will also increment the reference
count of the array unless it is an array literal.</div></li><li><div class="item-name"><a class="fn" href="fn.handle_binary.html" title="fn noirc_frontend::ownership::handle_binary">handle_<wbr>binary</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="fn" href="fn.handle_call.html" title="fn noirc_frontend::ownership::handle_call">handle_<wbr>call</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="fn" href="fn.handle_cast.html" title="fn noirc_frontend::ownership::handle_cast">handle_<wbr>cast</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="fn" href="fn.handle_constrain.html" title="fn noirc_frontend::ownership::handle_constrain">handle_<wbr>constrain</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="fn" href="fn.handle_expression.html" title="fn noirc_frontend::ownership::handle_expression">handle_<wbr>expression</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="fn" href="fn.handle_for.html" title="fn noirc_frontend::ownership::handle_for">handle_<wbr>for</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="fn" href="fn.handle_if.html" title="fn noirc_frontend::ownership::handle_if">handle_<wbr>if</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="fn" href="fn.handle_index.html" title="fn noirc_frontend::ownership::handle_index">handle_<wbr>index</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Extracting an array from another array (<code>let inner: [_; _] = array[0];</code>):Extracting a nested array from its outer array will always increment the reference count
of the nested array.</div></li><li><div class="item-name"><a class="fn" href="fn.handle_let.html" title="fn noirc_frontend::ownership::handle_let">handle_<wbr>let</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Let bindings (<code>let _ = &lt;expression which returns an array&gt;;</code>):Binding an array to a let binding increments the reference count of the array unless
the expression is an array literal in which case it is considered to be moved.</div></li><li><div class="item-name"><a class="fn" href="fn.handle_literal.html" title="fn noirc_frontend::ownership::handle_literal">handle_<wbr>literal</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Array literals:Arrays stored inside a nested array literal (e.g. both variables in <code>[array1, array2]</code>
have their reference count incremented).This does not apply to nested array literals since we know they are not referenced elsewhere.</div></li><li><div class="item-name"><a class="fn" href="fn.handle_lvalue.html" title="fn noirc_frontend::ownership::handle_lvalue">handle_<wbr>lvalue</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="fn" href="fn.handle_match.html" title="fn noirc_frontend::ownership::handle_match">handle_<wbr>match</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="fn" href="fn.handle_ownership_in_function.html" title="fn noirc_frontend::ownership::handle_ownership_in_function">handle_<wbr>ownership_<wbr>in_<wbr>function</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="fn" href="fn.handle_tuple.html" title="fn noirc_frontend::ownership::handle_tuple">handle_<wbr>tuple</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="fn" href="fn.handle_unary.html" title="fn noirc_frontend::ownership::handle_unary">handle_<wbr>unary</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="fn" href="fn.handle_while.html" title="fn noirc_frontend::ownership::handle_while">handle_<wbr>while</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="fn" href="fn.is_array_or_str_literal.html" title="fn noirc_frontend::ownership::is_array_or_str_literal">is_<wbr>array_<wbr>or_<wbr>str_<wbr>literal</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="fn" href="fn.next_local_id.html" title="fn noirc_frontend::ownership::next_local_id">next_<wbr>local_<wbr>id</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="fn" href="fn.recur_on_parameter.html" title="fn noirc_frontend::ownership::recur_on_parameter">recur_<wbr>on_<wbr>parameter</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Recur on a parameter’s type, digging into any struct fields, looking for references to arrays.
This will build up an Expression of the current parameter access we’re doing, e.g. <code>*foo.bar</code>
would correspond to a parameter <code>foo</code> with struct field <code>bar</code> that is a reference to an array.</div></li></ul></section></div></main></body></html>