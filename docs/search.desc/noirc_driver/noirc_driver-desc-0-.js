searchState.loadedDescShard("noirc_driver", 0, "Helper type for connecting a compilation artifact to the …\nEach function in the contract will be compiled as a …\nDefault expression width used for Noir compilation. The …\nFor a given file, we store the source code and the path to …\nContains the error value\nHelper type used to signify where errors or warnings are …\nVersion string that gets placed in artifacts that Noir …\nContains the success value\nThe special case of running the compiler against the …\nHelper type used to signify where only warnings are …\nAdds a edge in the crate graph for two crates\nPretty print benchmark times of each code generation pass\nGenerate ACIR with the target backend expression width. …\nNames of the unconstrained functions in the program.\nNames of the unconstrained functions in the program.\nRun the lexing, parsing, name resolution, and type …\nUsed internally to test for non-determinism in the …\nRun the frontend to check the crate for errors then …\nRun the frontend to check the crate for errors then …\nCompile the current crate using <code>main_function</code> as the …\nEnable printing results of comptime evaluation: provide a …\nTreat all warnings as errors\nEmit the unoptimized SSA IR to file. The IR will be dumped …\nFlag to turn on the lookback feature of the Brillig call …\nFlag to turn on extra Brillig bytecode to be generated to …\nSpecify the backend expression width that should be …\nHelper method to return a file manager instance with the …\nForce Brillig output (for step debugging)\nForce a full recompilation.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nEach of the contract’s functions are compiled into a …\nHash of the <code>Program</code> from which this <code>CompiledProgram</code> was …\nSetting to decide on an inlining strategy for Brillig …\nInsert debug symbols to inspect variables\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSetting the maximum acceptable increase in Brillig …\nThe name of the contract.\nNames of the functions in the program. These are used for …\nNames of the functions in the program. These are used for …\nUse pedantic ACVM solving, i.e. double-check some …\nAdds the file from the file system at <code>Path</code> to the crate …\nDisplay the ACIR for compiled circuit\nOutputs the paths to any modified artifacts\nOnly show the SSA and ACIR for the contract function with …\nOutputs the monomorphized IR to stdout for debugging\nEmit debug information for the intermediate SSA IR to …\nOnly show SSA passes whose name contains the provided …\nSuppress warnings\nFlag to turn off the compiler check for missing Brillig …\nFlag to turn off the compiler check for under constrained …\nUnstable features to enable for this current build")