searchState.loadedDescShard("noirc_frontend", 0, "The noir compiler is separated into the following passes …\nThe submodules of this module define the various data …\nNoir’s Hir is the result of the name resolution step …\nThe lexer is the first pass of the noir compiler. Its goal …\nComing after type checking, monomorphization is the last …\nThe parser is the second pass of the noir compiler. The …\nA special kind of path in the form <code>&lt;MyType as Trait&gt;::ident</code>…\nAn “as Trait” path leading to an associated type. E.g. …\nDataBus is public input handled as private input. We use …\nThis statement should be executed at compile-time\nReturns type is not specified.\nIf implicitly_added is true, this operation was implicitly …\nThis is used when an identifier fails to parse in the …\nWe only support  variants of the form <code>Name(A, B, ...)</code> …\nCurrently, we support four types of functions:\nAn argument to a generic type or trait.\nAn iterator over the variants of Self\nInterned statements are allowed to be parsed as …\nRepresents whether the definition can be referenced …\nRepresents an Ast form that can be assigned to\nA Named UnresolvedType can be a struct type or a type …\nA named argument, e.g. <code>&lt;A = B, C = D, E = F&gt;</code>. Used for …\nAst node for an enum\nAst node for a struct\nAST node for trait definitions: …\nAst node for an implementation of a trait for a particular …\nAst node for type aliases\nAn ordered argument, e.g. <code>&lt;A, B, C&gt;</code>\nThe type of quoted code for metaprogramming\n&amp;T and &amp;mut T\nAlready-resolved generics can be parsed as generics when a …\nAn already resolved type. These can only be parsed if they …\nAst node for statements in noir. Statements are always …\nA Trait as return type or parameter of function, including …\nRepresents a single trait bound, such as <code>TraitX</code> or …\nAny declaration inside the body of a trait that a user is …\nEverything else.\nAst node for an impl of a concrete type …\nA special kind of path in the form <code>Type::ident::&lt;turbofish&gt;</code>\nA Vec of unresolved names for type variables. For …\nRepresents a simple trait constraint such as …\nThe parser parses types as ’UnresolvedType’s which …\nThe precursor to TypeExpression, this is the type that the …\nRepresents whether the parameter is public or known only …\nImplements the Visitor pattern for Noir’s AST.\nThis is used to represent an …\nCreate a range over some array.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts a token to a unary operator If you want the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct a PathKind::Plain from this single\nMethod calls have an optional list of generics if the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nComparator operators return a 0 or 1 When seen in the …\nTrue if this function was defined with the ‘comptime’ …\ntrue if generated at compile-time, e.g. from a trait alias\nTrue if this function was defined with the ‘unconstrained…\nThe kind of each argument, in order (in case traversing …\nAll named arguments, e.g. <code>&lt;A = B, C = D, E = F&gt;</code>. Used for …\nEach ordered argument, e.g. <code>&lt;A, B, C&gt;</code>\nThis is None for tag variants without parameters. A value …\nCreate a half-open range, bounded inclusively below and …\nCreate a range bounded inclusively below and above.\nReturns the span where turbofish happen. For example:\nReturns the innermost location that gives this expression …\nReturns the innermost location that gives this statement …\nIndicate if this function was defined with the ‘pub’ …\nThis structure is used to collect information about …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEvaluating a comptime call like <code>Module::add_item</code>\nThis is the unresolved version of <code>ElaboratorOptions</code> CLI …\nResolverMetas are tagged onto each definition to track how …\nA function attribute generated an item that’s being …\nAdd the given generics to scope. Each generic will have a …\nThe scope of –debug-comptime, or None if unset\nElaborate an expression from the middle of a comptime …\nEquivalent to <code>elaborate_pattern</code>, this version just also …\nUnstable compiler features that were explicitly enabled. …\nRun the given function using the resolver and return true …\nGo through the given tokens looking for a ‘$’ token …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLookup a given struct type by name.\nLookup a given trait by name/path.\nTrue if we should use pedantic ACVM solving\nUse pedantic ACVM solving\nPush a trait constraint into the current FunctionContext …\nTranslates an UnresolvedType into a Type and appends any …\nthe index in the scope tree (sometimes being filled by …\nDo not apply type bindings even after a successful …\nRegister a use of the given unstable feature. Errors if …\nList of characters that are not allowed in a crate name …\nXXX: This is bare-bone for two reasons:\nA dependency is a crate name and a crate_id This means …\nThe special case of running the compiler against the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHelper object which groups together several useful context …\nActivates LSP mode, which will track references for all …\nReturn the CrateId for each crate that has been compiled …\nThis set of modules implements the name resolution pass …\nReturns the CrateDefMap for a given CrateId. It is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns a fully-qualified path to the given [StructId] …\nReturn a Vec of all <code>contract</code> declarations in the source …\nReturns a list of all functions in the current crate …\nReturns the FuncId of the ‘main’ function in a crate.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis set of modules implements the second half of the name …\nA map of each file that already has been visited from a …\nComptime errors always wrap another error to show it …\nThe possible errors that can halt the interpreter.\nTo expand macros the Interpreter needs access to the …\nEvaluate an expression and return the result. This will …\nevaluate_cast without recursion\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGiven a Crate root, collect all definitions in that crate\nStores all of the unresolved functions in a particular …\nCollect all of the definitions in a given crate into a …\nSeparate the globals Vec into two. The first element in …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the primary location where this error happened.\nWalk a module and collect its definitions.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA ‘contract’ in Noir source code with a given name, …\nSpecifies a contract function and extra metadata that one …\nMap of all modules and scopes defined within a crate.\nLets first check if this is offered by any external crate …\nThe name that is used for a non-contract program’s …\nContains the actual contents of a module: its parent (if …\nA generic ID that references either a module, function, …\nReturns an Err if there is already an item in the …\nEach child in the order they were declared in the parent …\nCollect all definitions in the crate\nReturns the reason for the test function to fail if …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGo through all modules in this crate, find all …\nGo through all modules in this crate, and find all …\nGo through all modules in this crate, and find all …\nReturns the function id of the test function\nFind a child module’s name by inspecting its parent. …\nReturn a topological ordering of each module such that any …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if this module is a <code>contract Foo { ... }</code> module …\nIndicates whether the function is an entry point\nTrue if this module is actually a type\nFind the main function for this crate\nTo keep <code>name</code> semi-unique, it is prefixed with the names of …\nReturns this module’s parent, if there’s any.\nGiven a FileId, fetch the File, from the FileManager and …\nReturns true if the test function has been specified to …\nReturn an iterator over all definitions defined within …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns <code>true</code> if any point of <code>self</code> intersects a point of …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the name that’s brought into scope: either the …\nResolves a Path in a <code>use</code> statement, assuming it’s …\nGiven a Path and a ModuleId it’s being used in, this …\nReturns true if an item with the given visibility in the …\nThis implementation uses the terminology Scope and …\nScopeTree allows one to specify that maps within the same …\nEnding a function requires that we removes it’s whole …\nEnds the current scope - this should correspond with the …\nReturns an iterator over all of the elements which satisfy …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the last pushed scope from the current scope tree\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nStarting a function requires a new scope tree, as you do …\nThe beginning of a scope always correlates with the start …\nRust also only shows 3 maximum, even for short patterns.\nThis error is used for types like integers which have too …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRepresents something that can be generic over type …\nTraitGenerics are different from regular generics in that …\nTrue if this item kind can ever accept named type …\nReturns the argument unchanged.\nEach ordered generic on this type, excluding any named …\nCalls <code>U::from(self)</code>.\nThe name of this kind of item, for error messages. E.g. “…\nThe name of this item, usually named by a user. E.g. “Foo…\nA Failure node in the match. <code>missing_case</code> is true if this …\nA method can be defined in a regular <code>impl</code> block, in which …\nRun <code>body</code> if the given expression is true. Otherwise …\nA variable captured inside a closure\nCorresponds to <code>assert</code> and <code>assert_eq</code> in the source code. …\nAn enum constructor is an expression such as …\nA HirExpression is the result of an Expression in the AST …\nCorresponds to a variable in the source code\nIndexing, as in <code>array[index]</code>\nThis is always a struct field access <code>my_struct.field</code> and …\nThese nodes are temporary, they’re lowered into …\nThis ident is not a trait method\nJump directly to ExprId\nSwitch on the given variable with the given cases to test. …\nThis ident refers to a trait method and its impl needs to …\nOr a method can come from a Trait impl block, in which case\nThis refers to just the arguments that are passed. E.g. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nMethod calls have an optional list of generics provided by …\nIf this HirIdent refers to a trait method, this field …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if this constructor constructs an enum value. Enums …\nTrue if we should return an offset of the field rather …\nTrue if this constructor constructs a tuple or struct …\nConvert to AST for display (some details lost)\nThe trait method id for the operator trait method that …\nThe trait method id for the operator trait method that …\nThis will be None when the capture refers to a local …\nA FuncMeta contains the signature of the function and any …\nA Hir function is a block expression with a list of …\nAn interned function parameter from a function definition\nAll the generics used by this function, which includes any …\nThe set of generics that are declared directly on this …\nIf this function is the one related to an enum variant, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTrue if this function is marked with an attribute that …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if this function is an entry point to the program. …\nA stub function does not have a body. This includes …\nThe HirIdent of each identifier within the parameter list. …\nGives the (uninstantiated) return type of this function.\nIf this function is from an impl (trait or regular impl), …\nThe crate this function was defined in\nTHe file this function was defined in\nThe module this function was defined in\nTake this function body, returning an owned version while …\nThe trait impl this function belongs to, if any\nThe type of this function. Either a Type::Function or a …\nThe type this method belongs to, if any\nCorresponds to <code>lvalue = expression;</code> in the source code\nRepresents an Ast form that can be assigned to. These can …\nA HirStatement is the result of performing name resolution …\nCreates a new ‘basic’ let statement with no attributes …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIterate over the fields of this pattern. Panics if the …\nRepresents a trait in the type system. Each instance of …\nReturns a TraitConstraint for this trait using Self as the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns both the ordered generics of this type, and its …\nA unique id representing this trait type. Used to check if …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaps method_name -&gt; method id. This map is separate from …\nWhen resolving the types of Trait elements, all references …\nThe resolved trait bounds (for example in …\nAny ordered type arguments on the trait this impl is for. …\nThe where clause, if present, contains each trait …\nA user-defined alias to another type. Similar to a Struct, …\nCan bind to any type\nArray(N, E) is an array of N elements of type E. It is …\nA restricted subset of binary operators useable on type …\nThe primitive <code>bool</code> type.\nA cast (to, from) that’s checked at monomorphization.\nA type-level integer. Included to let\nRepresents a struct or enum type in the type system. Each …\nA user-defined struct type. The <code>Shared&lt;StructType&gt;</code> field …\nThe result of some type error. Remembering type errors as …\nA primitive Field type\nFmtString(N, Vec) is an array of characters of length N …\nA type generic over the given type variables. Storing both …\nA functions with arguments, a return type and environment. …\nCorresponds to generic lists such as <code>&lt;T, U&gt;</code> in the source …\nCorresponds to generic lists such as <code>&lt;T, U&gt;</code> with additional\nAn infix expression in the form <code>lhs * rhs</code>.\nA primitive integer type with the given sign and bit count.\nA generic integer type. This is a more specific kind of …\nA generic integer or field type. This is a more specific …\nA Kind is the type of a Type. These are used since only …\nNamedGenerics are the ‘T’ or ‘U’ in a user-defined …\nCan bind to any type, except Type::Constant and …\nCan bind to a Type::Constant or Type::InfixExpr of the …\nThe type of quoted code in macros. This is always a …\n&amp;T\nA shared, mutable reference to some T. Wrapper is required …\nSlice(E) is a slice of elements of type E.\nString(N) is an array of characters of length N. It is …\n<code>impl Trait</code> when used in a type position. These are only …\nA tuple type with the given list of fields in the order …\nWrap around an unsolved type\nTypeBindings are the mutable insides of a TypeVariable. …\nA list of (TypeVariableId, Kind)’s to bind to a type. …\nA TypeVariable is a mutable reference that is either bound …\nTypeVariables are stand-in variables for some type which …\nA unique ID used to differentiate different type variables\nThe unit type <code>()</code>.\nApply the given type bindings, making them permanently …\nReturn this type as a monomorphic type - without a …\nBind this type variable to a value.\nBorrows this TypeVariable to (e.g.) manually match on the …\nTry to canonicalize the representation of this type. …\nIf this type is a Type::Constant (used in array lengths), …\nReturns the field at the given index. Panics if no field …\nReturns the number of field elements required to represent …\nReturns each of this type’s field names. Returns None if …\nRetrieve the fields of this type with no modifications. …\nFollow any TypeVariable bindings within this type. Doing …\nFollow bindings if this is a type variable or generic to …\nForcibly bind a type variable to a new type - even if the …\nForcibly substitute any type variables found within this …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nPerform the actual rust numeric operation associated with …\nReturns the number of <code>Forall</code>-quantified type variables on …\nReturn the generics on this type as a vector of types\nReturns the field matching the given field name, as well …\nRetrieves the type of the given field name Panics if the …\nRetrieve the fields of this type. Returns None if this is …\nReturns the name and raw types of each field of this type. …\nReturns all the fields of this type, after being applied …\nRetrieve the given variant at the given variant index of …\nReturns the name and raw parameters of the variant at the …\nRetrieve the variants of this type. Returns None if this …\nReturns the name and raw parameters of each variant of …\nA unique id representing this type. Used to check if two …\nCreates an <code>InfixExpr</code>.\nInstantiate this struct type, returning a Vec of the new …\nInstantiate this type, replacing any type variables it is …\nInstantiates a type with the given types. This differs …\nInstantiate this type with the given type bindings. If any …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates an <code>InfixExpr</code> that results from the compiler trying …\nA bit of an awkward name for this function - this function …\nTrue if this variant was declared as a function. Required …\nCheck that if bound, it’s an integer and if unbound, …\nCheck that if bound, it’s an integer or field and if …\nWhile Kind::is_numeric refers to numeric <em>types</em>, this …\nTrue if the given TypeVariableId is free anywhere within …\nReplace any <code>Type::NamedGeneric</code> in this type with a …\nTo account for cyclic references between structs, a struct…\nSubstitute any type variables found within this type with …\nAttempt to coerce <code>&amp;mut T</code> to <code>&amp;T</code>, returning true if this is …\n<code>try_unify</code> is a bit of a misnomer since although errors are …\nUnbind this type variable, setting it to Unbound(id).\nTry to unify this type with another, setting any type …\nSimilar to <code>unify</code> but if the check fails this will attempt …\nReturn the generics and type within this <code>Type::Forall</code>. …\nReturns the enum variant at the given index. Panics if no …\nReturns the function type of the variant at the given …\nReturns the function type of the variant at the given …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nContains the error value\nContains the error value\nThe job of the lexer is to transform an iterator of …\nContains the success value\nContains the success value\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nGiven a source file of noir code, return all the tokens in …\nAllow chosen warnings to happen so they are silenced.\n&amp;\n&amp;\n-&gt;\n-&gt;\n=\n=\nAn Attribute can be either a Primary Attribute or a …\n!\n!\nRepresents a token in noir’s grammar - a word, number, …\n^\n^\n:\n:\n,\n,\n$\n$\n.\n.\n::\n::\n..\n..\n..=\n..=\n==\n==\n=&gt;\n=&gt;\nPrimary Attributes are those which a function can only …\n=\n=\nA reference to an interned <code>ExpressionKind</code>.\nA reference to an interned <code>LValue</code>.\nA reference to an interned <code>Pattern</code>.\nA reference to an interned <code>StatementKind</code>.\nA reference to an interned <code>UnresolvedTypeData</code>.\nAn invalid character is one that is not in noir’s …\nAn invalid character is one that is not in noir’s …\nNote that <code>self</code> is not present - it is a contextual keyword …\nAn iterator over the variants of Self\n{\n{\n[\n[\n(\n(\n&lt;\n&lt;\n&lt;=\n&lt;=\nAn attribute expected to run a comptime function of the …\nNo scope is applied and so the test must pass\n!=\n!=\n%\n%\n|\n|\nA quoted type resulting from a <code>Type</code> object in noir code …\nthe u8 is the number of hashes, i.e. r###..\nthe u8 is the number of hashes, i.e. r###..\n}\n}\n]\n]\n)\n)\nSecondary attributes are those which a function can have …\n;\n;\n&lt;&lt;\n&lt;&lt;\nIf a test has a scope of ShouldFailWith, then it can only …\n/\n/\n&amp; followed immediately by ‘[’ This is a lexer hack to …\nA custom tag attribute: #[’foo]\nTestScope is used to specify additional annotations for …\nThe different kinds of tokens that are possible in the …\nThis is an implementation detail on how macros are …\nThis is an implementation detail on how macros are …\nTreat any metaprogramming functions within this one as …\nA variable-argument comptime function.\nThese are all the operators allowed as part of a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns note if a deprecated secondary attribute is found\nReturns true if one of the secondary attributes is …\nTrue if the function is marked with an <code>#[export]</code> attribute.\nCheck if secondary attributes contain a specific instance.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if these attributes mean the given function is an …\nCheck whether we have an <code>inline_always</code> attribute This is …\nCheck whether we have an <code>inline</code> attribute Although we also …\nA <code>ModuleDefId</code> captured to be offered in LSP’s …\nIf the item is available via a re-export, this contains …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe item to import.\nThe item’s visibility.\nStarting from the given <code>main</code> function, monomorphize the …\nCall sites are instantiated against the trait method, but …\nThis module implements printing of the monomorphized AST, …\nA definition is either a local (variable), function, or is …\nThe monomorphized AST is expression-based, all statements …\nFunctions marked as foldable will not be inlined and …\nA function ID corresponds directly to an index of …\nA function ID corresponds directly to an index of …\nThe most basic entry point can expect all its functions to …\nFunctions marked as inline always will always be inlined, …\nRepresents how an Acir function should be inlined. This …\nRepresents an Ast form that can be assigned to\nRather than a Pattern containing possibly several …\nID of a local definition, e.g. from a let binding or …\nFunctions marked to have no predicates will not be inlined …\nCompared to hir_def::types::Type, this monomorphized Type …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGlobals are expected to be generated within a different …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTakes a function body by replacing it with <code>false</code> and …\nWe keep a collection of the debug variables and their …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAssumed impls don’t have an impl id since they don’t …\nA dependency in the dependency graph may be a type or a …\nAll the information from a function that is filled out …\nAn ID for a global value\nWhen searching for a trait impl, these are the types of …\nLocals may be defined in let statements or parameters, in …\nRepresents the methods on a given type that each share the …\nThe node interner is the central storage location of all …\nGeneric types in functions (T, U in <code>fn foo&lt;T, U&gt;(...)</code> are …\nCaptures a reexport that happens inside a module. For …\nA reference to a module, struct, trait, etc., mainly used …\nA trait implementation is either a normal implementation …\nAdds an “assumed” trait implementation to the …\nAdds a non-trait method to a type.\nAdds a trait implementation to the list of known …\nAdds [TypeLiasId] and Location to the type_alias_ref vector\nRegister that <code>dependent</code> depends on <code>dependency</code>. This is …\nRetrieves the definition where the given id was defined. …\nRetrieves the definition where the given id was defined. …\nReturns the name of the definition\nReturns the type of the definition or <code>Type::Error</code> if it …\nReturns the interned expression corresponding to <code>expr_id</code>\nScans the interner for the item which is located at that …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the interned HIR function corresponding to <code>func_id</code>\nReturns the interned meta data corresponding to <code>func_id</code>\nReturns the module this function was defined within\nReturns the visibility of the given function.\nReturns the Location of the definition of the given Ident …\nTry to get the <code>HirLetStatement</code> which defines a given …\nReturns the type of an operator (which is always a …\nRetrieves the trait id for a given binary operator. All …\nRetrieves the trait id for a given unary operator. Only …\nReturns the type of a prefix operator (which is always a …\nRetrieves the impl selected for a given ExprId during name …\nIf the given function belongs to a trait impl, return its …\nReturns the span of an item stored in the Interner\nReturns the type of an item stored in the Interner or …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if this definition is for a global variable. Note …\nTrue if this definition is for a global variable. Note …\nIterate through each method, starting with the direct …\nLooks up a method that’s directly defined in the given …\nReturns the <code>FuncId</code> corresponding to the function referred …\nLooks up methods at impls for all types <code>T</code>, e.g. …\nGiven a <code>ObjectType: TraitId</code> pair, try to find an existing …\nLooks up a methods that apply to the given type but are …\nThe location of the function’s name rather than the …\nCreates a new struct or enum type with no fields or …\nReturns what the next trait impl id is expected to be.\nReturns the module where this struct is defined.\nStore the type for a definition\nIntern an empty function.\nIntern an empty global. Used for collecting globals before …\nInterns a HIR expression.\nIntern an expression with everything needed for it …\nStores the span for an interned expression.\nStore the type for an interned expression\nInterns a HIR Function.\nInterns a function’s metadata.\nInterns a HIR statement.\nStore Location of Type reference\nRemoves all TraitImplKind::Assumed from the list of known …\nReplaces the HirExpression at the given ExprId with a new …\nReplaces the HirStatement at the given StmtId with a new …\nTags the given identifier with the selected trait_impl so …\nReturns the interned statement corresponding to <code>stmt_id</code>\nConvert to AST for display (some details lost)\nConvert to AST for display (some details lost)\nReturns the DefinitionId of a trait’s method, panics if …\nReturn a set of TypeBindings to bind types from the parent …\nAdd the given trait as an operator trait if its name …\nAdd the given trait as an operator trait if its name …\nTries to retrieve the given id’s definition. This …\nReturns the span of an item stored in the Interner, if …\nSimilar to <code>lookup_trait_implementation</code> but does not apply …\nReturns the Type of the expression that exists at the …\nUpdates the interned expression corresponding to <code>expr_id</code>\nUpdates the underlying interned Function.\nReturns the interned statement corresponding to <code>stmt_id</code>\nWhether the function is <code>pub</code> or not.\nThe trait generics to use - if specified. This is allowed …\nA ParsedModule contains an entire Ast for one file.\nA submodule defined via <code>mod name { contents }</code> in some …\nRepresents a parsing error, or a parsing error in the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nModule declarations like <code>mod foo;</code>\nPathNoTurbofish = PathKind identifier ( ‘::’ …\nEntry function for the parser - also handles lexing …\nInvokes <code>parsing_function</code> (<code>parsing_function</code> must be some …\nFull submodules as in <code>mod foo { ... definitions ... }</code>\nNecessary to handle casting to unsigned generically …\nReturns the argument unchanged.\nConvert a signed integer to a SignedField, carefully …\nCalls <code>U::from(self)</code>.\nConvert a SignedField into a signed integer type (up to …\nConvert a SignedField into an unsigned integer type (up to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet all the unused items per module.")