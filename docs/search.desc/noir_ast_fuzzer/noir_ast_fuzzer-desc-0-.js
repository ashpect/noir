searchState.loadedDescShard("noir_ast_fuzzer", 0, "AST generation configuration.\nWrapper around <code>Program</code> that prints the AST as close to …\nGenerate an arbitrary input according to the ABI.\nGenerate an arbitrary monomorphized AST.\nFrequency of expressions, which produce a value.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaximum size for arrays.\nMaximum number of statements in a block.\nMaximum call depth for recursive calls.\nMaximum nesting depth for complex expressions.\nMaximum number of arguments a function can have.\nMaximum number of statements to aim for in a function body.\nMaximum number of functions (other than main) to generate.\nMaximum number of global definitions.\nMaximum size of for loop ranges, which affects unrolling …\nMaximum number of fields for tuples.\nModule responsible for generating arbitrary Program ASTs.\nGenerate the Abi interface of a Program.\nFrequency of statements in ACIR functions.\nFrequency of statements in Brillig functions.\nVisit for the contents of an Expression representing the …\nVisit for the contents of an Expression representing the …\nCheck if a type is valid as an ABI parameter for the <code>main</code> …\nGenerate the Abi interface of a Program.\nMap an AST type to an ABI type.\nCompare two equivalent variants of the same program, …\nCompare the execution the same program compiled in two …\nPossible outcomes of the differential execution of two …\nCompare the execution of different SSA representations of …\nGenerate a random AST and compile it into SSA in two …\nGenerate a random AST and compile it into SSA in two …\nGenerate a random AST and compile it into SSA in two …\nCheck whether two errors can be considered equivalent.\nExecute the two SSAs and compare the results.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck that the programs agree on a return value.\nGenerate an arbitrary input according to the ABI.\nContext to accumulate top level generated item, so we know …\nWrapper around <code>Program</code> that prints the AST as close to …\nName of a variable.\nID of variables in scope.\nGenerate an arbitrary monomorphized AST.\nReturn the generated Program.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a function declaration.\nFunction signatures generated up front, so we can call any …\nRandomly generated functions that can access the globals …\nGenerate a random function declaration.\nGenerate random function names and signatures.\nGenerate random function bodies.\nGenerate the i-th global variable, which is allowed to use …\nGenerate random global definitions.\nGenerate a random Type.\nGlobal variables.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the main function declaration.\nDerive a variable name from the ID.\nAs a post-processing step, identify recursive functions …\nRandom types generated for functions.\nAssign a value to an identifier.\nMake a binary expression.\nCast an expression to a target type.\nDereference an expression into a target type\nMake an <code>==</code> expression.\nAppend statements to a given block.\nGenerate a literal expression according to a type.\nGenerate a literals for loop ranges with signed/unsigned …\nCheck if an <code>Expression</code> contains any <code>Call</code> in any of its …\nMake an <code>Ident</code> expression out of a variable.\nMake an <code>Ident</code> out of a variable.\nMake an if/else expression.\nCreate an <code>if</code> expression, with an optional <code>else</code>.\nTake an integer expression and make sure it fits in an …\nInteger literal, can be positive or negative depending on …\nCreate a variable.\nMake a modulo expression.\nPrepend an expression to a destination.\nPrepend statements to a given block.\nTake an integer expression and make sure it’s no larger …\nReplace an expression with another one, passing its …\n32-bit unsigned int literal, used in indexing arrays.\nMake a unary expression.\nHelp with cumulative frequency distributions.\nFrequency distribution of generators.\nCheck if a key is enabled, based on the already checked …\nLike <code>enabled</code>, but if <code>cond</code> is <code>false</code> it redistributes the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the accumulated weights have passed the random …\nIn call arguments we can use <code>if</code> expressions, but avoid …\nIn <code>if</code> conditions avoid nesting more ifs, like …\nControl what kind of expressions we can generate, …\nContext used during the generation of a function body.\nSomething akin to a forward declaration of a function, …\nIn complex nested expressions, avoid generating blocks; …\nIn <code>for</code> ranges we can use <code>if</code> expressions, but let’s not …\nIn a top level context, everything is allowed.\nNumber of statements remaining to be generated in the …\nAll the functions callable from this one, with the types …\nChoose a producer for a type, preferring local variables …\nTop level context, to access global variables and other …\nGet the function declaration.\nDecrease the budget by some amount.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAssign to a mutable variable, if we have one in scope.\nTry to generate a binary expression of a certain type, if …\nGenerate a block of statements, finally returning a target …\nGenerate the function body.\nGenerate a function call to any function in the global …\nDrop a local variable, if we have anything to drop.\nGenerate an expression of a certain type.\nTry to generate an expression that produces a target type …\nTry to generate an expression with a certain type out of …\nGenerate a <code>for</code> loop.\nGenerate an if-then-else statement or expression.\nGenerate an arbitrary index for an array.\nGenerate a <code>Let</code> statement, optionally requesting mutability.\nGenerate a <code>loop</code> loop.\nGenerate a statement, which is an expression that doesn’…\nTry to generate a unary expression of a certain type, if it…\nGenerate a <code>while</code> loop.\nGet a local or global variable.\nGlobal variables.\nHIR representation of a function parameter.\nSelf ID.\nIndicator of being in a loop (and hence able to generate …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nVariables accumulated during the generation of the …\nThe default maximum depth to start from. We use <code>max_depth</code> …\nGet and increment the next ident ID.\nEvery identifier created in the function will have an …\nGet and increment the next local ID.\nEvery variable created in the function will have an …\nGenerate a HIR function signature.\nIs this function unconstrained.\nFind recursive functions and add a <code>ctx_depth</code> parameter to …\nFind the next local ID and ident IDs (in that order) that …\nA layer of variables available to choose from in blocks.\nScope stack as we exit and enter blocks\nAdd a new variable to the current scope.\nAdd a new variable to the scope.\nChoose a random producer of a type, if there is one.\nThe top scope in the stack.\nPush a new scope on top of the current one.\nRemove the last layer of block variables.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a variable in scope.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if there are any variables in scope.\nCreate a stack from the base variables.\nCreate the initial scope from function parameters.\nReverse index of variables which can produce a type. For …\nRemove a variable from all scopes.\nRemove a variable from the scope.\nIterate the types we can produce from other variables.\nIterate the IDs of the variables in scope.\nIterate the variables in scope.\nID and type of variables created in all visible scopes, …\nWe can only use globals that can be evaluated at comptime. …\nCheck if a certain binary operation can return a target …\nCheck if a certain binary operation can take a type as …\nCan the type be returned by some <code>BinaryOp</code>.\nCan the type be returned by some <code>UnaryOp</code>.\nCheck if the type works with <code>UnaryOp::Not</code>\nCheck if the type is a number.\nCheck if a type is <code>Unit</code>.\nCalculate the depth of a type.\nCollect all the sub-types produced by a type.\nVisit for the contents of an Expression representing the …\nVisit for the contents of an Expression representing the …")