searchState.loadedDescShard("noir_ast_fuzzer", 0, "AST generation configuration.\nGenerate an arbitrary input according to the ABI.\nGenerate an arbitrary monomorphized AST.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMaximum size for arrays.\nMaximum nesting depth for complex expressions.\nMaximum number of arguments a function can have.\nMaximum number of functions (other than main) to generate.\nMaximum number of global definitions.\nMaximum number of fields for tuples.\nModule responsible for generating arbitrary Program ASTs.\nGenerate the Abi interface of a Program.\nCheck if a type is valid as an ABI parameter for the <code>main</code> …\nGenerate the Abi interface of a Program.\nMap an AST type to an ABI type.\nCompare two equivalent variants of the same program, …\nCompare the execution the same program compiled in two …\nPossible outcomes of the differential execution of two …\nCompare the execution of different SSA representations of …\nGenerate a random AST and compile it into SSA in two …\nGenerate a random AST and compile it into SSA in two …\nGenerate a random AST and compile it into SSA in two …\nExecute the two SSAs and compare the results.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck that the programs agree on a return value.\nGenerate an arbitrary input according to the ABI.\nContext to accumulate top level generated item, so we know …\nGenerate an arbitrary monomorphized AST.\nReturn the generated Program.\nReturns the argument unchanged.\nGet a function declaration.\nFunction signatures generated up front, so we can call any …\nRandomly generated functions that can access the globals …\nGenerate a random function declaration.\nGenerate random function names and signatures.\nGenerate random function bodies.\nGenerate the i-th global variable, which is allowed to use …\nGenerate random global definitions.\nGenerate a random Type.\nGlobal variables, with higher IDs able to refer to …\nCalls <code>U::from(self)</code>.\nGet the main function declaration.\nCalculate the depth of a type.\nRandom types generated for functions.\nGenerate a literal expression according to a type.\nContext used during the generation of a function body.\nSomething akin to a forward declaration of a function, …\nTop level context, to access global variables and other …\nLocal variables currently in scope.\nDeclaration of this function.\nAdd a layer of block variables.\nRemove the last layer of block variables.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate the function body.\nSelf ID.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLook up a local variable.\nGet and increment the next local ID.\nEvery variable created in the function will have an …\nGenerate a HIR function signature.\nVariables accumulated during the generation of the …")