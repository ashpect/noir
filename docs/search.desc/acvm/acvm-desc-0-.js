searchState.loadedDescShard("acvm", 0, "This trait is extremely unstable and WILL have breaking …\nThis component will generate outputs for Blackbox function …\nReturns the closest number of bytes to the bits specified …\nReturns the argument unchanged.\nConverts bytes into a FieldElement and applies a reduction …\nConverts bytes in little-endian order into a FieldElement …\nCalls <code>U::from(self)</code>.\nComputes the inverse or returns zero if the inverse does …\nMaximum number of bits needed to represent a field element …\nMaximum numbers of bytes needed to represent a field …\nThis is the number of bits required to represent this …\nConverts the field element to a vector of bytes in …\nThis module moves and decomposes acir opcodes. The …\nSimulate a symbolic solve for a circuit\nMinimum width accepted by the <code>CSatTransformer</code>.\nApplies backend specific optimizations to a <code>Circuit</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBuilds a map from a vector of pointers to the old acir …\nMaps the old acir indices to the new acir indices\nApplies backend independent optimizations to a <code>Circuit</code>.\nTells whether a Memory Block is:\nTrack the witnesses that can be solved\nApplies backend specific optimizations to a <code>Circuit</code>.\nApplies backend independent optimizations to a <code>Circuit</code>.\nApplies backend independent optimizations to a <code>Circuit</code>.\nThe redundant range constraint optimization pass aims to …\nThe <code>GeneralOptimizer</code> processes all <code>Expression</code>s to:\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThis pass analyzes the circuit and identifies intermediate …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nStores the lowest bit range, that a witness has been …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMaps witnesses to their lowest known bit sizes.\nCreates a new <code>RangeOptimizer</code> by collecting all known range …\nReturns a <code>Circuit</code> where each Witness is only range …\n<code>UnusedMemoryOptimizer</code> will remove initializations of …\nCreates a set of ids for memory blocks for which no …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreates a new <code>UnusedMemoryOptimizer </code> by collecting unused …\nReturns a <code>Circuit</code> where <code>Opcode::MemoryInit</code>s for unused …\nSimulate a symbolic solve for a circuit\nSimulate a symbolic solve for a circuit by keeping track …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAdds the witness to set of solvable witness\nTells whether a Memory Block is:\nTrack the witnesses that can be solved\nCheck if the Opcode can be solved, and if yes, add the …\nWe need multiple passes to stabilize the output. The value …\nFold all witnesses in a circuit.\nFold a witness into the state.\nAdd all witnesses from the circuit.\nFold many witnesses into the state.\nAdd witnesses from the opcode.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTake the accumulated state.\nFind the witness with the highest ID in the circuit.\nCreate the folder with some initial state and an …\nApplies backend specific optimizations to a <code>Circuit</code>.\nApplies backend specific optimizations to a <code>Circuit</code>.\nApplies backend specific optimizations to a <code>Circuit</code>.\nA transformer which processes any <code>Expression</code>s to break …\nMinimum width accepted by the <code>CSatTransformer</code>.\nChecks if this expression can fit into one arithmetic …\nReturns the argument unchanged.\nGet or generate a scaled intermediate witness which is …\nCalls <code>U::from(self)</code>.\nAdds the witness to set of solvable witness\nCreate an optimizer with a given width.\nNormalize an expression by dividing it by its first …\nTrack the witness that can be solved\nCheck if the equation ‘expression=0’ can be solved, …\nAllows to point to a specific opcode as cause in errors. …\nThe ACVM has encountered an irrecoverable error while …\nEncapsulates a request from a Brillig VM process that …\nThe ACVM is in the process of executing the circuit.\nA dynamic assertion payload whose data has been resolved. …\nThe ACVM has encountered a request for an ACIR call to …\nThe ACVM has encountered a request for a Brillig foreign …\nEnumeration of possible resolved assertion payloads. This …\nAll opcodes have been solved.\nA counter maintained throughout an ACVM process that …\nRepresents the outputs of all ACIR calls during an ACVM …\nStores the solver for memory operations acting on blocks …\nResolved data that represents some ABI type. To be decoded …\nSets the VM status to ACVMStatus::Failure using the …\nFinalize the ACVM execution, returning the resulting …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAn identifier interpreted by the caller process\nThis id references which Brillig function within the main …\nReturn a reference to the arguments for the next pending …\nIndex in the list of ACIR function’s that should be …\nInitial witness for the given circuit to be called\nResolved inputs to a foreign call computed in the previous …\nInserts <code>value</code> into the initial witness map under the index …\nReturns the index of the current opcode to be executed.\nIndex of the next opcode to be executed.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the predicate is zero A predicate is used …\nReturns a slice containing the opcodes of the circuit …\nA list of opcodes which are to be executed by the ACVM.\nResolves an ACIR call’s result (simply a list of fields) …\nResolves a foreign call’s result using a result …\nSelector to the respective ABI type the data in this …\nExecutes the ACVM’s circuit until execution halts.\nUpdates the current status of the VM. Returns the given …\nSets the status of the VM to <code>RequiresAcirCall</code> Indicating …\nSets the status of the VM to <code>RequiresForeignCall</code>. …\nReturns a reference to the current state of the ACVM’s …\nAn Expression solver will take a Circuit’s assert-zero …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA wrapper around field division which skips the inversion …\nDerives the rest of the witness based on the initial low …\nReturns the summation of all of the variables, plus the …\nReturns the evaluation of the multiplication term in the …\nCheck if all of the inputs to the function have assignments\nCheck if all of the inputs to the function have assignments\nResolve BigInt opcodes by storing BigInt values (and their …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReads the hash function input from a <code>WitnessMap</code>.\nAttempts to solve a 256 bit hash function opcode. If …\nWrites a <code>digest</code> to the <code>WitnessMap</code> at witness indices …\nSolves a <code>BlackBoxFunc::And</code> opcode and inserts the result …\nDerives the rest of the witness based on the initial low …\nSolves a <code>BlackBoxFunc::XOR</code> opcode and inserts the result …\nEncapsulates a request from a Brillig VM process that …\nExtracts a <code>ResolvedAssertionPayload</code> from a block of memory …\nAn identifier interpreted by the caller process\nThis id references which Brillig function within the main …\nResolved inputs to a foreign call computed in the previous …\nConstructs a solver for a Brillig block given the bytecode …\nAssigns the zero value to all outputs of a given brillig …\nMaintains the state for solving <code>MemoryInit</code> and <code>MemoryOp</code> …\nReturns the argument unchanged.\nSet the block_value from a MemoryInit opcode\nCalls <code>U::from(self)</code>.")