---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "input",
        "type": {
          "kind": "array",
          "length": 6,
          "type": {
            "kind": "struct",
            "path": "Entry",
            "fields": [
              {
                "name": "key",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "1359149291226868540": {
        "error_kind": "string",
        "string": "hashmap.len() does not match input length."
      },
      "2386996775688025706": {
        "error_kind": "fmtstring",
        "length": 39,
        "item_types": [
          {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          }
        ]
      },
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3078107792722303059": {
        "error_kind": "string",
        "string": "Got incorrect iteration of values."
      },
      "3316745884754988903": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "4105629585450304037": {
        "error_kind": "string",
        "string": "UHashMap after one insert should have a length of 1 element."
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "6665645948190457319": {
        "error_kind": "string",
        "string": "CtHashMaps should be equal."
      },
      "6693878053340631133": {
        "error_kind": "fmtstring",
        "length": 79,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "7233212735005103307": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "7511829951750337011": {
        "error_kind": "fmtstring",
        "length": 37,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "8082322909743101849": {
        "error_kind": "string",
        "string": "UHashMap after one insert and corresponding removal should be empty."
      },
      "9576462532509309328": {
        "error_kind": "fmtstring",
        "length": 82,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "9862881900111276825": {
        "error_kind": "fmtstring",
        "length": 35,
        "item_types": [
          {
            "kind": "field"
          }
        ]
      },
      "9965974553718638037": {
        "error_kind": "fmtstring",
        "length": 81,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "10951819287827820458": {
        "error_kind": "string",
        "string": "Got incorrect iteration of entries."
      },
      "11665340019033496436": {
        "error_kind": "string",
        "string": "Value has been removed, but is still available (not none)."
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12632160011611521689": {
        "error_kind": "string",
        "string": "Got none value."
      },
      "13674703438729013973": {
        "error_kind": "string",
        "string": "UHashMap length is invalid."
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14241324264716156348": {
        "error_kind": "string",
        "string": "CtHashMaps should not be equal."
      },
      "15366650908120444287": {
        "error_kind": "fmtstring",
        "length": 48,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "15583592523844085222": {
        "error_kind": "string",
        "string": "Pair should have been removed, since it does not match predicate."
      },
      "16291778408346427203": {
        "error_kind": "string",
        "string": "Got incorrect iteration of keys."
      },
      "16986922238178214607": {
        "error_kind": "string",
        "string": "UHashMap should have retained 2 elements."
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "4": {
      "source": "unconstrained fn partition<T, let N: u32, Env>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: unconstrained fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_loop<T, let N: u32, Env>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: unconstrained fn[Env](T, T) -> bool,\n) {\n    let mut stack: [(u32, u32)] = &[(low, high)];\n    // TODO(https://github.com/noir-lang/noir_sort/issues/22): use 'loop' once it's stabilized\n    for _ in 0..2 * N {\n        if stack.len() == 0 {\n            break;\n        }\n\n        let (new_stack, (new_low, new_high)) = stack.pop_back();\n        stack = new_stack;\n\n        if new_high < new_low + 1 {\n            continue;\n        }\n\n        let pivot_index = partition(arr, new_low, new_high, sortfn);\n        stack = stack.push_back((pivot_index + 1, new_high));\n        if 0 < pivot_index {\n            stack = stack.push_back((new_low, pivot_index - 1));\n        }\n    }\n}\n\npub unconstrained fn quicksort<T, let N: u32, Env>(\n    arr: [T; N],\n    sortfn: unconstrained fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = arr;\n    if arr.len() > 1 {\n        quicksort_loop(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n",
      "path": "std/array/quicksort.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "9": {
      "source": "use crate::cmp::Eq;\nuse crate::default::Default;\nuse crate::hash::{BuildHasher, Hash, Hasher};\nuse crate::option::Option;\n\n// An unconstrained hash table with open addressing and quadratic probing.\n// Note that \"unconstrained\" here means that almost all operations on this\n// map are unconstrained and importantly are not constrained afterward either.\n// This map is meant to be used in unconstrained or comptime code where this\n// is not an issue.\n//\n// Compared to the constrained HashMap type, UHashMap can grow automatically\n// as needed and is more efficient since it can break out of loops early.\npub struct UHashMap<K, V, B> {\n    _table: [Slot<K, V>],\n\n    // Amount of valid elements in the map.\n    _len: u32,\n\n    _build_hasher: B,\n}\n\n// Data unit in the UHashMap table.\n// In case Noir adds support for enums in the future, this\n// should be refactored to have three states:\n// 1. (key, value)\n// 2. (empty)\n// 3. (deleted)\nstruct Slot<K, V> {\n    _key_value: Option<(K, V)>,\n    _is_deleted: bool,\n}\n\nimpl<K, V> Default for Slot<K, V> {\n    fn default() -> Self {\n        Slot { _key_value: Option::none(), _is_deleted: false }\n    }\n}\n\nimpl<K, V> Slot<K, V> {\n    fn is_valid(self) -> bool {\n        !self._is_deleted & self._key_value.is_some()\n    }\n\n    fn is_available(self) -> bool {\n        self._is_deleted | self._key_value.is_none()\n    }\n\n    fn key_value(self) -> Option<(K, V)> {\n        self._key_value\n    }\n\n    fn key_value_unchecked(self) -> (K, V) {\n        self._key_value.unwrap_unchecked()\n    }\n\n    fn set(&mut self, key: K, value: V) {\n        self._key_value = Option::some((key, value));\n        self._is_deleted = false;\n    }\n\n    // Shall not override `_key_value` with Option::none(),\n    // because we must be able to differentiate empty\n    // and deleted slots for lookup.\n    fn mark_deleted(&mut self) {\n        self._is_deleted = true;\n    }\n}\n\n// While conducting lookup, we iterate attempt from 0 to N - 1 due to heuristic,\n// that if we have went that far without finding desired,\n// it is very unlikely to be after - performance will be heavily degraded.\nimpl<K, V, B> UHashMap<K, V, B> {\n    // Creates a new instance of UHashMap with specified BuildHasher.\n    // docs:start:with_hasher\n    pub fn with_hasher<H>(_build_hasher: B) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let _table = &[Slot::default()];\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    pub fn with_hasher_and_capacity<H>(_build_hasher: B, capacity: u32) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let mut _table = &[];\n        for _ in 0..capacity {\n            _table = _table.push_back(Slot::default());\n        }\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    // Clears the map, removing all key-value entries.\n    // docs:start:clear\n    pub fn clear(&mut self) {\n        // docs:end:clear\n        self._table = &[Slot::default()];\n        self._len = 0;\n    }\n\n    // Returns true if the map contains a value for the specified key.\n    // docs:start:contains_key\n    pub fn contains_key<H>(self, key: K) -> bool\n    where\n        K: Hash + Eq,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:contains_key\n        // Safety: unconstrained context\n        unsafe { self.get(key) }.is_some()\n    }\n\n    // Returns true if the map contains no elements.\n    // docs:start:is_empty\n    pub fn is_empty(self) -> bool {\n        // docs:end:is_empty\n        self._len == 0\n    }\n\n    // Returns a BoundedVec of all valid entries in this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:entries\n    pub fn entries(self) -> [(K, V)] {\n        // docs:end:entries\n        let mut entries = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                // SAFETY: slot.is_valid() should ensure there is a valid key-value pairing here\n                let key_value = slot.key_value().unwrap_unchecked();\n                entries = entries.push_back(key_value);\n            }\n        }\n\n        let self_len = self._len;\n        let entries_len = entries.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {entries_len}.\";\n        assert(entries.len() == self._len, msg);\n\n        entries\n    }\n\n    // Returns a BoundedVec containing all the keys within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:keys\n    pub fn keys(self) -> [K] {\n        // docs:end:keys\n        let mut keys = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (key, _) = slot.key_value_unchecked();\n                keys = keys.push_back(key);\n            }\n        }\n\n        let self_len = self._len;\n        let keys_len = keys.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {keys_len}.\";\n        assert(keys.len() == self._len, msg);\n\n        keys\n    }\n\n    // Returns a BoundedVec containing all the values within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:values\n    pub fn values(self) -> [V] {\n        // docs:end:values\n        let mut values = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (_, value) = slot.key_value_unchecked();\n                values = values.push_back(value);\n            }\n        }\n\n        let self_len = self._len;\n        let values_len = values.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {values_len}.\";\n        assert(values.len() == self._len, msg);\n\n        values\n    }\n\n    // For each key-value entry applies mutator function.\n    // docs:start:iter_mut\n    pub unconstrained fn iter_mut<H>(&mut self, f: fn(K, V) -> (K, V))\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = f(entry.0, entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each key applies mutator function.\n    // docs:start:iter_keys_mut\n    pub unconstrained fn iter_keys_mut<H>(&mut self, f: fn(K) -> K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_keys_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = (f(entry.0), entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each value applies mutator function.\n    // docs:start:iter_values_mut\n    pub fn iter_values_mut(&mut self, f: fn(V) -> V) {\n        // docs:end:iter_values_mut\n        for i in 0..self._table.len() {\n            let mut slot = self._table[i];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                slot.set(key, f(value));\n                self._table[i] = slot;\n            }\n        }\n    }\n\n    // Retains only the elements specified by the predicate.\n    // docs:start:retain\n    pub fn retain(&mut self, f: fn(K, V) -> bool) {\n        // docs:end:retain\n        for index in 0..self._table.len() {\n            let mut slot = self._table[index];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                if !f(key, value) {\n                    slot.mark_deleted();\n                    self._len -= 1;\n                    self._table[index] = slot;\n                }\n            }\n        }\n    }\n\n    // Amount of active key-value entries.\n    // docs:start:len\n    pub fn len(self) -> u32 {\n        // docs:end:len\n        self._len\n    }\n\n    // Get the current capacity of the inner table.\n    // docs:start:capacity\n    pub fn capacity(self: Self) -> u32 {\n        // docs:end:capacity\n        self._table.len()\n    }\n\n    // Get the value by key. If it does not exist, returns none().\n    // docs:start:get\n    pub unconstrained fn get<H>(self, key: K) -> Option<V>\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:get\n        let mut result = Option::none();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, value) = slot.key_value_unchecked();\n                if current_key == key {\n                    result = Option::some(value);\n                    break;\n                }\n            }\n        }\n\n        result\n    }\n\n    // Insert key-value entry. In case key was already present, value is overridden.\n    // docs:start:insert\n    pub unconstrained fn insert<H>(&mut self, key: K, value: V)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:insert\n        self.try_resize();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n            let mut insert = false;\n\n            // Either marked as deleted or has unset key-value.\n            if slot.is_available() {\n                insert = true;\n                self._len += 1;\n            } else {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    insert = true;\n                }\n            }\n\n            if insert {\n                slot.set(key, value);\n                self._table[index] = slot;\n                break;\n            }\n        }\n    }\n\n    unconstrained fn try_resize<H>(&mut self)\n    where\n        B: BuildHasher<H>,\n        K: Eq + Hash,\n        H: Hasher,\n    {\n        if self.len() + 1 >= self.capacity() / 2 {\n            let capacity = self.capacity() * 2;\n            let mut new_map = UHashMap::with_hasher_and_capacity(self._build_hasher, capacity);\n\n            for entry in self.entries() {\n                new_map.insert(entry.0, entry.1);\n            }\n            *self = new_map;\n        }\n    }\n\n    // Removes a key-value entry. If key is not present, UHashMap remains unchanged.\n    // docs:start:remove\n    pub unconstrained fn remove<H>(&mut self, key: K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:remove\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    slot.mark_deleted();\n                    self._table[index] = slot;\n                    self._len -= 1;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Apply UHashMap's hasher onto key to obtain pre-hash for probing.\n    fn hash<H>(self, key: K) -> u32\n    where\n        K: Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        let mut hasher = self._build_hasher.build_hasher();\n        key.hash(&mut hasher);\n        hasher.finish() as u32\n    }\n\n    // Probing scheme: quadratic function.\n    // We use 0.5 constant near variadic attempt and attempt^2 monomials.\n    // This ensures good uniformity of distribution for table sizes\n    // equal to prime numbers or powers of two.\n    fn quadratic_probe(self: Self, hash: u32, attempt: u32) -> u32 {\n        (hash + (attempt + attempt * attempt) / 2) % self._table.len()\n    }\n}\n\n// Equality class on UHashMap has to test that they have\n// equal sets of key-value entries,\n// thus one is a subset of the other and vice versa.\n// docs:start:eq\nimpl<K, V, B, H> Eq for UHashMap<K, V, B>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    B: BuildHasher<H>,\n    H: Hasher,\n{\n    fn eq(self, other: UHashMap<K, V, B>) -> bool {\n        // docs:end:eq\n        let mut equal = false;\n\n        if self.len() == other.len() {\n            equal = true;\n            for slot in self._table {\n                // Not marked as deleted and has key-value.\n                if equal & slot.is_valid() {\n                    let (key, value) = slot.key_value_unchecked();\n                    // Safety: unconstrained context\n                    let other_value = unsafe { other.get(key) };\n\n                    if other_value.is_none() {\n                        equal = false;\n                    } else {\n                        let other_value = other_value.unwrap_unchecked();\n                        if value != other_value {\n                            equal = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        equal\n    }\n}\n\n// docs:start:default\nimpl<K, V, B, H> Default for UHashMap<K, V, B>\nwhere\n    B: BuildHasher<H> + Default,\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        // docs:end:default\n        UHashMap::with_hasher(B::default())\n    }\n}\n",
      "path": "std/collections/umap.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time.\n// The message can be a string, a format string, or any value, as long as it is known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32, T>(predicate: bool, message: T) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "42": {
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "46": {
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n",
      "path": "std/slice.nr"
    },
    "50": {
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::collections::umap::UHashMap;\nuse std::hash::BuildHasherDefault;\n\ntype K = Field;\ntype V = Field;\n\n// It is more convenient and readable to use structs as input.\nstruct Entry {\n    key: Field,\n    value: Field,\n}\n\nglobal HASHMAP_LEN: u32 = 6;\n\nglobal FIELD_CMP: fn(Field, Field) -> bool = |a: Field, b: Field| a.lt(b);\n\nglobal K_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal V_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal KV_CMP: fn((K, V), (K, V)) -> bool = |a: (K, V), b: (K, V)| a.0.lt(b.0);\n\nglobal ALLOCATE_HASHMAP: fn() -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> =\n    || -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> UHashMap::default();\n\nunconstrained fn main(input: [Entry; HASHMAP_LEN]) {\n    test_sequential(input[0].key, input[0].value);\n    test_multiple_equal_insert(input[1].key, input[1].value);\n    test_value_override(input[2].key, input[2].value, input[3].value);\n    test_insert_and_methods(input);\n    test_hashmaps_equality(input);\n    test_retain();\n    test_iterators();\n    test_mut_iterators();\n\n    doc_tests();\n}\n\n// Insert, get, remove.\nunconstrained fn test_sequential(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    hashmap.insert(key, value);\n    assert(hashmap.len() == 1, \"UHashMap after one insert should have a length of 1 element.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n\n    hashmap.remove(key);\n    assert(\n        hashmap.is_empty(),\n        \"UHashMap after one insert and corresponding removal should be empty.\",\n    );\n    let got = hashmap.get(key);\n    assert(got.is_none(), \"Value has been removed, but is still available (not none).\");\n}\n\n// Insert same pair several times.\nunconstrained fn test_multiple_equal_insert(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for _ in 0..HASHMAP_LEN {\n        hashmap.insert(key, value);\n    }\n\n    let len = hashmap.len();\n    assert(len == 1, f\"UHashMap length must be 1, got {len}.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n}\n\n// Override value for existing pair.\nunconstrained fn test_value_override(key: K, value: V, new_value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New hashmap should be empty.\");\n\n    hashmap.insert(key, value);\n    hashmap.insert(key, new_value);\n    assert(hashmap.len() == 1, \"UHashMap length is invalid.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(got == new_value, f\"Expected {new_value}, but got {got}.\");\n}\n\n// Insert several distinct pairs and test auxiliary methods.\nunconstrained fn test_insert_and_methods(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for entry in input {\n        println(f\"Inserting {entry}\");\n        hashmap.insert(entry.key, entry.value);\n    }\n\n    println(hashmap.len());\n    assert(hashmap.len() == HASHMAP_LEN, \"hashmap.len() does not match input length.\");\n\n    for entry in input {\n        let entry_key = entry.key;\n        assert(hashmap.contains_key(entry.key), f\"Not found inserted key {entry_key}.\");\n    }\n\n    hashmap.clear();\n    assert(hashmap.is_empty(), \"UHashMap after clear() should be empty.\");\n}\n\n// Insert several pairs and test retaining.\nunconstrained fn test_retain() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    let (key, value) = (5, 11);\n    hashmap.insert(key, value);\n    let (key, value) = (2, 13);\n    hashmap.insert(key, value);\n    let (key, value) = (11, 5);\n    hashmap.insert(key, value);\n\n    let predicate = |key: K, value: V| -> bool { key * value == 55 };\n    hashmap.retain(predicate);\n\n    assert(hashmap.len() == 2, \"UHashMap should have retained 2 elements.\");\n    assert(\n        hashmap.get(2).is_none(),\n        \"Pair should have been removed, since it does not match predicate.\",\n    );\n}\n\n// Equality trait check.\nunconstrained fn test_hashmaps_equality(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap_1 = ALLOCATE_HASHMAP();\n    let mut hashmap_2 = ALLOCATE_HASHMAP();\n\n    for entry in input {\n        hashmap_1.insert(entry.key, entry.value);\n        hashmap_2.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap_1 == hashmap_2, \"CtHashMaps should be equal.\");\n\n    hashmap_2.remove(input[0].key);\n\n    assert(hashmap_1 != hashmap_2, \"CtHashMaps should not be equal.\");\n}\n\n// Test entries, keys, values.\nunconstrained fn test_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(keys == [2, 5, 11], \"Got incorrect iteration of keys.\");\n    assert(values == [3, 7, 13], \"Got incorrect iteration of values.\");\n    assert(entries == [(2, 3), (5, 7), (11, 13)], \"Got incorrect iteration of entries.\");\n}\n\n// Test mutable iteration over keys, values and entries.\nunconstrained fn test_mut_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let f = |k: K| -> K { k * 3 };\n    hashmap.iter_keys_mut(f);\n\n    let f = |v: V| -> V { v * 5 };\n    hashmap.iter_values_mut(f);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n\n    assert(keys == [6, 15, 33], f\"Got incorrect iteration of keys: {keys}\");\n    assert(values == [15, 35, 65], \"Got incorrect iteration of values.\");\n\n    let f = |k: K, v: V| -> (K, V) { (k * 2, v * 2) };\n    hashmap.iter_mut(f);\n\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(entries == [(12, 30), (30, 70), (66, 130)], \"Got incorrect iteration of entries.\");\n}\n\n// docs:start:type_alias\ntype MyMap = UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>>;\n// docs:end:type_alias\n\n/// Tests examples from the stdlib cthashmap documentation\nunconstrained fn doc_tests() {\n    // docs:start:default_example\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    assert(hashmap.is_empty());\n    // docs:end:default_example\n    // docs:start:with_hasher_example\n    let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::with_hasher(my_hasher);\n    assert(hashmap.is_empty());\n    // docs:end:with_hasher_example\n    // docs:start:insert_example\n    let mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    map.insert(12, 42);\n    assert(map.len() == 1);\n    // docs:end:insert_example\n    get_example(map);\n\n    // docs:start:remove_example\n    map.remove(12);\n    assert(map.is_empty());\n\n    // If a key was not present in the map, remove does nothing\n    map.remove(12);\n    assert(map.is_empty());\n    // docs:end:remove_example\n    // docs:start:is_empty_example\n    assert(map.is_empty());\n\n    map.insert(1, 2);\n    assert(!map.is_empty());\n\n    map.remove(1);\n    assert(map.is_empty());\n    // docs:end:is_empty_example\n    // docs:start:len_example\n    // This is equivalent to checking map.is_empty()\n    assert(map.len() == 0);\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n    map.insert(5, 6);\n    assert(map.len() == 3);\n\n    // 3 was already present as a key in the hash map, so the length is unchanged\n    map.insert(3, 7);\n    assert(map.len() == 3);\n\n    map.remove(1);\n    assert(map.len() == 2);\n    // docs:end:len_example\n    // docs:start:capacity_example\n    let empty_map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::default();\n    assert(empty_map.len() == 0);\n    println(empty_map.capacity());\n    // docs:end:capacity_example\n    // docs:start:clear_example\n    assert(!map.is_empty());\n    map.clear();\n    assert(map.is_empty());\n    // docs:end:clear_example\n    // docs:start:contains_key_example\n    if map.contains_key(7) {\n        let value = map.get(7);\n        assert(value.is_some());\n    } else {\n        println(\"No value for key 7!\");\n    }\n    // docs:end:contains_key_example\n    entries_examples(map);\n    iter_examples(map);\n\n    // docs:start:retain_example\n    map.retain(|k, v| (k != 0) & (v != 0));\n    // docs:end:retain_example\n    // docs:start:eq_example\n    let mut map1: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    let mut map2: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n\n    map1.insert(1, 2);\n    map1.insert(3, 4);\n\n    map2.insert(3, 4);\n    map2.insert(1, 2);\n\n    assert(map1 == map2);\n    // docs:end:eq_example\n}\n\n// docs:start:get_example\nfn get_example(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // Safety: testing context\n    let x = unsafe { map.get(12) };\n\n    if x.is_some() {\n        assert(x.unwrap() == 42);\n    }\n}\n// docs:end:get_example\n\nfn entries_examples(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:entries_example\n    let entries = map.entries();\n\n    // The length of a hashmap may not be compile-time known, so we\n    // need to loop over its capacity instead\n    for i in 0..map.capacity() {\n        if i < entries.len() {\n            let (key, value) = entries[i];\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:entries_example\n    // docs:start:keys_example\n    let keys = map.keys();\n\n    for key in keys {\n        // Safety: testing context\n        let value = unsafe { map.get(key) }.unwrap_unchecked();\n        println(f\"{key} -> {value}\");\n    }\n    // docs:end:keys_example\n    // docs:start:values_example\n    let values = map.values();\n\n    for value in values {\n        println(f\"Found value {value}\");\n    }\n    // docs:end:values_example\n}\n\nunconstrained fn iter_examples(\n    mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>,\n) {\n    // docs:start:iter_mut_example\n    // Add 1 to each key in the map, and double the value associated with that key.\n    map.iter_mut(|k, v| (k + 1, v * 2));\n    // docs:end:iter_mut_example\n    // docs:start:iter_keys_mut_example\n    // Double each key, leaving the value associated with that key untouched\n    map.iter_keys_mut(|k| k * 2);\n    // docs:end:iter_keys_mut_example\n    // docs:start:iter_values_mut_example\n    // Halve each value\n    map.iter_values_mut(|v| v / 2);\n    // docs:end:iter_values_mut_example\n}\n",
      "path": ""
    },
    "57": {
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
