---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "50": {
      "source": "use std::slice;\n\nfn main(x: Field, y: pub Field) {\n    let mut slice = &[0; 2];\n    assert(slice[0] == 0);\n    assert(slice[0] != 1);\n    slice[0] = x;\n    assert(slice[0] == x);\n\n    let slice_plus_10 = slice.push_back(y);\n    assert(slice_plus_10[2] == 10);\n    assert(slice_plus_10[2] != 8);\n    assert(slice_plus_10.len() == 3);\n\n    let mut new_slice = &[];\n    for i in 0..5 {\n        new_slice = new_slice.push_back(i);\n    }\n    assert(new_slice.len() == 5);\n\n    new_slice = new_slice.push_front(20);\n    assert(new_slice[0] == 20);\n    assert(new_slice.len() == 6);\n\n    let (popped_slice, last_elem) = new_slice.pop_back();\n    assert(last_elem == 4);\n    assert(popped_slice.len() == 5);\n\n    let (first_elem, rest_of_slice) = popped_slice.pop_front();\n    assert(first_elem == 20);\n    assert(rest_of_slice.len() == 4);\n\n    new_slice = rest_of_slice.insert(2, 100);\n    assert(new_slice[2] == 100);\n    assert(new_slice[4] == 3);\n    assert(new_slice.len() == 5);\n\n    let (remove_slice, removed_elem) = new_slice.remove(3);\n    assert(removed_elem == 2);\n    assert(remove_slice[3] == 3);\n    assert(remove_slice.len() == 4);\n\n    let append = &[1, 2].append(&[3, 4, 5]);\n    assert(append.len() == 5);\n    assert(append[0] == 1);\n    assert(append[4] == 5);\n\n    let mapped = &[1, 2].map(|x| x + 1);\n    assert_eq(mapped, &[2, 3]);\n\n    assert_eq(&[1, 2, 3].fold(0, |acc, x| acc + x), 6);\n    assert_eq(&[1, 2, 3].reduce(|acc, x| acc + x), 6);\n    assert(&[2, 4, 6].all(|x| x > 0));\n    assert(&[2, 4, 6].any(|x| x > 5));\n\n    regression_2083();\n    // The parameters to this function must come from witness values (inputs to main)\n    regression_merge_slices(x, y);\n    regression_2370();\n\n    regression_4418(x);\n    regression_slice_call_result(x, y);\n    regression_4506();\n}\n\n// Ensure that slices of struct/tuple values work.\nfn regression_2083() {\n    let y = &[(1, 2)];\n    let y = y.push_back((3, 4)); // [(1, 2), (3, 4)]\n    let y = y.push_back((5, 6)); // [(1, 2), (3, 4), (5, 6)]\n    assert(y[2].1 == 6);\n\n    let y = y.push_front((10, 11)); // [(10, 11), (1, 2), (3, 4), (5, 6)]\n    let y = y.push_front((12, 13)); // [(12, 13), (10, 11), (1, 2), (3, 4), (5, 6)]\n    assert(y[1].0 == 10);\n\n    let y = y.insert(1, (55, 56)); // [(12, 13), (55, 56), (10, 11), (1, 2), (3, 4), (5, 6)]\n    assert(y[0].1 == 13);\n    assert(y[1].1 == 56);\n    assert(y[2].0 == 10);\n\n    let (y, x) = y.remove(2); // [(12, 13), (55, 56), (1, 2), (3, 4), (5, 6)]\n    assert(y[2].0 == 1);\n    assert(x.0 == 10);\n    assert(x.1 == 11);\n\n    let (x, y) = y.pop_front(); // [(55, 56), (1, 2), (3, 4), (5, 6)]\n    assert(y[0].0 == 55);\n    assert(x.0 == 12);\n    assert(x.1 == 13);\n\n    let (y, x) = y.pop_back(); // [(55, 56), (1, 2), (3, 4)]\n    assert(y.len() == 3);\n    assert(x.0 == 5);\n    assert(x.1 == 6);\n}\n\n// The parameters to this function must come from witness values (inputs to main)\nfn regression_merge_slices(x: Field, y: Field) {\n    merge_slices_if(x, y);\n    merge_slices_else(x);\n}\n\nfn merge_slices_if(x: Field, y: Field) {\n    let slice = merge_slices_return(x, y);\n    assert(slice.len() == 3);\n    assert(slice[2] == 10);\n\n    let slice = merge_slices_mutate(x, y);\n    assert(slice.len() == 4);\n    assert(slice[3] == 5);\n\n    let slice = merge_slices_mutate_in_loop(x, y);\n    assert(slice.len() == 7);\n    assert(slice[6] == 4);\n\n    let slice = merge_slices_mutate_two_ifs(x, y);\n    assert(slice.len() == 6);\n    assert(slice[3] == 5);\n    assert(slice[4] == 15);\n    assert(slice[5] == 30);\n\n    let slice = merge_slices_mutate_between_ifs(x, y);\n    assert(slice.len() == 8);\n    assert(slice[3] == 5);\n    assert(slice[4] == 30);\n    assert(slice[5] == 15);\n    assert(slice[6] == 50);\n    assert(slice[7] == 60);\n\n    merge_slices_push_then_pop(x, y);\n\n    let slice = merge_slices_push_then_insert(x, y);\n    assert(slice.len() == 7);\n    assert(slice[1] == 50);\n    assert(slice[2] == 0);\n    assert(slice[5] == 30);\n    assert(slice[6] == 100);\n\n    let slice = merge_slices_remove_between_ifs(x, y);\n    assert(slice.len() == 5);\n}\n\nfn merge_slices_else(x: Field) {\n    let slice = merge_slices_return(x, 5);\n    assert(slice[0] == 0);\n    assert(slice[1] == 0);\n    assert(slice.len() == 2);\n\n    let slice = merge_slices_mutate(x, 5);\n    assert(slice[2] == 5);\n    assert(slice.len() == 3);\n\n    let slice = merge_slices_mutate_in_loop(x, 5);\n    assert(slice[2] == 5);\n    assert(slice.len() == 3);\n}\n\n// Test returning a merged slice without a mutation\nfn merge_slices_return(x: Field, y: Field) -> [Field] {\n    let slice = &[0; 2];\n    if x != y {\n        if x != 20 {\n            slice.push_back(y)\n        } else {\n            slice\n        }\n    } else {\n        slice\n    }\n}\n\n// Test mutating a slice inside of an if statement\nfn merge_slices_mutate(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n    slice\n}\n\n// Test mutating a slice inside of a loop in an if statement\nfn merge_slices_mutate_in_loop(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        for i in 0..5 {\n            slice = slice.push_back(i as Field);\n        }\n    } else {\n        slice = slice.push_back(x);\n    }\n    slice\n}\n\nfn merge_slices_mutate_two_ifs(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n    slice = slice.push_back(30);\n\n    slice\n}\n\nfn merge_slices_mutate_between_ifs(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n\n    slice\n}\n\nfn merge_slices_push_then_pop(x: Field, y: Field) {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(slice.len() == 4);\n    assert(elem == 30);\n\n    let (slice, elem) = slice.pop_back();\n    assert(slice.len() == 3);\n    assert(elem == x);\n}\n\nfn merge_slices_push_then_insert(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n        slice = slice.push_back(15);\n    }\n\n    slice = slice.insert(1, 50);\n    // Test that we can use slice insert the same as slice push back\n    slice = slice.insert(6, 100);\n\n    slice\n}\n\nfn merge_slices_remove_between_ifs(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    let (mut slice, elem) = slice.remove(2);\n    assert(elem == y);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice\n}\n// Previously, we'd get a type error when trying to assign an array of a different size to\n// an existing array variable. Now, we infer the variable must be a slice.\nfn regression_2370() {\n    let mut slice = &[];\n    slice = &[1, 2, 3];\n}\n\nfn regression_4418(x: Field) {\n    let mut crash: [u8; 32] = x.to_be_bytes();\n\n    if x != 0 {\n        crash[0] = 10;\n    }\n}\n\nfn regression_slice_call_result(x: Field, y: Field) {\n    let mut slice = merge_slices_return(x, y);\n    if x != 0 {\n        slice = slice.push_back(5);\n        slice = slice.push_back(10);\n    } else {\n        slice = slice.push_back(5);\n    }\n    assert(slice.len() == 5);\n    assert(slice[0] == 0);\n    assert(slice[1] == 0);\n    assert(slice[2] == 10);\n    assert(slice[3] == 5);\n    assert(slice[4] == 10);\n}\n\nfn regression_4506() {\n    let slice: [Field] = &[1, 2, 3];\n    assert(slice == slice);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "directive_invert",
    "directive_integer_quotient",
    "directive_to_radix"
  ]
}
