---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "to_hash",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "array",
            "length": 10,
            "type": {
              "kind": "field"
            }
          }
        },
        "visibility": "private"
      },
      {
        "name": "enable",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "boolean"
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": {
        "kind": "array",
        "length": 3,
        "type": {
          "kind": "field"
        }
      },
      "visibility": "public"
    },
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "use poseidon::poseidon2::Poseidon2;\n\nglobal NUM_HASHES: u32 = 2;\nglobal HASH_LENGTH: u32 = 10;\n\n#[no_predicates]\npub fn poseidon_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    Poseidon2::hash(inputs, inputs.len())\n}\n\nfn main(\n    to_hash: [[Field; HASH_LENGTH]; NUM_HASHES],\n    enable: [bool; NUM_HASHES],\n) -> pub [Field; NUM_HASHES + 1] {\n    let mut result = [0; NUM_HASHES + 1];\n    for i in 0..NUM_HASHES {\n        let enable = enable[i];\n        let to_hash = to_hash[i];\n        if enable {\n            result[i] = poseidon_hash(to_hash);\n        }\n    }\n\n    // We want to make sure that the function marked with `#[no_predicates]` with a numeric generic\n    // is monomorphized correctly.\n    let mut double_preimage = [0; 20];\n    for i in 0..HASH_LENGTH * 2 {\n        double_preimage[i] = to_hash[0][i % HASH_LENGTH];\n    }\n    result[NUM_HASHES] = poseidon_hash(double_preimage);\n\n    result\n}\n",
      "path": ""
    },
    "57": {
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
