---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "to_hash",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "array",
            "length": 10,
            "type": {
              "kind": "field"
            }
          }
        },
        "visibility": "private"
      },
      {
        "name": "enable",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "boolean"
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": {
        "kind": "array",
        "length": 3,
        "type": {
          "kind": "field"
        }
      },
      "visibility": "public"
    },
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "tdndThxHEIbhe9ljDqarqv98KxayMF5HSAgQhkiRxb2na7reMYkEIm3lxPWs2f62Z6Z652d/nr6dvz7/8eXm7vv9j9Onzz9PXx9vbm9v/vhye3999XRzfzf+9+dp83+6nT6li1PPs5RZ6ixtlr6XtG1RU1SJqlEtao5aos60lMZ48Trer14tao5aotaoLWqfVbaoKapEjTyJPIk8iTyJPIk8iTwdeeY1RR3js9fx/uJ1vL957bPaFjVFlaga1aLmqL79m6OCBnogbyABAQoMjODq1YN9j+YKGuiBsoEEBCgoc8NLjdqi9llr7KAaO6hKVI3qE/MjWjMooIIGeqD5zHz/twQEKLB5CFqOWqLGoWktap+1b1FTVInqE/Op7o29owKfmB/uvb0HZO/vHQkIUGAggwIqiGRJnlMdAhQYyKCAChrwGfYBXwETCQhQYCCDAirw5OIYyTJaS3wtTCQgQIGBDApoAW9jSQ4fLg4frg4DGRRQQQM94H08kYAAkgvJheRCciG5kFxIriRXkivJleRKsne4mKOAChroAe/wiQQEkOMdK94k3rITAhQYyKCAChroE+rdK8UhQIGBDAqooIEe2L+3d3hgdfjw5iigAh/eHT3gTTuRgAAFBjIooAIC9yZJjj57TGkSpUmUJlGaRGkSpUmUJlGaRGkSpUmUJlGaRGkSpUmUJtFKciW5klxJriQ3khvJNIn61+CEgQwKqKCBaD/t5NAkSpMoTWLbBhIQoMBABgVEkxhNYjSJpQQEKDCQQQEV9NljtjdJcygwEE1iNInRJCYNRLeYbiABAQoMEOjnet0cCQhQYCCDAipooAcyyf5VqckhQIGBDAqooIEe8FUwQXIhuZDs/azi8PeoQ4ACAxn4p5vDP8sbwLt3IgEBCgxk4Dl+lL17JxroAf9inEhAgCd7b/gX40QGBVTQQJ/I3vMTHtgcCgxkUEAFDfSA9/xEAiQnkveL3O7IoIAKGuiB/VJ3R+zeLAIUGIjFmL3nbbRW3q9sdyQgwK/dksNABgVU0EAP+LqYSEAAyUaykWwkG8lGsq8LGw2ZfV1M+J9G12VvYzOHAAUGMiigggZ6gObPe/PvEKDAQAYFVNBADzSSG8mN5EZyI7mR7Ktg31JfBeaH0nt+gk3ubHJnkzub7D1vfty95yca8E0erV685ycSiOSyKTCQQQEVNBA7s3jzTyRActoDX14uTtxvfnl6PJ/9dvPVDei4LX24ejzfPZ0+3T3f3l6c/ry6fd7f9OPh6m6vT1eP46+jbc9330Ydgd9vbs+ul4tfo7e3h44TeQweZ/JjeP7w+HHqi/HjnLUwvirjq5aF8W0rMb6llfE1s/212sr4xvzbpivzL8f8+5vzr++Mt+Pziy6MH/eYMX7cTb01vr/TP1mO4/9q/vXD2/+R+b833u//5niV3+sfXfl8U/pnXMmsjK/H/msr889+vbePH+eHt8b7neybAZ0dWF4v4PrhgA91UGr/XwvlxCHMsvIVNJ455GMLXu/E+h8S7EgotpTQj70oW19JEP2VYLKSUBonkvEMQFcS6nEoxhOCpT05HmccW1GXEsbNPAma0tIcWj8StpU9mYWAvLQXPrQm3xk/HjyzpMYz5qWEpByH8RS6LSWUYw7jKeVKgh67YXBpDlmOrRhX1ksJx/XReITcl7ZiOxJUlrZCzY6EvLQV5VhV41H20hxqZVWN59Qra2I8gT72Q5eVhGo0VLWV80Q/LjV6XtkHfaMduyx9/rEges2/N/9/jb8cr66ubx7/8evViyc93lx9vT3Hy+/Pd9ev/vr01wN/4devh8f76/O358ezJ/36CWz881nHDZlmvRzPyMarul207dJ/uhovZNynihV/Oe50PudxPs/ZLl98Yn8D",
  "file_map": {
    "50": {
      "source": "use poseidon::poseidon2::Poseidon2;\n\nglobal NUM_HASHES: u32 = 2;\nglobal HASH_LENGTH: u32 = 10;\n\n#[no_predicates]\npub fn poseidon_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    Poseidon2::hash(inputs, inputs.len())\n}\n\nfn main(\n    to_hash: [[Field; HASH_LENGTH]; NUM_HASHES],\n    enable: [bool; NUM_HASHES],\n) -> pub [Field; NUM_HASHES + 1] {\n    let mut result = [0; NUM_HASHES + 1];\n    for i in 0..NUM_HASHES {\n        let enable = enable[i];\n        let to_hash = to_hash[i];\n        if enable {\n            result[i] = poseidon_hash(to_hash);\n        }\n    }\n\n    // We want to make sure that the function marked with `#[no_predicates]` with a numeric generic\n    // is monomorphized correctly.\n    let mut double_preimage = [0; 20];\n    for i in 0..HASH_LENGTH * 2 {\n        double_preimage[i] = to_hash[0][i % HASH_LENGTH];\n    }\n    result[NUM_HASHES] = poseidon_hash(double_preimage);\n\n    result\n}\n",
      "path": ""
    },
    "57": {
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
