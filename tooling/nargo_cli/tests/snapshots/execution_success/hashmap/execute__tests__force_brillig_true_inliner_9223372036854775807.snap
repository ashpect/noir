---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "input",
        "type": {
          "kind": "array",
          "length": 6,
          "type": {
            "kind": "struct",
            "path": "Entry",
            "fields": [
              {
                "name": "key",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "955212737754845985": {
        "error_kind": "string",
        "string": "HashMap should have retained 2 elements."
      },
      "1359149291226868540": {
        "error_kind": "string",
        "string": "hashmap.len() does not match input length."
      },
      "2386996775688025706": {
        "error_kind": "fmtstring",
        "length": 39,
        "item_types": [
          {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          }
        ]
      },
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3078107792722303059": {
        "error_kind": "string",
        "string": "Got incorrect iteration of values."
      },
      "3316745884754988903": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "5727012404371710682": {
        "error_kind": "string",
        "string": "push out of bounds"
      },
      "6693878053340631133": {
        "error_kind": "fmtstring",
        "length": 79,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "6895136539169241630": {
        "error_kind": "string",
        "string": "HashMaps should not be equal."
      },
      "7233212735005103307": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "9417307514377997680": {
        "error_kind": "string",
        "string": "HashMap after one insert should have a length of 1 element."
      },
      "9576462532509309328": {
        "error_kind": "fmtstring",
        "length": 82,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "9862881900111276825": {
        "error_kind": "fmtstring",
        "length": 35,
        "item_types": [
          {
            "kind": "field"
          }
        ]
      },
      "9965974553718638037": {
        "error_kind": "fmtstring",
        "length": 81,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "10951819287827820458": {
        "error_kind": "string",
        "string": "Got incorrect iteration of entries."
      },
      "11665340019033496436": {
        "error_kind": "string",
        "string": "Value has been removed, but is still available (not none)."
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12389747999246339213": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "12632160011611521689": {
        "error_kind": "string",
        "string": "Got none value."
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14479745468926698352": {
        "error_kind": "string",
        "string": "HashMap after one insert and corresponding removal should be empty."
      },
      "15366650908120444287": {
        "error_kind": "fmtstring",
        "length": 48,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "15583592523844085222": {
        "error_kind": "string",
        "string": "Pair should have been removed, since it does not match predicate."
      },
      "16291778408346427203": {
        "error_kind": "string",
        "string": "Got incorrect iteration of keys."
      },
      "16567169223151679177": {
        "error_kind": "string",
        "string": "HashMaps should be equal."
      },
      "16850003084350092401": {
        "error_kind": "string",
        "string": "Load factor is exceeded, consider increasing the capacity."
      },
      "16954218183513903507": {
        "error_kind": "string",
        "string": "Attempted to read past end of BoundedVec"
      },
      "17677620431177272765": {
        "error_kind": "string",
        "string": "HashMap length is invalid."
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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X8A62xewzvYFrLN9AetsX8A62xewzvYFrLN9AetsX8A62xewzvYFrLN9AetsX8A62xewzvYFrLN9AetsX8A62xewzvYFrLN9AetsX8A62xewzvYFrLN9AetsX8A62xewzvYFrLN9AetsX8A62xewzvYFrLN9AetsX8A62xduP9vnvd/kvGAc5FgsOQ5LjseSQ1hyApaciCUnYcnJWHIKkpxooLJyNFBZORqorBwNVFaOBiorRwOVlaOBysrRQGXlaKCycjRYWdliZWWLlZUtVla2WFmZ42yfKektp3Oxs1vX5/yHctu69PSX3SPHMcCHlMdpladpledplZdZlXOcbnxIuZ1WuZtWuZ9W+bQ11KHU0KoGpS5WNSi1rqpBqV9VDUpN+lLjUepMVXN37UjbD2G77M+zgXdlU+69pZ/ZwLtplftpld+d88LWDbpAx7/du/d1DHt18gc1xLyvXep9qintclL++VGRxZLjsOR4LDmEJSdgyYlYchKWnHyvnBR2Oen1fHC/2LeufVXp/do/d9uvrdLLtNKDmVe6xZVuTYmbitca+7X0Ld3NK93PK53mlR7mlR7nlZ7mlQ5cTXvSgaupNXGXbp39KT0CV9OedOhqei4dupqeS4eupufSoavpuXToanouHbqankuHrqbn0qGr6bn0odX0a4lkxi/B8XZTer+/k2Pn4rh/ACGW9yPb9Pff9rGcsH1Iup9XOs0rPcwrPc4rPc0rPc8rvUwrneUE80PS562med5qmuetpiwnrh+SPm81zfNW0zxvNc3zVtM8bzUt81bTMm81LfNW0zJvNWU5Kf+Q9HmraZm3mpZ5q2mZt5qWaatpMtNW02SmrabJTFtNk5m2miYzbTVNZtpqmsy01TSZaatpMjDVtMqBqZBfcixM1atyYCpZlQNTnaocmIpT5dxdRZLd5SSXD3IClpyIJSdhyclYcgqUHGew5FgsOVh5x929swptLy+FEo5yMpacAiXHGyw5FkuOw5LjseQQlpyAJSdiybk5K0cTNjnRxHSQk7HkFCg5ZLDkWCw5DkuOx5JDWHIClpyIJQcrKxNWViasrBywsnLAysoBKysHrKwcsLJywMrKASsrB6ysHLCycsDKyhErK0esrByxsnLEysoRKytHrKwcsbJyxMrKESsrR6ysnLCycsLKygkrKyesrJywsnLCysoJKysnrKycsLJywsrKGSsrZ6ysnLGycsbKyhkrK2esrJyxsnLGysoZKytnrKxcsLJywcrKBSsrF6ysXLCycsHKygUrKxesrFywsnKBysrZQGXlbKCycjZQWTkbqKycDVRWzgYqK2cDlZWzgcrK2UBl5WywsrLFysoWKytbrKxssbKyxcrKFisrW6ysbLGyssXKyhYrKzusrOywsrLDysoOKys7rKzssLKyw8rKDisrO6ys7LCyssfKyh4rK3usrOyxsrLHysoeKyt7rKyMdbYvY53ty1hn+zLW2b6MdbYvY53ty1hn+zLW2b6MdbYvY53ty1hn+zLW2b6MdbYvY53ty1hn+zLW2b6MdbYvY53ty1hn+zLW2b6MdbYvY53ty1hn+zLW2b6MdbYvY53ty1hn+zLW2b6MdbYvY53ty1hn+zLW2b6MdbYvY53ty1hn+zLW2b6MdbYvY53ty1hn+zLW2b6MdbYvY53ty1hn+zLW2b6MdbYvY53ty1hn+zLW2b6MdbYvY53ty1hn+zLW2b6MdbYvY53ty1hn+zLW2b6MdbYvY53ty1hn+zLW2b6MdbYvY53ty1hn+wrW2b6CdbavYJ3tK1hn+4qBysoF62xfwTrbV7DO9hWss30F62xfwTrbV7DO9hWss30F62xfuf1snzN+k+NcOcgJWHIilpyEJSdjySlQcm4/29eRY7HkOCw5HksOVlZ2WFnZYWVlh5WVHVZWdlhZ2WNlZY+VlT1WVvZYWdljZWWPlZU9Vlb2WFmZ5WxfTG855fxiZ/P3tc6H96W2denp794XlmOAjyhnOTH4jHI7rXI3rXI/rXKaVnmYVnmcVnmaVvm0NZSmraFh2hoapq2hYdoaGqatoSxnUZ9RjlJDqxqUuljVoNS6qgalflU1KDXpS01EqTNVzd21I9GmJvvzbOBd2ZR7b+lnNohuWuV+WuV357ywPWlygY5/u3fv6xj26uQPahLzvi6596mmtMtJ+edHlSyWHIclx2PJISw5AUtOxJKTsOTke+WksMtJ0b7zoG9dG73br/1zt/3aKr1MKz2beaVbXOnWlO0dvtc/3+/w0bd0N690P690mld6mFd6nFd6mlc6cDXtSQeuptbEXbp19qf0AlxNe9Khq+m5dOhqei4dupqeS4eupufSoavpuXToanouHbqankuHrqbn0hmq6euB+ybd+fR58WsJMhxnjHtL2PFLuPFL+PFL0Pglwvgl4vgl0vgl8vglxu9ujrOqzpn3Ep2LozWbnmitOeqxYHocmB5/rx5b9neuX3XtXX/CtxzCkhOw5EQsOQlLTsaSU6DkOIMlByvvuNt31v5Qy70WP8gZurPqEnn8Egw7wO/l6/XPo93gOO7XW8KOX8KNX8KPX4LGLxHGLxHHL5HGL5HHLzF+d3Mc8HI5v5e4aJY5jm2x6nFgevy9ejpFnePcFKecgCUnYslJWHIylpwCJScYLDlYeSfcvrNOm4kwdGfVJfL4JTjsRvH7EiUcluA4o9Bbwo5fwo1fwo9fgsYvEcYvEccvkcYvkccvMX53p/G7O43f3Wn87k7jd3cav7vT+N3N8Ya+j+a9ROq0X87t7ZeLx3aZ4xV9Vj0ZTE+5V0/HJnK8TM8px2LJcVhyPJYcwpITsORELDlYeafcvrNO29MydGfVJWj8Er/sAKJ9iUidJQLt7/yFGM4vTnm7cTbu/FL3+nvYAn19Y2c+Z4Qfr/a0v3noKbuPa2ucUUicSUicWUicRUSc9re3a5eL0wqJ0wmJ0wuJk4TEKcMPWSPDD1kjww9ZI8MPWSPED1khfsgK8UNWiB+yQvyQFeKHrBA/ZIX4ISvED1khfsgK8UNOiB9yQvyQE+KHnBA/5IT4ISfEDzkhfsgJ8UNOiB9yQvyQF+KHvBA/5IX4IS/ED3khfsgL8UNeiB/yQvyQF+KHvBA/REL8EAnxQyTED5EQP0RC/BAJ8UMkxA+RED9EQvwQCfFDQYgfCkL8UBDih4IQPxSE+KEgxA8FIX4oCPFDQYgfCkL8UBTih6IQPxSF+KEoxA/FoX6oLhHGLxHHL5HGL5HHL1GGL5E4Mv7+Bx5CjucXv1IvbZMAX/9O9uefeLJoghyaII8miNAEBTRBEU1QQhOUbxdUwi7IGTotyzZnu8vP2dvTq917JI439kN1bqkuW36ONnxeWrEUxdLAko1iaWGxiqWFxSmWFhavWFpYSLG0sATF0sISFUsLS1IsLSzqcptY1OW2sBR1uU0sMlxujVWGda2xyvCjNVYSFKsM51hjlWEHa6wyPF6NVYZxq7Eu5Ma8iXmP9XNYest22LD/4q19fW32E4wzC/kxXjALOTJeMAvZN14wC3k9XjCkYNpgFnKRvGAWspy8YBbyp7xgFjKzvGDU+bbBWLnON5YdTC5HMHKdbweMXOfbASPX+XbArORjrN1f47a+Byal7YdIbSru/OJEW4SJ4pHhSgVsGMNCm+YS8oGhW6nWPcVwpbL4FMOVKuhTDFcqtk8xJGV4meFKD6+eYqj+8DrDlR6JPcVwpadnTzHUPuUyQ699yj9gaM37Z8BNDEeK2qlwUNRehYOidiscFEkpMlDUjoWDovYsHBS1a+GgqH3LgWIFo81IGwxph/ELGG0afgEjtg8oZv9yu7gGGLHWvgeGJgJD5uPqKn8mm9yQP5M/bcgHMoZVEJDHqoKAvM2XoHB7hXApvgWldBDEsYPL9mcaou3Mgwwxhf3ibD4vrnoimJ4EpieD6SlYelhG+HLqsWB6HJgeD6aHwPTcnJ/PJhW27O3rhru/jeHnXEMX49zy09zy89zyy9Tyk8GWn8ju8lNDvgWXv798//r30dgmN7d8jyO/CiI0QUCVsQoCqnVVEFD1qoKA6lEVBFRhvgRloJpRBd1fBSYYwuayUywtLF6xtLCQYmlhCYqlhSUqlhaWpFhaWLJiaWEpiqWBpRjF0sKiLreJRV1uE4u63CYWEoGlxirDutZYZfjRGqsMk1ljleEca6wy7OCfWL2R4fFqrDKMW411ITfGOZ7Pm4X8GC8YUjBtMAvZN14wC3k9XjALGUNeMAu5SF4wC1lOVjB2IX/KC2YhM8sLRp3vL2DkOt/TabrekoJpg5HrfDtg5DrfDpiVfMwzg6m9W6mAPTPwzbuVat1TDFcqi08xXKmCPsVwpWL7FMOVnkg9xXClh1dPMVR/eJmhX+mR2FMMV3p69hRD7VOuM9Q+5fq4Rs8yxlYpaq/CQVG7FQ6K2q9wUNSOhYOi9iwMFEm7Fg6K2rc0p+l60mbkFzDaYfwChhRMG4zYPuB8/rInsda+B2Ymt34YjexpJpvckD+TPz3KD0DGsAoC8lhVEJC3qYJurxDng6k9x6Dj6GgX5HPv4tNBrJ5j0DGnHo5Bx6x6LJgeB6bHg+khMD0BTE8E05PA9Nycn3mH8/pYppafzNzy7dzy3dzyPbb888HUnmMS8VD5p5OdfQpzy4848qughCYIqDJWQUC17ktQBqpeVRBQPaqCgCpMFQRUM6qg+6vABEPYfA6KpYUlKpYWlqRYWliyYmlhKYqlgaUYxdLCYhVLC4tTLC0sXrG0sJBiaWFRl9vEoi63iUWGy62xyrCuNVYZfvRPrGRkmMwaqwznWGOVYQdrrDI8Xo2VBMW6kBvjHM9HZiE/xgtmIUfGC2Yh+8YLZiGvxwrGLmQMecEs5CJ5wSxkOXnBLORPecGQgmmDUef7Cxi5zvd0mi5Zuc63A0au8+2Aket8z8G4lXzMM4Opya1UwJ4Z+EZupVr3FMOVyuJTDFeqoE8xXKnYPsTQr/RE6imGKz28eoqh+sPrDFd6JPYUQ1KGlxlqn3KdofYp18c1ktdOhYOi9iocFLVbYaBI2q9wUNSOhYOi9iwcFLVr4aBISrE1TZdIm5FfwGiH8QsYbRp+ASO2Dzifv0wk1tp3wISZ3PphNDKFmWxyQ/5M/rQhH8gYVkGEJgjI21RBt1eI88HUxDLoOO+TspMpnYvf4xDDv7zCY771ODA9HkwPgekJYHoimJ4EpieD6SlYelhGEXPquTk/W5PeBcOknE8tSogp7bWonNsZl8z2gMalDyscvwN1UgL1UgIlKYEGKYFGKYEmKYFmKYEWIYFmIyVQKc4oS3FGWYozYpn2PUWgUpxRluKMshRnlKU4oyzFGRUpzqhIcUZFijMqUpwRy4ToKQKV4oyKFGdUpDijIsUZFSHOKBghzigYIc4oGCHOKBghzigYkhKoEGcUjBBnFIwQZxTMpM6oip/U7XyJt5M6mCp+UldSxU/qNKr4Sd1DFU/Q4tN+TCIklw/isat8Rzx25e6Ix67GHfHYFbYjHrvCnot32BW2Ix67wnbEz5znHXa2KbRdHD6HDG3isbNNRzx0tokmbBdHE38eSwoeOtv0xENnm554aD/fEw/t53viofN8Tzy0n++Jh/bzPfHQFTY6s41MiM6Vg3joCtsTj11hz8UTdoXtiMeusB3x2BW2Ix67wnbEY1fYjnjsCtsRj11hO+JnrrA0c4WlmStsmLnChpkrbJi5woaZKyzLBKDHxM9cYcPMFTbMXGHDzBU2zFxh48wVNgJV2CoIqGpWQUCVsAq6vbp9TAA0OZz/vXmK+2BKyu4gPswsPs4sPs0sPs8svkwsPpmZxduZxbuZxfuZxc9cYdPMFTbNXGHTzBU2zVxh08wVNs9cYfPMFTbPXGHzzBX2/tlTnOJnrrB55gqbZ66weeYKm2eusGXmCltmrrBl5gpbZq6w988w4hQ/c4UtM1fYMnOFLTNX2DJxhY1m4gobzcQVNpqJK2w0E1fYaCausNFMXGGjmbjCRjNxhY1m4gobzcwV1s5cYe3MFdbOXGHtzBX2/tkynOJnrrB25gprZ66wduYKa2eusG7mCutmrrBu5grrZq6w90/14RQ/c4V1M1dYN3OFdTNXWDdzhfUzV1g/c4X1M1dYD1RhqyCgqlkFAVXCKgioulVBQBWrCgKqQlXQ3ZXFmo9bm06KsK/eMmxXv1o1Or86fwSbs7enV7tStgN33tiPGHMrxrKlqtcTns9LvyDePs9oSYhWIV6H6BTidYheIV6HSArxOsSgEK9DjArxOsSkEK9DzArxOkTtWK5DDNqxMEDUjoUBIt3+RCTb9xOR43PHAFTpqiCgqlEFAWXgL0ERKJtVQQwdZAq0C0qpJyi9d+/r3+UgKI4UVJdI45fI45cow5fgmK3TW8KOX8KNX8KPX4LGLxHGL8Gwu7M12xL549dFmxe/cuX2U6Qxl3JuFU5/tjRyTE95SnqeV3qZVjrH3JSnpNt5pbt5pft5pdO80sO80uetpnneaprnraZ53mpa5q2mZd5qWuatpmXeasoxG+Up6fNW0zJvNS0w1bTKgamQVQ5M1fsjJxmYSlblwFSnKgem4lQ5d1eR4nY5xfuDHMKSE7DkRCw5CUtOxpJToORYgyUHK+/Ym3dWen9t+UoyRzkJS87NOytZ2j6sZP9c8UNOgZLjDJYciyXHYcnxWHIIS07AknN3VnZ5+6225E08yElYcjKWnAIlxxssORZLjsOS47HkEJacgCUHKyt7rKzssbKyx8rKhJWVCSsrE1ZWJqysTFhZmbCyMmFlZcLKyoSVlQkrK3OcQcomvuWE84vd/oq88x+X2r/+YjBxHPx5SLmbVrmfVjlNqzxMqzxOqzxNqzxPq7zMqjxOW0MjSg2talDqYlWDUuuqGpT6VdWg1KSqBqXOVDV314603fjl9M+zgXdlU+79x4nxLRvkaZWXWZWnu3Ne2LpBF+jwt5vu3tcx7NXJH9Uw72tPvU81pV1OyoePKmHJyVhyCpScbLDkWCw5DkuOx5JD98p5tZubnJcjf+dB37o2+v21ifjx2oT/lh7mlR7nlZ5wpVuzTwl6/fM9toC+ped5pZdppRczr3Q7r3Q3r3Q/r3TgatqTDlxNrYm7dOvsQTpwNe1Jh66m59Khq+m5dOhqeiY9G+hqei4dupqeS4eupufSoavpuXToanoufWg1rUvE8Uuk8Uvk8UuU4UtYM34JO34JN34JP34JGr8Ex+5Obl8ix05iKm57Ce7VHb2t+9+PmMgsJ0Afkp7mlZ7nlV6mlc5yYvUh6XZe6W5e6X5e6TSv9HmrqZu3mrp5q6mbt5q6eaupn7ea+nmrqZ+3mvp5qynLyeiHpM9bTT1MNa1yYCpklQNT9aocmEr2JYdgqlOVA1Nxqpzbq0h8y0n2IMdjySEsOQFLTsSSk7DkZCw5BUpOwMo74ead9fp2a7vz61uocJATseTcvLNeT8W30yKvp8z5ICdjySlQcqLBkmOx5DgsOR5LDmHJuTsre7+dC3t1y0c5EUtOwpKTseQUKDnJYMmxWHIclhyPJYew5GBl5YSVlRNWVk5YWTlhZeWMlZUzVlbOWFk5Y2XljJWVM1ZWzlhZOWNl5YyVlVnOkMb8llPOL2Yb3ZRZjpA+o9xOq9xNq9xPq5ymVR6mVR6nVZ6mVZ6nVT5rDS0GpYZWNSh1sapBqXVVDUr9qmpQalJVg1Jnqpq7awfXKL5i0rTK86zK7d0572z8YbF37+uz8YfFMu/rj28Zf/lUz6aiFRux5CQsORlLToGS4wyWHIslx2HJ8ffK4RvEVxzNKz3MKz3iSj+f8FVcmld6nld6mVa6N/NKt/NKd/NKB66mPenA1fR81lTxwNW0Jx26mp5Lh66m59Khq+m5dOhqeiqdoKvpuXToanouHbqankuHrqbn0odW07pEGL9EHL9EGr9EHr9EGb5EMOOXsOOXYMhGL7+3LfF50ntfwo9fgsYvEcYvEccvkcYvkccvUYYvwXGasbeEHb/E+N0dx+/uOH53x/G7m+MU3+ubpfcSHfMUrdn0RGvNUU8C05PB9JR79diS7Hbnkt8GNlQ5HAf5OOVYLDkOS47HkkNYcgKWnIglByvv5Nt31v5U3BkXD3KG7qy6BI1fIoxfIo5fIo1fIo9fogxfopjxS9jxS7jxS4zf3WX87i7jd3cZv7vL+N1dxu/uMnp3B2PM+CXs+CXc+CX8+CVo/BJh/BJx/BJp/BJ5/BLjd7cdv7vt+N1tx+9uO3532/G7247f3Xb87rbjd7cdv7vt+N3txu9uN353u/G7243f3W787nbjd7cbv7vd+N3txu9uN353+/G724/f3X787vbjd7cfv7v9+N3tx+9uP353+/G724/f3TR+d9P43U3jdzeN3900fnfT+N1N43c3jd/dNH530/jdHcbv7jB+d4fxuzuM391h/O4O43d3GL+7w/jdHcbv7jB+d8fxuzuO391x/O6O43d3HL+74/jdHcfv7jh+d8fxuzuO391p/O5O43d3Gr+70/jdncbv7jR+d6fxuzuN391p/O5O43d3Hr+78/jdncfv7jx+d+fxuzuP3915/O7O43d3Hr+78/jdXcbv7jJ+d5fxu7uM391l/O5meFctvr40/7749c90XCKOXyKNXyKPX6KMXsIyvKvWXcKOX8KNX8KPX4LGLxHGLxHHL5HGL8FRu/eDC68lLh0+e+kpWHpY3oLj1GPv1XN6SOYlx2HJ8VhyCEtOwJITseQkLDkZSo7Dyjvu9p11cjjvJWfozqpLxPFLMNgNu3dd0X6O6W9dTH77hXiid6WjbzEZSUwBEsPwch+jGIskxiGJ8UhiCElMQBITkcTcnIEL+W1IVqHwlpNa1SPuM+lCLHR67ekPIL3CzDLCLCLCJCMjTCsjTCcjTC8jTJIRZpARZpQRpgwXRDJcEMlwQUGGCwoyXFCQ4YKCDBfEcIxjijBluKAgwwUFGS4oyHBBQYYLijJcUJThgqIMFxRluCCG425ThCnDBUUZLijKcEFRhguKMlxQkuGCkgwXlGS4oCTDBTEcC34gzCp9SmdTpU/pVqr0KR1IlT6lq6jSp3QKX9IzcvVPdpeeXD5IR67oHenIVbojHbnydqQjV9OOdORq2pGOXE070pGr6bn0Mm9eL8gZptB2KiWUcJSOnGE60oEzTDThfRYopoN04AzTkw6cYXrSgf16TzqwXz+X7gxwXu9JB/brPenAfr0nHbiaxpe67cbOlYN04Grak45cTTvSkatpRzpyNe1IR66mHenI1fRcukWuph3pyNW0Ix25mnakz1tNGea7PCZ93mpq562mdt5qauetpnbeaurmraZu3mrq5q2mbt5qyjDT6THp81ZTN281dTDVtMqBqZBVDkzV+5Ljb69keRu0U14N9enfmae4fXvmKbuDdDuvdDevdD+vdJpXephXepxXeppXep5XeplWOs1bTWneakrzVlOat5reP8OKT/q81ZTmraY0bzWleaspzVtNw7zVNMxbTcO81TTMW03vn4XEJ33eahrmraZh3moa5q2mYd5qGuetpnHeahrnraZx3mp6/0wdPunzVtM4bzWN81bTOG81jfNW0zRvNU3zVtM0bzVN81bT+2ez8Emft5qmeatpmreapnmraZq3muZ5q2met5rmeatpnrea3j+bhU/6vNU0z1tN87zVNM9bTfO81bTMW03LvNW0zFtNy7zV9P45RHzS562mZd5qWuatpmXealpgqukfOd7AVMgqB6bqVTkwlazKgalOVQ5Mxaly7q4iyWx3Lsnm06Rgoy1hkxGdofOrc7bbUbXXv709vfqVUrZhUK/98xFhblwcStoDDJ+XVoRREV5FmBThVYRZEV5FWBThRYS3z4laEKFVhFcROkV4FaFXhFcRkiK8ilC7k8sItTu5jFC7k6sIb594FsjvTz2Ifj71cDDVrcqBqRRVDkzWrXJgMliVw5EN0j6J3BZ7fjHfr+R5lllWD0kv00pnmZH1kHQ7r3Q3r3Q/r3SaV3qYV3qcV/q81dTPW039vNWU5q2mNG81pXmrKc1bTVlmZD0kfd5qSvNWU5q3mtK81ZTmraZh3moa5q2mYd5qGuatpiwzsh6SPm81DfNW0zBvNQ3zVtMwbzWN81bTOG81jfNW0zhvNWWZkcUivcqBqZBVDkzVq3JgKlmVA1OdqhyYivMlJ91dRZLd5SR3+L47WSw5DkuOx5JDWHIClpyIJSdByclYeSffvbMKbReHEo5yCEvOzTsrmrBfbGI6yIlYchKWnIwlp0DJKQZLjsWS47Dk3JyVz38s1BfCkhOw5EQsOQlLTsaSU5DkkDFYciyWHIclByork4HKymSgsjIZqKxMBiork4HKymSwsrLFysoWKytbrKxssbKyxcrKFisrW6yszHLmNLm3nM7Fbj8X6j7Px9m//mKQbJ5WeZlVOcvx2meU22mVu2mV+2mV07TKw7TK47TKp62hbtoa6qatoX7aGuqnraF+2hrqp62hPEe0GZRXNSh1sapBqXVVDUr9qmpQalJVg1JnvtTQ3bUjbTd22Z9nA+/Kptz7jyFO39mA7LTK3bTK7855YXvS5AId/3bv3tcx7NXJH9Xw7uvXQ7bep7q/i/v6Z/75UQWDJcdiyXFYcjyWHMKSE7DkRCw56V45KexyUrTvi33r2ujdfu2fu+3XVul5XullWunR4Eq3Zh/c+frn+x0++pZu55Xu5pXu55VO80oP80qP80oHrqY96cDV1Jq4S7fOHqQDV9OO9ARdTc+lQ1fTc+nQ1fRcOnQ1PZcOXU3PpUNX03Pp0NX0XDp0NT2XzlBNXXxLj/8yu70uUYYvwXEytreEHb+EG7+EH78EjV8ijF8ijl8ijV9i/O7O43d3Gb+7y/jdXcbv7jJ+d5fxu7uM391l/O4u43d3Gb+7y/DdHTjOMToX3kuk//DFVY8F0+PA9Ph79diS7Hbnkj8ObXzLISw5AUtOxJKTsORkLDkFSo41WHKw8o69fWftT8WdcfEgZ+jOqkvk8Uv8sgPen4TN7nyJZPehVan7S3Lu9SHvr+I6Yz6nqRyv9q+vTb4v9vSho54IDL+d8ZpDvJ1ZvJtZvJ9ZPM0sPswsPs4sPs0sPs8sfuYK62eusH7mCutnrrB+5grrZ66wfuYK62eusH7mCutnrrB+5gpLM1dYmrnC0swVlmausDRzhaWZKyzNXGFp5gpLM1dYmrnChpkrbJi5woaZK2yYucKGmStsmLnChpkrbJi5woaZK2yYucLGmStsnLnCxpkrbJy5wsahFbYuEcYvEccvkcYvkccvUYYvkTiyKNl9idAZt22jpW0m0+vfyf78E08WTZBDE+TRBBGaoIAmKKIJSmiC8u2CStgFOUOnZdnmvM8dfP3b29Or3fsdTm8+xs79+fXIw8WhbPk52vB5acVSFEsDSzaKpYXFKpYWFqdYWli8YmlhIcXSwhIUSwtLVCwtLEmxtLCoy21iUZfbwlLU5TaxyHC5NVYZ1rXGKsOP1lhJUKwynGONVYYdrLHK8Hg1VhnGrca6kBvzJu6/AGI+T/e3bIcNzmx3DpR+golmIT/GC2YhR8YLZiH7xgtmIa/HC4YUTBvMQi6SF8xClpMXzEL+lBfMQmaWF4w63zYYK9f5xrKDyeUIRq7z7YCR63w7YOQ63w6YlXzM+61bb30PTErb74LaVNz5xYn2H0OjeGS4UgEbxrDQprmEfGDoVqp1TzFcqSw+xXClCvoUw5WK7VMMSRleZrjSw6unGKo/vM5wpUdiTzFc6enZUwy1T7nM0Guf8g8YWuO2htmaGI4UtVPhoKi9CgdF7VY4KJJSZKCoHQsHRe1ZOChq18JBUfuWA8UKRpuRNhjSDuMXMNo0/AJGbB9QzP7ldnENMGKtfQ8MTQSGzMfVVf5MNrkhfyZ/2pAPZAyrICCPVQUBeZsvQeH2ROhSfAtK6SBo6BaoS6TxS+TxS5ThS0Qzfgk7fgk3fgk/fgkav0QYvwTH7t7ntyab43GJNH6JPH6JMnwJllGjnSXs+CXc+CX8+CVo/BJh/BLjd3cav7s5Rl86t/06d3IfPrl5cfFxu/Prn7njnyiXveWnYg7+iWNC5XPqOQZJPqjeTq3eTa3eT62eplYfplYfp1afplY/da3NU9faMnWtLVPX2oJda4srb/U+/8+/eCp829zBWLAr/hwMSRleZojtfuZgiO3B5mCI7QTnYIjtR+dgiO2KZ2CYDLY3n4MhdocwB0PtU64z1D7lOkNShpcZap/SHLCcjDYfv4DRjuIXMNom/AJGvX8bjFVD/wsYdem/gFHr/QsYqX6ac4RssqQUGShK9dS8FKUacF6KUt06L0Wp1p6XotQ+gJWik9o08FKU2mHwUpTajvBS1N6FgyIpxcsD/pPT3oWDovYuHBS1d2Gg6MX6RfvI73skL7acPzNkN3EMk1TgfwNcrEl4CrhYP/EUcLHW4yngYp+wPgVc7MPYh4CT+vCbgYt9xPsUcLFPg58Crp3mzcBJgd87ET2R9pq3I9du83bk2m/ejlw7ztuRa895N/KgXeftyLXvvB25dp7XfxgkBW0nOSiSUmSgqG0fB0Xt5K7//E0K2pxxUFy23zr85k0KyzY6x1jjsh1GI9ZZrX1VP6tLrupndadVPXQlDsa+36031h7UQ+ezQJZ29eT9T/UJOkN11d/9d092V0+2dO4cN/+Z0vtNWHLf0mle6WFe6fFB6S59Xlz1JDA9GUxPwdLD8oMl2ex6SkfPq1xu4qnQoXKy/AIJoxyPJYew5AQsORFLTsKSk7HkFCg5LL+E8Rdy7CvT7S3EK81wPshhHBhZrGJpYXGKpYXFK5YWFlIsLSxBsbSwRMXSwpIUSwtLViwtLEWxHLFkoy63iUVdbhOLutwmFhkut8ZKgmKV4UdrrDJMZo1VhnOsscqwgzVWGR7vK1Yrw7jVWBdyY5wzD7NdyI/xglnIkfGCIQXTBrOQ1+MFs5Ax5AWzkIvkBbOQ5eQFs5A/ZQXjFjKzvGDU+f4CRq7zPR33m51c59sBQwqmDUau8+2AWcnHPDMM+yVLGV6cOpb9SrXuKYYrlcWnGK5UQZ9iuFKxfYrhSk+knmK40sOrpxiqP7zOcKVHYg8xpJWenj3FUPuU6wy1T/n3y7PsMmmnwkGRlCIDRe1WOChqv8JBUTsWDoras3BQ1K6FgWLQvuXfW2M7c9Bm5Bcw2mH8Akabhl/AkFQw5+NYcxBr7XtgZnLrhxGlOcxkkxvyZ/KnDflAxvBLUATyWFUQkLepgm6vEOU9bPX1b3sQNHQH1yXy+CXK8CWSGb+EHb+EG7+EH78EjV8ijF8ijl+CYXd7s9md5J09LpHHL1GGL5HN+CUYdrcv+yxeMv784vOJg5lj0imnHI8lh7DkBCw5EUtOwpKTseSUe+VMMkaHY+LqilisYmlhcYqlhcUrlhYWUiwtLEGxtLBExdLCkhRLC0tWLC0s6nIbWIpRl9vEoi63iUWGy62xyrCuNVYSFKsMk1ljleEca6wy7GCNVYbHq7HKMG5fsdqF3BjngKViF/JjvGAWcmS8YBayb7xgSMG0wSxkDHnBLOQiecEsZDl5wSzkT3nBLGRmWcE4db6/gJHrfE/nIRYn1/l2wMh1vh0wpGDaYFbyMc+MFi1+pQL2zMie4leqdU8xXKksPsVwpQr6FMOViu1TDFd6IvUUw5UeXj3FUP3hdYYrPRJ7iuFKT88eYkjap1xnqH3Kv18euFVIOxUOitqrcFAkpchAUfsVDorasXBQ1J6Fg6J2LRwUtW/599Y8xBK0GfkFjHYYv4DRpuEXMGL7gPMJmoVj5uqaYGZy64fhliXMZJMb8mfypw35QMawCgLyWF+CIpC3qYJurxDno0VLHLqD6xJp/BJ5/BJl+BLJjF/Cjl/CjV/Cj1+Cxi8Rxi/BsLtpfzc6kafjEmn8Enn8EmX4EhzTS4Pfjq6m8Pn+YzP1R0u7fYivZX6mfo5Zp7yCHJogjyaI0AQFNEERTVBCE5RvF1TCLsgZYuzFGcfqcExgXRBLMYqlhcUqlhYWp1haWLxiaWEhxdLCEhRLC0tULC0sSbG0sKjLbWJRl3vEEo1Rl9vEIsPl1lhlWNcaqww/WmMlQbHKcI41Vhl2sMYqw+PVWGUYtxrrQm6MceBSNHYhP8YLZiFHxgtmIfvGC2Yhr8cLhhRMG8xCLpIXzEKWkxfMQv6UF8xCZpYXjDrfNhinzvcXMHKd79ngyBcYuc63A0au8+2AIQXTBrOSj3lkBms0fqUC9shsoxfDlWrdUwxXKotPMVypgj7FcKVi+xTDlZ5IPcVwpYdXTzFUf3id4UqPxJ5iuNLTs4cYkvYp1xlqn3J5MtmLonYqHBS1V+GgSEqRgaL2KxwUtWPhoKg9CwdF7Vo4KGrf0hocGU3QZuQXMNph/AJGm4ZfwIjtA05Hjb7AkIJpg5nJrf+cAvqSP5NNbsifyZ825AMZwyoIyGN9CYpA3qYKur1CuBTfglI6CBq6g+sSafwSefwSZfgSyYxfwo5fwo1fwo9fgsYvEcYvwbG743uJlM8vpuLp+2IqlH8mG455rSGGXU42x4jz+CXK8CVY5rV2luDIBDnvS5Rrfxos81cZ5XgsOYQlJ2DJiVhyEpacjCWn3Ctn5M+xMI47Ypl1uiAWq1haWJxiaWHxiqWFhRRLC0tQLC0sUbG0sCTF0sKSFUsLi7rcBhZr1OU2sajLbWKR4XJrrDKsa42VBMUqw2TWWGU4xxqrDDtYY5Xh8WqsMozbV6x2ITfGOe/J2oX8GC+YhRwZL5iF7BsvGFIwbTALGUNeMAu5SF4wC1lOXjAL+VNeMAuZWVYwTp3vL2DkOt/T8YzWyXW+HTBynW8HDCmYNpiVfMwzk06tX6mAPTNByPqVat1TDFcqi08xXKmCPsVwpWL7FMOVnkg9xXClh1dPMVR/eJ3hSo/EnmK40tOzhxiS9inXGWqf8u+X539Z0k6Fg6L2KhwUSSkyUNR+hYOidiwcFLVn4aCoXQsHRe1b/r01ntEGbUZ+AaMdxi9gtGn4BYzYPuB8oKdlmXS6JJiZ3Pph1qYNM9nkhvyZ/GlDPpAxrIKAPNaXoAjkbaqg2ytEseZdsqw9CBq6g+sSafwSefwSZfgSyYxfwo5fwo1fwo9fgsYvEcYvwbC7X63ztkR0jSXS+CXy+CXK8CU4ppemvCXzlIrppP4/T462W//Z+T9TP8esU15BDk2QRxNEaIICmqCIJiihCcq3Cxr2qyOMY3U4JrAuiKUYxdLCYhVLC4tTLC0sXrG0sJBiaWEJiqWFJSqWFpakWFpY1OU2sajLbWBxRl1uE4sMl1tjlWFda6wy/GiNlQTFKsM51lhl2MEaqwyPV2OVYdxqrAu5Mc6BS84u5Md4wSzkyHjBLGTfeMEs5PV4wZCCaYNZyEXyglnIcvKCWcif8oJZyMzyglHn2wbj5Drf0/mIzsl1vh0wcp1vB4xc59sBs5KPeWbUqHMrFbBnRvg4v1Kte4rhSmXxKYYrVdCnGK5UbJ9iSMrwMsOVHl49xVD94XWGKz0Se4rhSk/PnmKofcplhqR9yvUBXI60U+GgqL0KB0XtVjgoklJkoKgdCwdF7Vk4KGrXwkFR+5bmfERH2oy0wQTtMH4Bo03DL2DE9gHnEzVdEGvte2BoIjCHYZcuzGSTG/Jn8qcN+UDGsAoC8lhVEJC3+RIUb68QLsW3oJQOghh2cDb7SznZdgfy+V38+wUect9qIpSaBKUmQ6kpSGo4hrQyqrFQahyUGg+lhqDU3JyLz6YStqxstPsTlhLDzxmGLsW55ae55ee55Zep5WeDLT/RLqSkhnw7t3wHLn8/J/D699GDZz+3fMKRXwUB1dEqCKgyVkFAta4KAqpeVRBQPfoSVIAqTBUEVDOqoPurwAzz4opXLC0spFhaWIJiaWGJiqWFJSmWFpasWFpYimI5YvHGKJYWFqtYWljU5TaxqMttYiHF0sIiw+XWWGVY1xqrDD9aY5VhMmusMpzjV6xWhh2sscrweDVWGcatxrqQG+OcJOg55tuuCWYhR8YLZiH7xgtmIa/HC2YhY8gLZiEXyQrGLWQ5ecEs5E95wSxkZnnBqPP9BQyJBXM6+Nc7uc63A0au8+2Aket8z8H4lXzMMzO0vV+pgD0zm85zzIwVz3ClsvgUw5Uq6FMMVyq2TzFc6YnUUwxXenj1EENSf3id4UqPxJ5iuNLTs6cYap9ynSEpw8uTJT1pp8JBUXsVDorarXBQ1H6Fg6J2LAwUg/YsHBS1a+GgqH1Lc/CvD9qM/AKGFEwbjDYNv4AR2wecj4r2Qay174GZya0fpjj7MJNNPsqPM/nThnwgY1gFAXmsKgjI21RBtyfC8xnanmX6sKNdkKfOxWdTZD3L9GE+NQ5KjYdSQ1BqApSaCKUmQanJUGoKkpp8cy7mnSPss51bvptbvp9bPs0tP2DLPx9C7XMEl386xdnnNLf8jCO/CipgggpQZayCgGpdFQRUvaogoHpUBQFVmCoIqGZUQfdXgRkGrpWkWFpYsmJpYSmK5YiFjFEsLSxWsbSwOMXSwuIVSwsLKZYWlqBYWljU5TaxqMttYlGX28Qiw+V+xWplWNcaqww/WmOVYTJrrDKcY42VBMUqw+PVWGUYtxrrQm6McxQf2YX8GC+YhRwZKxi3kH3jBbOQ1+MFs5Ax5AWzkIvkBUMKpg1mIX/KC2YhM8sLRp3vL2DkOt/Tybnk5DrfczBervPtgJHrfDtgaCEwzwyhJr9SAXtmuBv5lWrdUwxXKosPMaSVKuhTDFcqtk8xXOmJ1FMMV3p49RRDUoaXGa70SOwphis9PXuKofYp1xlqn3J9NCORdioMFIP2KhwUtVvhoKj9CgdF7Vg4KJJSZKCoXQsHRe1bmpNzKWgz8gsY7TB+AaNNQxtMFNsHnM9apijW2vfAzOTWD2OQKc5kkxvyaW75QMawCgLyWFUQkLf5EpRurxDnQ6hp7GjjugSNXyKMXyKOXyKNXyKPX6IMX2LstN66hB2/hBu/BMfuDvvg5BzTcQkav0QYv0QcvwTD7i5hs56p/OsSzVp0OnOQOGaf8goqYII4Zp/yCrJoghyaII8miNAEhdsFzTBWh2MC64pYkmJpYcmKpYWlKJYjlmCMYmlhsYqlhcUplhYWr1haWEixtLCoy21iUZfbxKIut4lFhsutscqwrl+xWhl+tMYqw2TWWGU4xxqrDDtYYyVBscowbjXWhdwY58ClYBfyY7xgFnJkvGAWsm+sYNxCXo8XzELGkBfMQi6SF8xClpMXDCmYNpiFzCwvGHW+v4CR63xP5yMGJ9f5dsDIdb7nYLxc59sBs5KPeWbUaPArFbBnRvgEv1Kte4rhSmXxKYYrVdCHGNJKxfYphis9kXqK4UoPr55iqP7wOkNShpcZrvT07CmG2qdcZ6h9yvUBXIG0U+GgqL0KA8Wg3QoHRe1XOChqx8JBUXsWDoqkFBkoat/SnI8YgjYjv4DRDuMXMNo0/AJGbB9wPlEzRLHWvgdmJrd+GHYZ4kw2uSF/Jn/akE848qsgII9VBQF5myro9gpxPmo0pKE7uC7hxy9B45cI45eI45dI45fI45cow5fIZvwSdvwSHLs7bwkkG2OOS/jxS9D4JcL4Ja7v7td9876EzecXU/HbGFoqlH8mfobJp6xyMpacAiWHYeYpqxyLJcdhyfFYcuheOTZlt/e8KfvM2HszjtFhmLi6JJaoWFpYkmJpYcmKpYWlKJYjlmiMYmlhsYqlhcUplhYWr1haWEixtLCoy21iUZfbxCLD5dZYZVjXGqsMP/oVq5VhMmusMpxjjVWGHayxyvB4NVYSFOtCboxzwFK0C/kxXjALOTJeMAvZN14wC3k9VjBuIWPIC2YhF8kLZiHLyQtmIX/KC4YUTBuMOt9fwMh1vqfzEKOT63w7YOQ63w4Yuc73HIxfycc8M1o0+pUK2DMje6JfqdY9xXClsvgUw5Uq6FMMVyq2DzGklZ5IPcVwpYdXTzFUf3id4UqPxJ5iSMrwMkPtU64z1D7l3y8P3IqknQoHRe1VOChqt8JAMWi/wkFROxYOitqzcFDUroWDIinF1jzEGLQZ+QWMdhi/gNGm4RcwYvuA8wmaMYi19h0wcSa3fhhuGeNMNrkhfyZ/2pAPZAyrIEITBORtqqDbK0Sx5l2yrP0pKA3dwXUJN34JP34JGr9EGL9EHL9EGr9EHr9EGb5ENuOX4Njd++C6bKixhBu/hB+/BI1fgmF3u/3iV51JxyXi+CXS+CXy+CXK8CU4poH2lrDjl3Djl2DY3b7saZBMOr/Y57S/tZ2L/2mIOCZxcsoJWHIilpyEJSdjySlIchLHZEFOORZLjsOSA5WVk4HKyslAZeVkoLJyMlBZORmorJwMVla2WFnZYmVli5WVLVZWtlhZ2WJlZYuVlS1WVrZYWdliZWWHlZUdVlZ2WFnZYWVlh5WVHVZWdlhZ2WFlZYeVlR1WVvZYWdljZWWPlZU9Vlb2WFnZY2Vlj5WVPVZW9ndn5WK3t1h8ceYgp0DJ4TihT/vL45l8/Ly4LmHHL+HGL+HHL0Hjlwjjl4jjl0jjl2DIGsFuZ3Bz+HzXtXUxhf3FWAoufGzTxntp9EpzmwwqHxlg29RlYvEcZ/CeE29nFu9mFu9nFk8ziw8zi48zi08zi5+5wgboClve79FTAf0prhSh6/wcCKHdxhwIoT3PHAihndccCEkRXkUI7ULnQAjthedACO3I50AI3RfMgVC7k6sIk3YnlxFqd3IZoXYnrZ8ZTUlbjjYXUi5NLtoctLmo429zURvf5qLevM1FDXeTSxbqojl/QDFloT6aF6JQJ80LUajt5oVICvE6RKGGnheiUPfPC1Foq8ALUWhfwQtRaBPCCrFox8IAUTuWy79pnYp2LAwQtWNhgEgK8TpEqT7RPvJz9tlILeTDeJ/+pGQ2Umv+U7yl2oOneEt1Ek/xJuV9K2+pT1Sf4i314etTvNV/38tb6iPdp3hLffr7EG+r/eW9vLW/vPdHf7PVDvNu4tpj3k2clPjNxLXPvJu4dpp3E9de827i2m3eTVz7zcu/eZ+dNpEMELUzZICozR4DRO3f/gHEYnYdxTUgkkK8DnHVLovMx9U11FXbm0aoq/YVjVAnNfRV/KTe+Eu8n9STVvHIFTgY+35t3lh7EI+cyQJZ2sWT//kzG5njhyRCpl18KZ8X1yXs+CXc+CX8+CVo/BJh/BJx/BJp/BJ5/BJl+BJh/O4O43d3GL+7w/jdHcbv7jB+d4fxuzuM391h/O4O43d3HL+74/jdHcfv7jh+d8fxuzuO391x/O6O43d3HL+74/jdncbv7jR+d6fxuzuN391p/O5O43d3Gr+70/jdncbv7jR+d+fxuzuP3915/O7O43d3Hr+7OQYfRbd9i/WyAr5zcdluXNz70j/fOPzzS6vwOKvwNKvwPKvwMqlwjuExzwi3swp3swr3swqnWYXPWjnLrJWzzFo5y6yVs0xaOYuZtHIWM2nlLGbSylnMpJWzmEkrZzGTVs5iJq2cxUxaOYuZtHIWM2vltLNWTjtr5bSzVk47a+XkOKX7jPBZK6edtXLaWSunnbVy2lkrp5u1crpZK6ebtXK6WSsnx2GqZ4TPWjndrJXTzVo53ayV081aOf2sldPPWjn9rJXTz1o5/ayV089aOf2sldPPWjn9rJXTz1o5adbKSbNWTpq1ctKslZPj9OkzwmetnDRr5aRZKyfNWjkJt3Im2qYRpGwOwgNu5ewIx62cHeFDZ2nUJWj8EmH8EnH8Emn8Enn8EmX4EtGMX8KOX4LjOFRI+xKRzi+2lMs+2Y6Kef+ka/oW5NEEEZqggCYooglKaIIymqACJojl6DirIIsmCC1Tp9sz9biRmK6U+H2xN/ZDSGskZiib6GgP46oLy8H7BbEExdLCEhVLC0tSLC0sWbG0sBTF0sCSjWJpYbGKpYXFKZYWFnW5TSykWFpY1OU2schwuTVWGda1xirDj9ZYZZjMr1iLDOdYY5VhB2usMjxejVWGcaux0jqxehPzHmvu/TpRcO8fuqB0BLOQH+MFs5Aj4wWzkH3jBbOQ1+MFs5AxZASTjFnIRfKCWchy8oJZyJ/yglnIzPKCIQXTBiPX+cZdR8jlCEau8+2Aket8O2DkOt9zMHYlH2N5fp77eHEi931tonhkuFIBG8aw0PYWewn5yHClWvcUw5XK4lMMV6qgTzFcqdg+xXClJ1IPMXQrPbx6iqH6w+sMV3ok9hTDlZ6ePcWQlOFlhtqn/AOG9pXztotNDEeK2qlwUNRehYOidiscFLVfYaDotWPhoKg9CwdF7Vo4KGrfcqBYwZCCaYPRDuMXMNo0/AJGbB9QzK6juAYYsda+B2Ymt07m4+ov+TSTTW7In8mfNuQDGcMqCMhjVUGEJujuChGMfb/aaKz9KSjcvYMDWdoFkfcHQRx7MtMuqJTPi+sSbvwSfvwSQ+de1yXi+CUYNsTrode2RHKdObvltQe/Ly7JHvYnxzhVTjkFSg7HmFZOORZLjsOS47HkEJaccLOcaPZvM6ON5xeHmLaKGmKhU5fo3ipc+ugw4necUUicSUicWUicRUacyQiJ0wqJ0wmJ0wuJk4TEKcQPJSF+KAnxQ0mIH0pC/FAW4oeyED+UhfihLMQPccyqnSJOIX4oC/FDWYgfykL8UBbih8qcfqhqn9PjVO1z+paqfU4vUrXTxNrn9AxVO7QPSPsrdyG5w3d5Bbq2d7RD1+uOdugafKrdGui62tEOXVc72qHrakc7dF3taJ83v1sDnWcKbePkw+c59W/tFjrPdLQj55nXtZv2aGI6aEfOMz3tyHmmp50m1o7s33vakfN7Tzuyf+9pR/bvPe3IdTU6s704Hp0rP7U75Lra0w5dVzvaoetqRzt0Xe1oh66rHe3QdbWjHbqudrRD19WOdui62tE+cV31E9dVP3Fd9RPXVT9xXeWYfvKY9onrqp+4rvqJ66qfuK76iesqTVxXaeK6ShPXVbr9BG/Y7lzS5wg1862HwPQEMD0RTE8C05PB9BQsPcGA6bk772e/zaopmexRjwPT48H0EJieAKYngulJYHoymJ6Cpef28Tc9PWD5OYLl5wiWnyNYfo5g+TmC5ecIlp8jWH6OYPk5geXnBJafE1h+TmD5OYHl5wSWnxNYfk5g+TmB5ecElp8zWH7OYPk5g+XnDJafM1h+zmD5OYPl5wyWnzNYfs5g+fn2s+Y55F1P7nxXlsv+rPrjvn8OzP/zS2uUVkSUTkSUXkSUJCLKICLKKCLKJCLKLCLKIiBKZyR4H2ckeB9nJHgfZyR4H2dIRJQSvI8zEryPMxK8jzMSvI8zIryPFeF9rAjvY0V4HyvC+9w+S+WZKEV4HyvC+1gR3seK8D5WhPdxIryPE+F9nAjv40R4n9vn3TwTpQjv40R4HyfC+zgR3seJ8D5ehPfxIryPF+F9vAjvc/tMomeixJpO4AgnG1Y9OHmr6sHJMFUPTi6oenB2bdWD01tUPThdQNWD49ernruddcnbxaUUc35xzPvFMZfPSUXHa89/0czdPnXloThvn+byVJxWSJxOSJxeSJwkJM4gJM4oJM4kJE4hfigI8UNRiB+KQvxQFOKH4px+qGqnibXP6Vuq9jm9SNU+p7+o2uf0DFU7tA8obtdevP+pPUHX9o526Hrd0Q5dgzvaoetqRzt0Xe1oh66rHe3QdbWjfeL8npHzTDJE3xcnE47akfNMTztynvnz4xqbdhvMQTtynulpR84zPe3I/r2nHdm/97Qj5/eO9oLs33vakf17Tzt0XX2Vzk27N/GgHbqudrRD19WOdui62tEOXVc72qHrakc7dF3taIeuq6favYGuqx3t0HW1o33euurNvHXVm3nrqjfz1lVv5q2r3sxbV72Zt656M3FdtRPXVTtxXbUT11U7cV29fRIQp/aJ6+rdU3usMXa/tTHucErN3z1h5x8oynCKCpqiu6fM/ANFFk6Rg1Pk4RTR3YqsC7si6zv3tlRc2S6n4vNHPm1cnbPdTsS9/u3t6dWv50Dx++LXowl6C8mNi0NJ39dGGz4vrRSDUmSgGJUiA8WkFBkoZqXIQLEoxesUvVGKDBStUmSg6JQiA0WvFBkoklJkoKi9CwdF7V04KD7buwQ6PB/xGU5RQVNEBk6RhVPk4BR5OEUEp+j+2pjMW1HJnXszTU70FIXEmYTEmYXEWWTEGYyQOK2QOJ2QOAPa953h9szoyttjeBPOL0/FbZ9TKj6d912nU2Z8KFIijUZMpFZMpE5MpF5MpCQm0iAm0igm0iQmUjEeKYrxSEmMR0piPFIS45HSrB6pqqep1c/qZar6Wf1JVT+r56jqZ/URVT26N4hv9cn+VJ/R6/25evQafq4evS6fq0evtefq0WvtuXr0WnuuHr3WnqufOt8X7JyTTd6mUmZTwkE9ds7pqcfOOdnm7WW+/PnV36YeO+f01GPnnJ56bH/fU4/t73vqsfP9uXoy2P6+px7b3/fUg9da77cJFNmHo3rwWttRD15rO+rBa21HPXit7agHr7Ud9eC1tqMevNaeq7fgtbajHrzWdtRPXWvt1LX27hlhzOqnrrV26lprp661dupaa6eutW7qWuumrrVu6lrrpq61989hY1U/da29f+6Yd/Gtnv7l3lVRglOU4RQVNEX3z2nqKrJwihycIg+n6PZa8PoyZFf0MpBHRQFOUYRTlOAUZThFBU3R/bNLuoosnCIHp8jDKYLL2QSXswkuZxNczia4nE1wOTvA5ewAl7MDXM4OcDk7wOXsAJezA1zODnA5O8Dl7ACXsyNczo5wOTvC5ewIl7MjXM6OcDk7wuXsCJezI1zOjnA5O8Hl7ASXsxNczk5wOTvB5ewEl7MTXM5OcDn7/vPkr68Z3opi6tybaWoi3X/y/Jk47z+j/lCcVkicTkicXkicJCTOICROuHd4ytDMWJdw45fw45eg8UuE8UvE8Uuk8Uvk8UuU0UuEsQeI6xIcu3v/2aL8MsadfJPfDUSh9695pG85DkuOx5JDWHIClpyIJSfdLMek/Q3q178pdC+P9n15jMfUkGcPoEweAMuh1kcDsLMH4GYPwM8eAM0eQIAOoJDf5qgU+nPFXsWO14aYtl+GDLHQ6bXn04KDjUqlQQXbMzxFBduIPEUF2908RMVhW6anqGD7sKeoYJu7p6hgO8anqJBSaVBRb9uiot62RUW9bYuKetsWFfW2DSpevW2LinrbFhX1ti0q6m1bVEipNKiot21RUW/boqLetkVFvW2LinrbBhWS4G1rpBL8ao1UggetkUrwlTVSEhOpBP9XI13I0yW7R5pcPkS6kE/rRLqQ9+pEupCfOo80LOSROpEu5JE6kS7kkTqRLuSROpGKqadhodxbaDsHF8ph/niIC+XeTqTr5N5owhZpNB9HOLdI18m9vUjXyb29SElMpOv0p71I16mnvUjX6U97ka7Tn/YiXccjRWe2O0fnys9I0zoeqRfpQh6pE+lCHqkT6UIeqRMpiYl0IY/UiXQhj9SJdCGP1Il0IY/UiVSMR8piPFIW45GyGI+UxXgklrl6c0QqxiNlMR4pi/FIWYxHymI8UhHjkYoYj1TEeKQyq0eq6mlq9bN6maoe3Z9ks6kP7nyPeIrbeyOePkRvkaL7E75I0f0JX6To/oQr0mjQ/QlfpOj+hC9SdH/CFym6P+GLlMREiu57+CKV4pEi+PxozkileKQIPpGaMVLw0dWckYrxSODDsDkjFeORwMdrc0YqxiPBz9bmi1SMR4Kfgc0XqRiPBD+rmi9SMR4JfqY0X6RiPBL87Ge+SMV4JPgZzXyRivFI8LOU+SIV45HgZx7zRSrGI8HPJuaLVIxHgp8hzBepGI8EP+uXL1IxHgl+Ji9fpGI8EvzsXL5IZ/VIVf2svqeqn9XLVPU0tfpZPUdVP6uPqOrBvUEytKlPNp9mV/v6ciVst359/XA+sd3mbLfX1V//9vb0alfKNgXHG/u+858Bc4eLQ9my/Otr2c9LK3Fwj7IgcXCvtB5x9Fm+CxIH944LEgf3uwsSB/foCxInJX4zcfBeaEHi4P3bgsS157ybuPacdxPXnvNm4ujz7gP5/Tkc/fyVqog+7/zXv5eqftYaWtXPWo+q+llze1V/e54sjnb1hWz38v3nRF7/Dv9y+VcA948F5w7Azh6Amz0AP3sANHsAYfYA4uwBJPAAUnoHkPK5Y+b75eh4/5TsSbig+4aHuGR0O/IUF3SX8xQXdPP0FBd0T/YUF1IuTS7oDvIpLujG9Cku6nfbXNTvtrmo321yKep321zU77a5qN9tc1G/2+ZCyqXJRf1um4v63TYX9bttLup321zU77a4JKN+t81F/W6biwy/W2OV4WFrrCQoVhles8Yqwz/WWGV4whrrUj4v2T3W5PIh1qW823msdik/1ol1KY/ViXUp39SJdSnf1ImVBMW6lG/qxCqovrql8vD7zdBQwjHWpfJwJ9aV8nA0Ybs4mpgOsa6Uh3uxrpSHe7Gu1L/2Yl2pf+3FulJ97cW6Uv/aidWv1L/2Yl3JN0VntlOY0blyiHUl39SLdSnf1ImVBMW6lG/qxLqUb+rEupRv6sS6lG/qxLqUbzqPlZbyTZ1YBfkmEuSbSJBvun9C+oOxCvJNJMg3kSDfRIJ8EwnyTUGQbwqCfFMQ5JuCIN90/wToB2Od1zdV/fN6oap/Xn9T9aN7lo/JrCaH871y/ltlKaB7FsZYI7pn4YwV3bNwxoruWThjRfcsnLGSoFjRPQtnrOj+hjNWdC/EGasg3wQ/75oxVvjR2JyxCvJN8AO3OWMV5Jvgx3hzxirIN8EPB+eMVZBvgp8NzhmrIN8EP8ObM1ZBvgl+1jZnrIJ8E/xMbM5YBfkm+NnVnLEK8k3wM6Y5YxXkm+BnQXPGKsg3wc9s5oxVkG+Cn63MGasg3wQ/A5kzVkG+CX5WMWescnxThp8pzBmrHN+U4Wf/csY6r2+q+mly/fP6m6p/Xs9S9c/rQ6r+eb1F1Q/uF6yh/XJrOrnWRlvCdnV05nwCvc0fbHL29vRqV8r2Er039n3nP5IOF4ey5fxow+elX8zRZ+8uyRzcPy3JHNzHLckc3E8uyZyU+e3MwX37kszBe40lmYP3R0syB+/plmSufejtzJ32ofcz1z70fuaE/owu2/czuuN3BOjz2k/+Zqr+eetp1T9vbfrSjz4rvav/7v1rTXRvQbmrP73z2uvf5aCf4+8np11/6el3Pu+CXv8+COIYFlr2rzVzyeH8YmdL2n/s1RmTTjN/5xtTjumfz4mnmcWHmcXHmcWnmcXnmcWXicVzDK18TrydWfzMFTbMXGE5Bj8+J37mChtmrrBh5gobZq6wYeYKG2eusHHmChtnrrBx5grLMabwOfEzV9g4c4WNM1fYOHOFjTNX2DRzhU0zV9g0c4VNM1dYjoF2z4mfucKmmStsmrnCppkrbJq5wuahFbYuYccv4cYv4ccvQeOXCOOXuJ5Fi9mXKObe7ZBmFp9nFl8mFs8wxOlB8XZm8W5m8X5m8TSz+DCz+JkrbJm5wpaZK2yZuMIWM3GFLWbiClvMxBW2mIkrbDETV9hiJq6wxUxcYYuZuMIWM3GFLWbmCmtnrrB25gprZ66wduYKyzC840HxM1dYO3OFtTNXWDtzhbUzV1g3c4V1M1dYN3OFdUMrbF2Cxi8Rxi8Rxy+Rxi+Rxy/BkUXL9gf+6hz8+cU2WtrPJMfXMj//xL1BE2TRBDk0QR5NEKEJCmiCIpqgdLugCUbWFJ8VSwtLUSwNLGQUSwuLVSwtLE6xtLB4xdLCQoqlhSUolhaWqFhaWNTlNrGoy21iUZfbwhJkuNwaqwzrWmOV4UdrrDJMZo2VBMUqww7WWGV4vBqrDONWY13IjXkT8x7r5wDflu2wwZntzuFzOPAGZiE/xgomLuTIeMEsZN94wSzk9XjBLGQMecGQgmmDWchy8oJZyJ/yglnIzPKCUef7Cxi5zjeWHczHD2hsYJJc59sBI9f5dsDIdb4dMCv5mJfsDYz1PTAp+e3OqbjzixNtESaKR4YrFbBhDF9f2m8RfvzI1M5wpVr3EMO8Ull8iuFKFfQphisV26cYrvRE6imGpAwvM1R/eJ3hSo/EnmK40tOzpxhqn3KdofYp/4ChNW4L0Zp4fJmwaKfCQVF7FQ6K2q1wUNR+hYMiKUUGitqzcFDUroWDovYtB4oVjDYjv4DRDqMFJhujTcMvYMT2AS/Z252La4ARa+17YGZy62Q+rq7yaW75M/nThnwgY1gFAXmsKgjI23wJsrcnQpfiW1BKB0EMW8Da/UGtdbEjKJd3QqQjn4glJ2HJyVhyCpQcjqGynHIslhyHJcdjySEsOXdn5ZP5hC1TG+3+rKXEYA/y49zy09zy89zyy9TyvcGWn2gXUlJDvp1bvgOXv58YeP376Ma9n1s+4civgoDqaBUEVBmrIKBaVwUBVa8qCKgefQkioApTBQHVjCro/iqAPznuhcUrlhYWUiwtLEGxtLBExdLCkhRLC0tWLC0sRbE0sASjWFpYrGJpYVGX28SiLreJhRRLC4sMl1tjlWFda6wy/GiNVYbJrLHKcI5fsUYZdrDGKsPj1VhlGLca60JujHGm4AsMKZg2mIUcGS+YhewbL5iFvB4vmIWMIS+YhVwkK5i0kOXkBbOQP+UFs5CZ5QWjzvcXMCQWzNkI4BcYuc63A0au8+2Aket8z8HklXzMI9O0XwxXKmCPTKl7MVyp1j3FcKWy+BTDlSroUwxXKrZPMVzpidRTDFd6ePUQw6L+8DrDlR6JPcVwpadnTzHUPuU6Q1KGV2dMvihqp8JBUXsVDorarXBQ1H6Fg6J2LNcpWqM9CwdF7Vo4KGrf0hwBbI02I7+AIQXTBqNNwy9gxPYB50OjrRFr7XtgZnLrh3nO1sxkk4/y7Uz+tCEfyBhWQUAeqwoC8jZV0O2J8HyatmUZQezLLiiYjqDTMbKWZQQxoxyHJcdjySEsOQFLTsSSk7DkZCw5BUqOvzsrs04Utt7OLd/NLd/PLZ/mlh+w5Z+Po7Y+gss/nedsfZpbfsaRXwUVMEEEVBmrIKBaVwUBVa8qCKgeVUFAFaYKAqoZVdD9VWCC0WuWkmJpYcmKpYWlKJYGlmAUSwuLVSwtLE6xtLB4xdLCQoqlhSUolhYWdblNLOpym1jU5TaxyHC5X7FGGda1xirDj9ZYZZjMGqsM51hjJUGxyvB4NVYZxq3GupAb4xzKZ+NCfowXzEKOjBVMWsi+8YJZyOvxglnIGPKCWchF8oIhBdMGs5A/5QWzkJnlBaPO9xcwcp3v6Qxdm+Q633MwWa7z7YCR63w7YGghMM+Mo7Z5pQL2zJg3m1eqdU8xXKksPsSwrFRBn2K4UrF9iuFKT6SeYrjSw6unGJIyvMxwpUdiTzFc6enZUwy1T7nOUPsUhiGNRTuV6xSd0V6Fg6J2KxwUtV/hoKgdCwdFUooMFLVr4aCofUtzhq4z2oz8AkY7jF/AaNPQBmPF9gHnU5edFWvte2BmcuuHgcjOzmSTG/JpbvlAxrAKAvJYVRCQt/kSdPv05844ascy4Ti6XVDyHUGnc1gdy4RjRjkBS07EkpOw5GQsOQVKDsuEY0Y5FkuOw5Jzd1ZmHcnrPM0tP8wtP84tP80tP2PLPx9H7XwBl386z9mRmVu+xZFfBTk0QUCVsQoCqnVVEFD1qoKA6lEVBFRhqiCgmlEF3V8FJhi95oJRLC0sVrG0sDjF0sLiFUsLCymWFpagWFpYomJpYUmKpYUlK5YWFnW5LSxRXW4Ti7rcJhYZLrfGKsO61lhJUKwyTGaNVYZzrLHKsIM1Vhker8Yqw7h9xZoWcmOcQ/lcWsiP8YJZyJHxglnIvvGCIQXTBrOQMeQFs5CL5AWzkOXkBbOQP+UFs5CZZQWT1fn+Akau8z2doeuyXOfbASPX+XbAkIJpg1nJxzwzjtqVlQrYM2PeXFmp1j3FcKWy+BTDlSroUwxXKrZPMVzpidRTDFd6ePUUQ/WH1xmu9EjsKYYrPT17hqE32qdcZ6h9yvUhjd5op8JBUXsVDoqkFBkoar/CQVE7Fg6K2rNwUNSuhYOi9i3NGbreajPyCxjtMH4Bo03DL2DE9gHnU5c9y9zfJcHM5NYPA5G9nckmN+TP5E8b8oGMYRUE5LG+BDkgb1MF3V4hzsdR+7ETjusSafwSefwSZfgSLBODy+ZQijPhP3xx1WPB9DgwPR5MD4HpCWB6IpieBKYng+kpWHoILD/TzfnZmeS31uf1bwo/zQQ5NEEeTRChCQpogiKaoIQmKKMJKo8Kiu6noODQBN2eh7INu6Ds4kEQoQkKaIIimqCEJiijCSpggqJBE3S3Y7Rm/+20178p/8/TB55U3P60nIrvXP3QAD4fnUK8DtErxOsQSSFehxgU4nWIUSFeh5gU4nWIWSFeh1gU4mWIySjE6xC1Y2GAqB0LA0TtWBggoj1Vy7cnaZfc/qm6cnhUnIcmvLqEG7+EH78E2hPjDPe3jfbEOKM9Mc5oT4wL2hPjYtEEOTRBaN/tsUz9YRWElqkLWqYuaJm6oGXqApapyYBlajJgmZrM7Zm62LgLerVD502NTbt6Z9JBvEcWb3N5HysiOoi/vQIUk9/ivT0Iuj2/lf2k3uvf5fjxZjRBBUyQNWiCLJoghybIowkiNEHg3/Xm/d6vZ3jHomTBv2XtyQf/frMnH/ybxZ588O/0OvId+LdpPfng32P15IN/g9STD/7dTU8+zS1/7qrr5q66bu6q6+auuk7fpLn8rTF5fZOGAaK+ScMAUd+kYYCob9IwQCSFeB2ivvvPAFHf/WeAqO/+HyFWMvpC/29ktLf4hQxpw/AbGe0CfiOj1v43MurXfyNDSuYXMmKdNecvjxOJ9da8GMW6a16MYq04L0axvp0VYxBr8nkxiu0IeDGKbR94MYrtNXgxkmLkwKhdDAtG7WL+Gca46wi5HDFqF8OCUbsYFozaxXBglDtNctxvQSbaRmwkikficou6feS32knudMDHiMu1Ck8Rl+sqniIu14A8RFzuRMPHiMt9OPsUcfXjdxOX+8j3KeKkxG8mrj3n3cS152Qnbo3bHqxYE48vsSftOu9nrn3n/cy187ydedbe837m2n3ez1z7z/uZawd6P3NS5teYV4zaWLJg1G6RBaM2gCwYtaf7RxiL2XUU18CobRoHxrJu50Xm4+oa7LotTyPYdXuNRrDTmvwqn+aWP61PrfKxK3Iw9v0CvrE/5+8Hg53VAlna5ZP3B/nYeaor//6//fQhv+SDoNtt+u8/ete4NW15vMQP61KlW7Df6wu3/wpAVxB2pu2lKvAp61352D1HTz74lPWufPA615MPXud68rEddlc+zS1/7rwPPmX95Zn8W37x51cXm/Ze9KUqHILFfk7KHCx6RWcNFr3+cwYLPpedOVh0b8EaLLoTYQ0W3bewBktLBRvPg0X3RKzBruWgOsGu5aA6wa7loGLag3XGHIJdy0FFcxYs+KBq5mDXclCdYNdyUJ1g13JQ4eN9CHPIxuBDn5mDXctBdYJdy0F1gp3WQVX503qiKn9al/MlH3z2brD0/kbexsN3pOAzb7vywb1FTz64W+jJp7nlg1f0nnzwGt2TD151e/LBq25PPnjV7ciPc1fdOHfVBZ/U2ZU/d9WNc1dd8KGjXfngVdd9yHchnV7tbNoGxzh3+MX2AD46869Ctbm8nwEQ/QwVfJ7f6xut9ytDPp1f/T5Sl/LHzN/vQMFzX+cFcvB5XV354LmvJx88IXTk6+CU/3zvgPGgY1P4iReTdh4N4tgJckXiOnfibuI6ouJu4jrN4m7iOvji3jGpQWdk3E184XEaqMTVj/MTj1sHVFI4EtchhncT1xGGdxMnJT4wj7eIa895d+XUnvNu4tpz3k1ce867iWvPeS/xaLTnvJu49px3E9ee827i2nPeTZyU+M3Etee8m7h2QDcTZ5mp+X5WZpM/v/h1bYrbrV///vkKZrQeTRChCQpogiKaoIQmKKMJKmCCHFoeYhknyirI3S3I77Xx9e9QzqtdZ/ZUdH5u+TS3/DC3/Di3/DS3/Dy3/DK1fG/A5cdz+XZu+ehVtyMfvep25KNX3dNxdtGjV93TyV7Ro1fdjnz0qtuRj151O/LRq+7phKxI6FW3Ix+96nbko1fdjnygqlsFAdXRKgioMlZBt9e6j6O7rz8YdxCU0ARlNEEFTFAwaIIsmiCHJsijCSI0QQFNEFqmDmiZOqBl6oCWqSNapo63Z+qwX/36dzo3vM7YfWqS6b32UErcrz38EnOMDjnQnvjbc2FK7z+b1Pnt1LMpSDFmHOlfgpLB+UOogoC2YBUEtFWqoNvNUvxo2l5e7SCI0AQFNEERTVBCE5TBBGUDlqnz7du+uP31xli8PQgiNEG3b/sSw1tQPv4NRTRBCU1QRhNUwAQVgybIoglyaII8miBCE4SWqQtapi5ombqgZeoClqmTAcvUyYBl6mTAMnUyYJk6GbBMnQxYpk4GLFMnA5apkwHL1MmgZWqLlqktWqa2aJnaomVqi5apLVqmtmiZ2qJlaouWGO8/3GbLW9Dru74PQY2rZ/jpgXT/CbsZGZ4OoU73HzRbkGFShpcZZmV4mWFRhlcZ3n/4cEqGZyNW0v0nIBdkqP7wOkP1h1cHf6f7D6QuyDAow8sMtU+5OlI+ee1TrtcU7VOuM9Q+5TJD0j7lOkPtU64z1D7lOkPtU64zJGV4maH2KdcZap9ynaH2KdcZqse+zJBleMN+9qnYP1ecMzyfiJtYRhOwCopoghKaoIwmqIAJYhlNwCrIoglCy0PRowmiuwVxTrxNMcwtP84tP80tP88tv0wtP5m55du55Ttw+fFcvp9bPnrV7chHr7od+ehV93RUeEroVfd02nNK6FW3Ix+96p7Lz+hVtyMfveqeTntOGb3qduSjV92OfPSq25EPVHWrIKA6WgUBVcYq6PZadz48NOUCJqgYNEEWTZBDE+TRBBGaoIAmKKIJSmiC0DJ1AcvU2YBl6mzAMnU2YJk6m9sz9TOjwrMh5EB74m/PhVyjwrM1ONKrIIfzh1AFAW3BKghoq1RBt5ul86nK2UY0QQlNUEYTVMAEOYMmyIFlanf7tj+fzJ1dRBN0+7Y/n7yUXUYTVMAEeYMmyKIJcmiCPJogQhMU0ARFNEFomdqjZWqPlqkJLVMTWqYmtExNaJma0DI1oWVqQsvUhJapCS1TE1qmDmiZOqBl6oCWqQNapg5omTqgZeqAlqkDWqYOaJk6oGXqiJYY7z/cttyo8Hz/CbvlRuPm+w+aLciwKMOrDO8/crcgQ6sMLzN0yvDiiJV8/wnIBRmSMrzMUP3h1RHN+f4DqQsyTMrwMkPtU66OCs9J+5TLNSVrn3KdofYp1xlqn3KdofYp1xmSMrzMUPuU6wy1T7nOUPuU6wy1T7nOUPuUywyLeuzrDImB4X6QuNjPrxvaDM8n4maW0QSsgjKaoIIlqLCMJmAVZNEEOTRBHk0QWB4qJqAJincL4px4W0yaW36eW36ZWr41c8u3c8t3c8v3c8sncPnxXH6YWz561e3IR6+6HfnoVfd0VHix6FX3dNpzcehVtyMfvep25KNX3Y589Kp7Ou25OPSq25GPXnU78tGrbkc+UNWtgoDqaBUEVBm/BPnba9358NDiLZoghybIowkiNEEBTVBEE5TQBGU0QQVMEKFlakLL1ISWqQktUxNapqbbM/Uzo8ILReRAe+Jvz4Vco8JLcDjSqyDC+UOogoC2YBUEtFWqoNvN0vlU5RIymqACJigaNEEWTZBDE0RgmTrevu3PJ3OXmNEE3b7tzycvlWTQBFk0QQ5NkEcTRGiCApqgiCYooQnKaILQMnVGy9QZLVNntEyd0TJ1RsvUGS1TZ7RMndEydUbL1BktUxe0TF3QMnVBy9QFLVMXtExd0DJ1QcvUBS1TF7RMXbAydTEGK1O/BGFl6pcgrMT4EnT7tl9tVPiLYVKG10bjFnP/QbMFGVpleJmhU4aXGXpleJkhKcNrI1ZeDIMyvMxQ/eF1huoPL45ofjHMyvAyw6IMrzJ02qdcHBX+Yqh9yuWa4rRPuc5Q+5TrDEkZXmaofcp1htqnXGeofcp1htqnXGeofcplhl77lOsMtU+5zlA99nWGDN7GlP2phjW+x/B0Iu5LUAETxDGagFeQRRPk0AR5NEGEJiigCULLQ5TQBOW7BTFOvH3JL1PLD2Zu+XZu+W5u+X5u+TS3/DC3/AguP57LT3PLR6+6HfnoVfdcfkSvumejwl/y0avu2bTnl3z0qtuRj151O/LRq25HPnrVPZv2/JKPXnU78tGrbkc+etXtyAequl+CElAdrYKAKmMVdHutOx0e+hLk0QQRmqCAJiiiCUpogjKaoAImKBs0QRZNEFqmzmiZOqNl6oyWqTNaps63Z+pHRoW/As3IgXbEl9tzIdOo8NeqhCO9Coo4fwhVENAWrIKAtkoVdLtZOp2q/LqBQRNk0QQ5NEEeTRChCYpYmdqa27f96WTuYq1BE3T7tj+fvGStQxPk0QQRmqCAJiiiCUpogjKaoAImyBk0QWiZ2qFlaoeWqR1apnZomdqhZWqHlqkdWqZ2aJnao2Vqj5apPVqm9miZ2qNlao+WqT1apvZomdqjZWqPlqkJLVMTWqYmtExNaJma0BLj/YfblhsVbu8/YbfcaFx7/0GzBRl6ZXiZISnDywyDMrzMMCrDiyNW7P0nIBdkqP7wOkP1h1dHNNv7D6QuyNAqw8sMtU+5OircRu1TLteU+w8pL8hQ+5TrDLVPuc5Q+5TrDLVPuc5Q+5TLDJP2KdcZap9ynaH2KdcZap9ynaF67OsMr3ubnPImPaeSOgydzzuV179/nke0DMMb/lIQ2f3oliP/c0SvZRjewCzIoglyaII8miBCExTQBEU0QQlNUEYThJapC1qmLmiZuqBl6oKWqQtapi73Z+pAb0ExndpW9zLh3xc7Z47iI7L4VwZ7T3wkOoi/Pb+FsLcXLsTzkTw5m22qzavR+Bcdf9Q7Y6ZWb7HV781azs4f1bup1Xvwv5zwVk9H9bennFD2W7to8o808sqKaIJuN5LRu7egj5fcN0EFTJA1aIIsmqDbM1x8/6iAi/koyKMJIjRBAU1QRBOU0ARlNEEFTJAzaIIsmiC0TO3QMrVDy9QOLVM7tEzt0DK1Q8vUDi1Te7RM7dEytUfL1B4tU3u0TO3RMrVHy9QeLVN7tEzt0TI1oWVqQsvUhJapCS1TE1piJI5t78ouiHqCrHnPXbcm297l6f2y2Ovf5aC/oOun8tYff86CccFMrt9Ort9Nrt9Prp8m1x8m1x8n158m1w9ffzv6J6+/cfL6Gyevv3Hy+hsnr78MZ9qf1Q9ff7N56y+f+o9Xn7816CJ8rf6LWM9fMnQRva7k8qGkdH5p73XD+L55+Zebf4Wb0MtQTumtJP/8EXCX0MtQTz96GSofj0HK4Sc1XUIvQz396GWopx+9DPX0o5eWnn70NrCnH70N7OlHL9cd/Rm9/vb0o9ffnv7J62+evP6yHMR9Uv/k9TdPXn/z5PU3T15/8+T1t0xef8vk9bdMXn/L5PWX5Xj1k/onr79l8vpbJq+/ZfL6W+auv97MXX+9mbv+ejN3/fVm7vrrzdz1y5u786cpbh8oYgr19JucdyWvfx/1F3D9xZj35fbn19Deusn1+8n10+T6w+T64+T60+T60fN/T//k+d+ZyfVbdP30cXn8fH/jeDXZspklcvatJH7HCl+rGWOFr+uMsZKgWOH9AmOs8N6CMVZ4H8IYK7xnYYwV3N9YYz5eULXxNNY/N4zvm4fD66zeg9sha94frTXhfLJiituPCqT0BkPuO1Rw58QZKrhx4gwV3DdxhkpyQgV3TZyhgpsmzlDBPRNnqOCWiTNUeMfEFiqt5JZstLR/VRVfMZxfXaLdvwd7eWz788EUrWSvuNms5Me42axk4LjZkLL5lc1KFvFv2STaoyypwWYlT/nXbN5ztEpK6cBmJRPKzWYl13rGpka7knHtRhukeNcarRQ3WqOV4i9rtFIcY42WREUrxdXVaBfzacN+XNqVsn2P5Y39+M2s1u9Fh7JNEIk2fF5amS/m/6ZgvpivnIL5Yu52BuZxMY89BfPFnP4UzBfrN6ZgvljXMwVzUuZXmVeQi7V1z4HUjpEJpLaBTCC1t2MCqQ0bD8ikXRgTSG2tmEBqv/TPQHqzf0Ht/2XWQsu72+D2o5LhE8lGXTumJ6iTUn+AujZYT1DXbuwJ6tq6PUFd+7wnqGtT+AD1rB3kE9S13XyCuvamT1DX3nQI9bj/VFnI5UidlPoD1LU3fYK69qZPUFe//g+pv5hs1K3vUU9pO5ZtU3HnFyfazg0miocPqKjdefoDKrRpLh/x7R+QOiPwD4j0A8L+gNRvgX9Aas3APyD9hgH8A9IvI8A/IO2DoD8gMvoVB/gHpN+GgH9A+iQB/APSJwlPf0DWuH2Il4nh+BGRfkToH5E+TYD/iPR5AvxHpE8U4D8ifaYA/xHpUwX0j8jqcwX4j0ifLNz7EVXq+rjgCer6DOAJ6qTUH6CunfoI6sXsb/wV16CuzfcT1LWf/qZO5uPqykYb2d/ZaAf5Kxv0n8ZmY1OjldIF1WildB812rWckEvxHe3hVzsI/ydrf432S/9Sv1ba/bSW+mnLfrRrueNetGu50l60a/nMXrRrOcdOtIv90mUv2rW8YC9aUfV2sd+X7EVLS0Xr/f4UKPpQzq8uNr1/3e7VIRzYrOW8eNms5dN42azl6njZrOUBedms5RhZ2Sz2a5S8bNZyo7xs1vKuf8kmnrNZy+nysiFl8ysb0b64w0a0L45pZ+PM4fvCxX5J82/ZmFM2on1xh41oX3zOZrFfkORlI9oXh4/3ocyhTi32i4y8bET74g4bEsKmRivF6dZopXjXGu1abpTsfnUk7w7RruUve9Gu5Rg70S72+3W9aNdydb1o1/JpvWjXcl69aElUtGt5qV60a3mpXrSivNRiv2zVi1aUl1rsl5x60YryUov9clGI+9SGGNL5cx1n7HYAxhnfufP7x4mdOZ76WuyXiP6GYo/MWjU/pfdu+jw+3rr6fdI85Y/f0PjmslYF+Z3LV7RlrZz6+/6o0UrJqTVaKbmvRktLRRs/ngfH4A/RrtWf9qJdq1b1ol2rP+1Fu1Z/2ot2LXdxHm1YbMr7uZcKZq0KVNw+jymWf5l+U6NdqwL1ol2rApX4njBR8nHfrlWBetGuVYF60a5VgTrRLjawtRftWvW2F+1a3Xwv2rW6+V60JCraxbxUJ1pRXmqxWY69aEV5qcXmLXaiXWyCYi9aUV5qsQmKvWhFeSlHoqIV5aWcKC/lRHkpJ8pLTTzn9T8QrRflpbwoL7XYxN9etKK8lCdR0YryUotNc+5FK8pLLTbNuRPtYvONe9Hqr6B9Xf3gjzIm2t7NTBQ/L60f0FpFc8YPqJjtxsU1PiD9vSnwD0h/9Ar8A9Jf3sL+gBYbybvgB6S/2/z4B0Sb5vIR3/4B6U88g39A2geBf0CkH9DTH9B+iLCkcPyA9DemwT8g/Tlq8A9InyQA1aDWB6RPEsBNgj5JwP6AFhtivuAHpE8SwD8gfZIA/gHpkwTwD4j0A8L+gPRJAvgHpE8SwD8gfZIA/gHpkwTsD2ixX1pY8AMCt9kmpbhfnvL5BxTSDjEk93ltjZUExQpu/lhjBfdRrLGCWxLWWMGrO2us4I/cOWNF/8kA1ljBHwSzxgr+TJU1VkG+KZOgWAX5JvSfX2CNVZBvyoJ8E/pPZfxlrBT3WDs/POxs2n+gxpn0k0tZy2P9cy42l/fvMRMduCxVt8ubS+k8vHo9r9qeGUXnyoELKZcml6X8wN9wyWHTEXN6y4jfXJbyDoxclvIZjFyW8iR/w6WYrU7H4tKBy1L+hY1LNEv5F0YuSz1PYuSy1LMnRi5i/W6HCymXJhexfrfDRazf7XAR63c7XNTvtrmo321yQf+RoMe4qN9tc1G/2+aifrfNhcRy2d/wjCUcucj1u+dc5Prdcy5y/e45F7l+95yLXL97ygX9p42YuNRYb6+9yfu3eArnl/+ZXvx99Z85uQf1AVz9exhM+Bg2sqnPU6svM6u//wdGWNXbqdW7qdX7qdWj5/tz9VPn+/t/QINVfcJW//oaZFMfXTr1RGTLdvqRnD34Pw9elxkjBa/hfJESeL1njBTcGzBGCu4jGCMF9xyMkZKYSMG9TIz7OPqY42mkr9uF9wOMz7fgX7euwYJbn78LNtr3rWM8BgvulJLZPqyS7PnToxS3G7+eOe1XkvsOFNwo8QUK7pPYAg3gNokvUHCXxBcouEniCxTcI/EFSlICBXdIfIGCuyO+QNdxRjZa2kdovb56Px+hZf+8FbVd/af6/Hy6FtaxUtxk1vFezGTiOmaNm8w67o6bzDp28G/JJNpjLKlBZh3/+NdkYn6TSelAhpTML2TWcahnZGqs65jUfqwyfGqNVYbzrLHK8JJfsSYZ7rDGKsPv1VhlOLga61KebNiAblfK9q2kN/Z95+bM7VC2r7qiPfz+Xbx/DrV44kt5yCmIL+VkpyC+lJ+egvhSrn4K4kv1FjMQz0t1OFMQX6rPeoJ4xbhUC/ccRu0OWTCSYuTAqH0cC0ZtzlgwasfFglHbKBaM2hv9E4ze7F83e5N7P7QYnNnuHD6BfDMv2h3dz1z7o/uZazN1P3PtvO5nTsr8duba093PXBvA+5lrt3g/c20t72eufejdzJPRPnQA87j/kGDI5chc+9D7mWsfej9z7UPvZ67+/B8xt/tvA3vre8xT2kNMxZ1fnGg74ZcoHj8etTjPfjyFNs2f45a3j8eqG4L+eNQ4QX886rGgPx61Y9AfD+nHg/zx6JcN0B+P9j3QH49+hQH98ei3HdAfjz41QP54nD41ePbjscbtY7VMDMcPSJ8bgH9A+uQA/APSZwfgHxDpB4T9AenzA/APSJ8ggH9A+gwB/APSpwh3fkCVuT4auJ05+q/TLslcW/j7mWtXzs+8mP39veIazLXRvp85KfM//ybzcXUlo03rb2S0W/yNjIw2rcYqo+OpscroNL5iRf/t4r+K1aX4jvXwKxkJ/cdff421ql/pr7LzSS30Y5H9WFfywb1YSVCsKznKXqwrecRerCu5vl6sK7m+XqyC6utSv9jYi3Wl56ne7893og/l/Opi0/tX4159wIHMSi6Ll8xKnoyXDCmZX8is5Pd4yazkDnnJrOQlecms5Dx5yazkU/+STDwls9QvTfKSEeyBO2QEe+AOGcEeOKadjDOH7/2W+m3KvyVjTskI9sAdMoI9cIeMYA/cISPYA4eP95jMsTYJ9sDnZJb6LUJeMjI8cI1VhqutscrwqTVWWihWsrTHSt4dYl3JS/ZiXckd9mJdye/1Yl3JwfViXcmTdWJd6jfNerGu5Jt6sa7km3qxruSberGSoFgF+aalfqOpF6sg37TUbxL1Yl3JN4W4z02IIZ0/sXHGbkdTnPGdO79/2NeZw0msvNRv+/wNwx6XlWr863u3ncvnIe7W1e/z3q/e+i3im8pKVeN3KjXWlTLp7zujxiojk37FutTvd/RiXakDjR9PeGPwh1hX6kB7sa5UnXqxkqBYV+pAe7Gu5CV6sa7kJTq+aalBysXtt47lX+bN1FhXqjm9WFeqOSW+ZzuUfNivS03K7cW6Us3pxbpSzenFutJTz16sK9XXXqwr9eqdWJeaotmLdSnf1Il1Kd/UiVWQb1pqSmIvVkG+aalJhr1YBfmmpWYT9mIV5JtIkG8iQb5pqZmTvVgF+SYiQbEK8k3Tzk39j8QqyDeRIN+01PTcTqxBkG8KgnzTUlORe7EK8k1LTUXuxSrINy01KbgT61ITZWf8ycJE2zuUieLnpfXj0R8Ve/bjKWa7cXGNj2elCrDgx6M/DgX98egvVEF/PPprxtAfj/6W8cMfD22aS8jHj0d/9hj541lq5vCCH4/2PQ9/PPvRvpLC8ePR312G/nj0J5qhPx7Sjwel9rQ+Hn1qAG0N9KkB9MejTw2gPx59agD98ehTA+SPZ6kp7Qt+PPrUAPrj0acG0B+PPjWA/nhIPx7kj0efGkB/PNqWIn886IP5yW8MX3GYU4Qh7QhDcp8fZY0U3KMyRgpu9xgjBXdOjJGSmEjB6zljpOAP1BkjBTcBjJGCP+ZljBT8iSlbpAV9WD5jpFI8UjFSPFJB/0kDxkhJTKRSPFJB/+mJv4qU4h5p58d5nU37T704kw5UVvJT/5yKfZmOTUUh+kkF/Sce/oZKeVP5fGzTuvb1JGpTEZ0rByoL1XRGKgvV/7+hksP2uDPm9H7MGL+pLOQVGKmQUmlQWciD/A2Vl/naqBSXDlQW8iuMVBbyK4xUFnpWxEhloedKfFScUG/boSLU23aoCPW2HSpCvW2HCimVBhX1ti0q6m1bVNTbtqiot21RUW/boIL+cz8PUZHqbWl/6lTCkYpUb3tORaq3PadCSqVBRaq3Paci1dueU5Hg4r4iZfk5GeP2SJ3vRepd3CP19C/3roocnCIPp4jgFAU4RRFOUYJTlOEUldsVhQ9F6agoODhFHk4RwSkKcIoinKIEpyjDKYLLRyw/oPB3it5vHxqy5fzy1wWbNyVnD8462qnVu6nVeyD1VRHBKQpwiiKcogSnKMMpKmiKElLdqIpurwXk37WVYuehTC6bjvJxZ+f+5tIapxMSpxcSJwmJMwiJMwqJMwmJMwuJs6wS5+sLku9LUzaHOLMREucyfqgTJ5JPqIpurwDuPVHLeNP5vi+9HvpsPEv6HKhV1aep1eep1ZeZ1RcztXo7tXo3tXo/tXqaWn2YWv3UtbZMXWsLeq3N+ztTxrgP9cdrO5NCCnpd/ueRnk7/sMYY7EKSTaY91BJOQ81+fw0u+58vq/0JFbvqsIaKXaL+JtTTgQp/QsWuZ6yhYhc/1lCxK+VfhXp2YuVPqNhllTVU7LrKGarFbo5ZQ8XupFlDXcctdUNdxy11Q6WFQj05mvIn1IXcUi/UhdxSL9SV3FIn1JXcUifUldzSeahuVgvxLf/2AvIyXbt84/5F/rekgCcp4klKeJIynqQCJ8kbPEkWT9Lt7Yrx77d2TfANSQFPUsSTlPAkZTxJBU4SGTxJFk8SXl66/5i+SfktqcTzy08PZ/2RT3PLD3PLj0DyvyUlPEkZT1KBkxQMniSLJ8nhSUKqIN+Sbq8K1r0fq1jfubelXPbBRVR+vofzJ4AwewBx9gDS7AHk2QMokwdw/8wJ7gDs7AG42QPwswcweyWO6JW47BMTX//25wMcbc52t045e3t6tStlOwDmjX2/QvvnvcvDxaFsh9eiDZ+XfmNE9wOTYER3JZNgRPdGk2BEd2hzYEzoPnESjOhudRKM6J55Eozozv0RjN9sSNn8ykb7jd/ZaBPxOxvtDH5no3b/dzbq4X9lk9WY/85Grtv2r+cHO5tsz22iDW6bLWDD5y+a7CDl+m1mkHIdNzNIUpA8IOV6eWaQco0/M0i5XQIzSLktBTNIuf0HL8git1lhBqmdDRNI7Wz+Ici46wi5NEBqZ8MEkhQkD0jtbJhACvaRryg3kNb3QKa0v6eXiju/ONEGJFE8MH/9P2XOzrzQFuLn7yW/mQv2Ao8xF2wbHmNOyvx25oLNyGPMBT+RfYy54Ie3jzFXf34/c8GPhJ9ibgU/PX6Mufah9zPXPpSf+au7d3uMMTSoayf6BHVS6g9Q1270Cerajz5BXTvSJ6hrT/oEde1KH6DutC+9Sv0bpDabTCC1g2QCqU0hE0hSkP8IZDHvnwR1LZDaujGBXLgbI/Nx9Xe4C7dBrXAX7j9a4c5r/GsAfl4P/R3AvN71OwDwCh1eX7pul7/+bY8BgGe4QJb2AMj7YwDP5qxAn5d/SypwksjgSbJ4khyeJI8nifAkBTxJ9zvlZN6SSu7cu2w6ysed/1j+f37pd6BJSqBZSqBFSKD3/zLJU4FaKYE6KYF6KYHSKoEm2h7EpWwagQYpgS7jjHqBLuOMeoEiGYYqCf0HQroPZtB/nqIfAPhXBf0A0B+NdQMAf5zfDwD8AX03APQfAOgHAP6Avh/A7HUAfdx8MO+XGIIpnw/oW98v2/cvPBZbwjFckhUufJXnDRfeE/CGC+8geMOF9xu84cK7E9Zw0Wemc4cL73z+LtzYCRfeJ/GGu5ir6oVLssJdzFXFtIfrjDmGu5iriuY83MVcVS/cxVxVL9zFXFUnXPThzn8bbvh4f9wcMzP6CGbucBdzVb1w53VV3wHQ7AHM63y+A0D3Mpbe7yO/vmU8BoDuTroBoPuNbgDoDqITwMsmzB4AepXvBoBet7sBoFfibgDolbgbAHol7gYweSV26FNV+wFMXokd+rzPbgDowzP7AcxeidHHOgb3EYAL6bSDdq/v+78vdq/0dAwWvWr/TbCvJ3nvpwVEx2DR64t/P7oLPp0fNn9P8kj544dJtlDR82DnkK1DH9bUDwA9jXQD0Akm//nmnxNyKw87eW6Ms9luXFyLuQ7ju535xGNE5mWuU/vuZ64D/u5nrrMABzA//SkEhz6UaEnm6s/vZ67+fADzuAEpKTSY62D4+5nrWPj7mWsfOjSft5iT9qG311DSPvR+5tqH3s9c+9D7mZMyv5259qH3M9c+9H7m2ofez1z70PuZax96O/Ogfej9zLUnup/5zV6xlLw/cyvFnF8cy/4DgrE0Xoi6e4oor/g0s/g8s/gysfhoZhZvZxbvZhbvZxZPM4ufucLGmStsxK6wwe7iI526w96ZkYhdjf95oL3zIgm5fiSzn4xJJpzP0cjebxY++5CPgSLXGtZAkevS3wQac9iujTm9O7i4BYpcw1gDRa53rIEi18a/CrSYsGdol46BItdR1kCR6yhroMgdMGegGblbZg10FWfUDXQVZ9QNdBlnVPZrX71AI1CSEugyzqgX6DrOqBPoOs6oE+g6zug80DKnYfgWf3fJSPujnZJi+Lz4WxChCQpogiKaoIQmKKMJKliC/N2zIvuC7m5GUiq7oBIbgghNUEATFNEEJTRBGU1QARNkDZogtDx09yS7kv02v6xksucX+1ep/b7Ye0s/rbG/ezIdr3hCFu9j2cXnz6bkeC3ZPVB6fS98DDRICTRKCTRJCTRLCbQICfTumZHPBWqlBIrjYL4F4biSb0GEJgjHEXwLwqnc34JwKuy3IJxK+C0Ip2JVQf72yhLyLijHzp3L/nzs477O/c2l32FaGWE6GWF6GWGSjDCDjDCjjDCTjDDzGmEm2s7LpmwaYRYRYdIiLqgX5iIuqBcmjj34FnR36o/7K5El2g73kPYj8yG5w8kSf/d0GF7xeWbxZWLxdw/+4BVvZxbvZhbvZxZPM4sPM4ufucKGmStsmLnChpkrbJy5wsaZK2zErrAUd/GhfIg/XtsZiOAjdjX+54F2BiL4CF0/yjvQEs7HpUVntjkB0blyDBS61nAGCl2X/ibQ8+PzPkLXMMZAE3S94wwUujb+TaDnR3N9gq6jnIFC11HOQElKoNDdMmegyzijXqDLOKNeoMs4o16gyzijTqB5GWfUC1SKM8pSnFGW4oxun87yWKBSnFGW4ozyOs7odGiJz+s4o06g6zij80DLOs6oE+g6zqgT6DrOqBMoTRnot3iGkhHC9iVcDh/zrpsX22DsdtDlz7/tT0XEMdyFWZGFU+TgFHk4RQSnKMApinCK8PJRvl3R+9euginn4/1ssWn/1a1iSzjqL3Prt2Zy/XZy/W5y/X5y/TS5/jC5/giuP3b0p8n1o9ffnn70+tvR79Drb0y7fmfMUT96/Y3mXD96/e3pR6+/Pf3o9benH73+hvKhv5F/0OtvTz96/e3pB6q/34qAKmpV5IFq5Lei26ue3Z+Sv/4d3VGRg1Pk4RQRnKIApyjCKUpwijKcooKmiAycIricTXA5m27P2e5DkQvp1E11jukREbL6ztk7otvznH/3NsGn86/p0+6I0udol2/t4fbd/npwu2un4491U7BwijycortrPRW3bwEqPnf2S7b7s7OcvT292tv9rLK3H9f+eSnjeOv3X7NNxZ1fnGh7eSRR/Lz0G2JSiH2IxWw3Lq4BMRqFeB2iVYjXITqFeB2iV4jXIZJC/AcQaX9b8+P9yzfEoBCvQ1SfyABRfeI/gRj3n69NoQExK8TrEItCvAwxacfydzmxCVE7luuFJWnHwgBROxYGiKQQr0PUjoUBonYsDBC1Y2GAqB0LA0TtWK5DzNqxMEDUjoUBopptBogcFseGHaLv/OovhT1QCi6cI+we++WYvPKceo5xKg+qt1Ord1Or91Orp6nVh6nVT53vWQbhjFPPeqS5ZEGxYtdxzliDwa76vLFiewTeWLEdBW+s2P6DN1YSFCu2t+EcmRAMthPijXUl39SLdSXf1It1Jd90PiIk2JV80/k4iGBX8k29WFfyTb1YV/JNvVhpoVjPx28Eu5Jv6sW6km/qxTqpb/pWP6kT+lY/qbep6h20W+kc4A8O2n901UM7iq56aI/QVU9Tq4eu41310JW5qx661nbVQ9farnroWttT76eutX7qWuuhay3jWKDgoesy4wih4KHrCNu4oeChs15n7E4g6KzXVQ+dN7rqkX3iguORAiGnpAXHhgRCzo0rAg/I6XxJ4Mi+e0ngyCV/SeDIHcuCh2lCIAV+L3D14TcDVx9+64CgEJCfii8JHPlB/pLAtdO8dVxWiNpp3ls0o3aaNwPXTvNm4Npp3gycFPi9wLXTvBm4dpo3A9dO82bg2mneDFw7zXuBJ+00bwaujc/NwBlsoTFboNnYfH7xS/B7RM7r34cROYFjUiizooKmiGOGJbMiC6fIwSnycIoIThFcPuIYMMmsKN2u6LPgXB7SkvPk+svc+ouZXL+dXL+bXL+fXD9Nrj+A6+8M/Slxcv3o9benH73+9vSj19/zQVDRoNff88E40aDX355+9Prb049ef3v60evv+VCdaNDrb08/ev3t6Qeqv9+KgCrqtyKgGlkV2burXjb0fgBvYjwqsnCKHJwiD6eI4BQFOEURTlGCU5ThFBU0RQ4uZzu4nO3gcraDy9kOLmc7uJztbs/Z9kORjecvKHSGC0WXkNV3BgZFf3uec+8eObsrQ4Civ323exN27d65I02CU3T7bvfh/fn6mI+KIpyiBKcowykqaIrIwCmycIocnCIPp4jgFMHlbILL2QSXswkuZxNczg5wOTvA5ewAl7MDXM4OcDk7wOXsAJezA1zODnA5O8Dl7AiXsyNczo5wOTvC5ewIl7Pj7TmbzH7rTPb4/X6McIoSnKIMp6igKUoGTpGFU+ThFN3+dlJ+H+tMeYlx4zElhXh1/Gy8/5TlihCtQrwO0SnE6xC9QrwOkRTi1aEL8f5DzitCVJ/IAFF94j+BeDoAON5/nn1FiEUhXoZYtGP5u5zYhKgdy/XCUrRjYYCoHQsDRFKI1yFqx8IAUTsWBojasTBA1I6FAaJ2LJchJqMdCwNE7VgYIKrZZoB43eKkEjbtqcTUgRhditutX/8+HExMDIMwmBUxDMLgVmThFDk4RR5OEcEpCnCK4PIRwyAMbkX5bkXe74Uv+lDOC19vHGayZW79zkyu306u302u30+unybXHybXH8H1x47+NLl+9Prb049efzv6PXr9PR8nnDx6/T0fB5s8ev3t6Uevvz396PW3px+9/p6Ps00evf729KPX355+oPr7rQioolZFBFQjvxXdXvXI0q6IvDsqcnCKPJwiglMU4BRFOEUJTlGGU1TQFAUDpwguZwe4nB3gcnaAy9kBLmeH23N22E8CvP6dzj2wM/tPIjvTe9GglLhfS8duKyTkSHvq4+05MaX3X87n2xUt9aeDflP0ONq/FQWcv4VvRUD78FsR0H75VnS7d4ofvVwM/qiooClKBk6RhVPk4BR5OEUBLWen23d/cfvrhbF4e1RU0BTl23d/ieGtKB//jrKFU+TgFHk4RQSnKMApinCKEpyiDKeooCkqcDm7wOXsApezC1zOLnA5u8Dl7AKXswtczi5wObug5exs0HJ2Nmg5Oxu0nJ0NWs7OBi1nZ4OWs7NBy9nZoOXsbNBydjZwOdvC5WwLl7MtXM62cBny/nNwtrwVvb4c/FDUuHqKMd/5/qN7M0I8H2mb7z+/tiJEpxCvQ/QK8TpEUojXIQaFeHUYSr7/YOWKENUnMkBUn3h5uHK+/5zrghDvP2y7IkTtWC6P+c5eO5brhcVrx8IAkRTidYjasTBA1I6FAaJ2LAwQtWNhgKgdy3WIpB0LA0TtWBggasfCAJEU4nWIDBbn9UXNBvHVAfUgdobYZo5hB8yKLJwiB6fIwykiOEUBTlGEU4SXjzKconK3ItYxtTmayfXbyfW7yfX7yfXT5PrD5Prj5PoTuP7Y0Z8n149efzv6E3r97elHr7/nY75zQq+/52Oac0Kvvz396PW3px+9/vb0o9ff8zHTOaHX355+9Prb0w9Uf6uiDFRRvxUB1chvRbdXvc6oz5w9nCKCUxTgFEU4RQlOUYZTVNAUFQOnyMIpgsvZBS5nF7icXeBydoHL2eX2nP3QmO//f3vvsiM7sGRX/kuPNfD341t6IEhqoVFAQSVUSw30oP6941QyGHGLTNrJdKfHctJqcJF1L5O5fJ/g3mYMurHUQl6pQF/NcE/sNua7msBhX4gS57OwEIGuw4UIdL0sRMNrJ2EYcrUGR2RxRA5H5HFEAUeUaJ5th1/9wlDt6gyOaPjVLwxFqs7hiDyOKOCIIo4o4YgyjqjgiCqNyBscEc6zPc6zPc6zPc6zPc6zPc6zPc6zPc6zPc6zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zI86zI86zI86zI86zI84hx++Du96Y7zp+6971RtrW8fvXriiiVxHbRQwqYruIUUVsFzGpiK3DUOr4jZVXFFHrxA4iap3YPFy5jt/nekURrYrYLqJ2LM1jvmvWjqU9WMbvfb6iiNqxdBBRO5YOImrH0kFE7Vg6iKgdS7uIRTuWDiJqx9JBRO1YOoioHUsHEbXY7iBijxLHrF9tF+skEYUhtrXLsIO+RA5H5HFEAUcUcUQJR5RxRDw/qiwia4wZTdRzTO2D307O7ybn95Pzh8n54+T8aXL+PDl/gfMngb/OzW/p+Svx0/NX4qfn7+GY7wc/PX8PxzQ/+On5K/HT81fip+evxE/P38Mx0w9+ev5K/PT8FfgdKH8XIlCiLkSgjFyIhqfe8ajPB1HAEUUcUcIRZRxRwRFVGpE3OCKLI3I4Ipxne5xne5xne5xne5xn++Ge/Zkx34+VVvJKJfow3BN7jfl+sEcO+0KUOZ+FhQh0HS5EoOvliygOr52OhyE/iCyOyOGIPI4o4IgijijTPDsNv/qPh2o/iCyOaPjVfzwU6UHkcUQBRxRxRAlHlHFEBUdUaUTZ4Igsjgjn2Rnn2Rnn2Rnn2Rnn2Rnn2Rnn2Rnn2QXn2QXn2QXn2QXn2QXn2QXn2QXn2QXn2QXn2QXn2RXn2RXn2RXn2RXn2RXn2RXnkOP3wV1uzPefvQ8qYuNI2z9faauI7SIGFbFdxKgitouYVMR2EbOK2DgM5U+HoyK2i6h1YruIVuvE1uHKf/5PRWwX0amI7SJqx9I65vvxf0FFbA8W7Vg6iKgdSwcRtWPpIKJ2LB1E1I6lXUSnHUsHEbVj6SCidiwdRNSOpYOIQUVsF1GL7Q4idihxHio+RczVSCIKQ2xtj2EHnYk8jijgiCKOKOGIMo6o4IhwfhQMjsiOJuo6ptYGNzm/n5w/TM4fJ+dPk/PnyfnL5PwVzn88ptlGMzk/PX8lfnr+Svz0/D0e8217jFs5l98c89PzV+Kn56/ET89fiZ+ev8djph//89z8iZ6/Ej8ofxciUKIuRKCMXIiGp54w6tOmiCNKOKKMIyo4okojygZHZHFEDkfkcUQ4z844z844z844z844z87DPftDY75tMeSVivTDPbHbmG9bEod9ISqcz8JCBLoOv4gq6HpZiIbXTsIwZFsdjsjjiAKOKOKIEo6owDzbmeFXvzBU2xmHIxp+9QtDkR61DI4o4ogSjijjiAqOqNKIrMERWRyRwxHhPNviPNviPNviPNviPNviPNviPNvhPNvhPNvhPNvhPNvhPNvhPNvhPNvhPNvhPNvhPNvjPNvjPNvjPNvjPNvjPNvjPNvjHHL8Prjrjfl247fuXW+krRu/f+2KIkYVsV3EpCK2i5hVxHYRi4rYOgzFjd9YeUERo9aJHUTUOrF5uLIbv8/1iiJ6FbFdxKAito75dlE7lg7Boh1LBxG1Y+kgonYsHUTUjqVdxKQdSwcRtWPpIKJ2LB1E1I6lg4hBRWwXUTuWDiJqsd0uYo+BELE8F5pjLYKIuVrzgrfbLTs9hh10Jgo4oogjSjiijCMqOKJKIyo4PyoWR+SGE70HTvXHwSeNqXXFT84fJuePk/Onyfnz5Pxlcv46N381cP4k8NvJ+en5K/HT81fip+fv8ZhvV+n5ezym2VV6/kr89PyV+On5K/HT8/d4zLQ39PyV+On5K/GD8nchAiXqQgTKyIVodOoVE1434E1KW6KEI8o4ooIjqjQia3BEFkfkcEQeRxRwRDjPtjjPtjjPtjjPtjjPdjjPdsM9274R2XT8gIKzeR087kze0jsyvS311VKEsKUf7nPu1SOXxxfDh/SHw8S9G361P0r5lf3xD79Vs9KI/PCr3cfXv69PZUtkcUQOR+RxRAFHFHFECUeUcUQFR1RpRAHn2QHn2QHn2QHn2QHn2QHn2QHn2QHn2QHn2QHn2RHn2RHn2RHn2RHn2RHn2RHn2RHn2RHn2RHn2RHn2Wm4ZweznroEu/1+P1kckcMReRxRwBFFHFHCERUaUR7+dFJx65cDuUgvVZ1inLDPTkVsHZ3px++yvKKISUVsFzGriO0iFhWxXcSqIrYOXfDjNzlfUUStEzuIqHXi34h4OMTVj9/PfkURg4rYLqJ2LD/zxF0RtWPpECzasXQQUTuWDiJqx9IuYtWOpYOI2rF0EFE7lg4iasfSQcSgIraLqB1LBxG1Y+kgohbbzSKGLqNFfFpFfP9ue1fE5PLz6D8/bzYmBhNwRBFHlHBEGUdUcESVRtRlEEZfIpwfdRmE0ZfIjybyfg2+5GM9Dj5pHGawYXL+ODl/mpw/T85fJuevc/M7Mzm/hfMngd9Nzk/PX4mfnr8SPz1/j8cJB0fP3+NxsMHR81fip+evxE/PX4Hf0/P3eJxt8PT8lfjp+Svxg/J3IQIl6kIEysiFaHjqPW40rESPD/2WKOOICo6o0oiCwRFZHJHDEXkcUcARRRwRzrMDzrMDzrMDzrMjzrPjcM+O606Ax8/5uAZ2xq7De430oEGtaT02bLut6MgrFemHe2LOr0/O+9MVPx70G2LhsH8RJcP5LCxEoOtwIQJdLwvR8NopvfVyKfotUcARRRxRwhFlHFGhEWVD8+w8/Oqvbn28MFVvt0QBRzT86q8pvojKzuco4YgyjqjgiCqNqBgckcURORyRxxEFHBHOswvOswvOswvOswvOsyvOsyvOsyvOsyvOsyvOsyvOsyvOsyvOsyvOsyvNs6OheXY0NM+OhubZ0dA8OxqaZ0dD8+xoaJ4dDc2zo8E55Ph9cLa+iB5fDr4R7Rw9xZjvOH7r3owiHo+0jeP3r11RxKwitotYVMR2EauK2Czi+D2NU4p4OAwljt9YeUURtU7sIKLWic3DleP4fa5XFDGqiO0iasfSPOY7Ou1YOgSLdiwdRNSOpV1Erx1LBxG1Y+kgonYsHUTUjqWDiEFFbBdRO5YOImrH0kFE7Vg6iKjFdruIPQZC+Lpudg3GCyLmas0L3m627MQeww46EyUcUcYRFRxRpRH1GHbQmcjiiHB+FD2OKAwneg+c6o+DTxpTG2OcnD9Nzp8n5y+T89e5+ZOZnN9Ozu/g/Eng95Pz0/NX4qfnr8RPz9/jMd8x0fP3eExzTPT8lfjp+SvwZ3r+Svz0/D0eMx0zPX8lfnr+Svyg/F2IQIm6EIEyciEanXrFhNcNeJPSlqjgiCqNqBgckcURORyRxxEFHFHEESUcEc6zC86zC86zK86zK86zK86z63DPtm9ENh0/oOBsXgePO5O39IFMb0t9tRQhbOmH+5x79cjF5eNB7ofDxJMZfrV7sz4GU7xz/1HNZCyOaPjV7uPr39ensiXyOKKAI4o4ooQjyjiigiOqNCJrcEQWR4TzbIvzbIvzbIvzbIvzbIvzbIvzbIvzbIfzbIfzbIfzbIfzbIfzbIfzbIfzbIfzbIfzbIfzbI/zbI/zbD/cs4NZT12CjVsijyMKOKKII0o4oowjKjSiYHBEw59OKm79ciAX6aWqU4wTTiGoiK2jM9P4XZZXFLGoiO0iVhWxWcTx22+vKKJVEVuHLqTxm5yvKKLWiR1EDCpi6xDXNH4/+xVFTCpiu4jasfzME3dF1I6lQ7Box9IuYtKOpYOI2rF0EFE7lg4iasfSQcSgIraLqB1LBxG1Y+kgonYsHUTUjqVdxKzFdgcRO5Q4rjwfWMquGklEYVhm6jEIozNRxhEVHFGlEfUYhNGZyOKIHI4I50c9BmF0JorDiXqOw0wlTc6fJ+cvk/PXufmrmZzfTs7vJuf3cP4k8IfJ+en5K/HT81fip+fv8TjhVOn5ezwONlV6/h7zZ0PPX4mfnr8SPz1/j8fZZkPPX4mfnr8SPyh/FyJQoi5EoIxciEannjTAL5tKI7IGR2RxRA5H5HFEAUcUcUQJR5RxRDjPtjjPdjjPdjjPdjjPdjjPdsM9u+M44ewimV4YJ5zdcJ/rNk44++FXuzC8N3uHIxp+tQtDfLIPOKKII0o4oowjKjiiSiMKBkdkcUQOR4Tz7IDz7IDz7IDz7IDz7IDz7IDz7Ijz7Ijz7Ijz7Ijz7Ijz7Ijz7Ijz7Ijz7Ijz7Ijz7ITz7ITz7ITz7DTcs4WBojkFHFHEESUcUcYRFRxRpRFliyMaffVfcJxwzlFFbB2dmcfvsryiiFVFbBZx/F7WK4poVcR2EZ2K2Dp0IY/f5HxFEYOK2C6i1ol/I+LhENc8fj/7FUXMKmK7iNqx/MwTd0XUjqU9WKp2LB1E1I6lg4jasXQQUTuWDiIGFbFdRO1YOoioHUsHEbVj6SCidiwdRNSOpVnEYrTY7iBi6CCiC6uIQRCx+vQ8c31/uGlf8WhekzUfP28ma5YuUzM+iF/mxq9T43cZ3vFBfDs3vpsb38+NP7fvd5lOciL+K6CjaR0fWroMPplmsfBE77tYeP73XSy8Wui6WAevLfouFl6J9F0svG7pu1h4lfOzxSZhseFOi71UBSUt9lIVlLTYS1VQx6O5i7tUBXU8h/lx+/FGi/WXqqCkxV6qgpIWe6kK6nj2dfGXqqCkxYY7LXbWCmrBn7UmWvBnrXIWfHbdYkNY8W1yW3x2JSLhB3ZtIeKzqwURn53/Ij470UV8dkaL+OzUFfHZqSvis1NXxJ87dcPcqRvnTt04d+rGuVM3zp26XcYanofv3vBdzIedsfBmgRLZCf2TpQqvISiRnSf+dSMu+pZ3FpTE9r5gX/+mwW+77cT2PhGf7X0iPtsQRHz0RR7q66H0UC8xDK0kdJ07peLHU4JKRhvkJRVHe/olFQ+q+GDF0cF/ScXRtxfnVPx4A11G3xG9pOJaj49WXOvxsXPBSkHfKr+k4ug7XJdUXHvOsYPyStGec3Bydpl5q4r/RHHtOUcrrj3naMW15xytuPacoxXXnnOw4lV7ztGKa885WnHtOUcrrj3naMW1AxqteIfq0IbnwdlGK4iYXE7PUz9+3jyDWXvMxuxM5HBEHkcUcEQRR5RwRBlHxPOjSiPqMfzzZ0Ter8GXfKzHwSdNZqrWTs7vJuf3k/OHyfnj5Pxpcv48OX+B8yeBv87N7+j5K/HT81fip+fv8eC36uj5ezwEq/YYNvlRfnr+Svz0/JX46fl7PD2rOnr+Svz0/BX4PSh/FyJQoi5EoIxciIan3tvu2BS82xIFHFHEESUcUcYRFRxRpREFgyOyOCKHI8J5dsB5dsB5dsB5dsB5dhju2XHdUvL4OR/XwM7YdU6RkR40qDWtx4ZttxUqeaUSfRzuiTm/PjnvT1f8ePJQjZHDvhBlzmdhIQJdhwsR6Hr5IkrDa6f01sul6LdEFkfkcEQeRxRwRBFHlGmenYdf/Y8vKFai6u2WyOKIhl/9j4/ui6hsP0fZ44gCjijiiBKOKOOICo6o0oiKwRFZHBHOswvOswvOswvOswvOswvOswvOswvOsyvOsyvOsyvOsyvOsyvOsyvOsyvOsyvOsyvOsyvMs50xMM9+EME8+0EE8+wHEcyzH0Qwz34QwRzyQTT86n98F7MSPb4cfCPaOXqG1wM8vtY1KmLjpOiHiF5FbBcxqIjtIkYVsV3EpCK2i5hVxMZhKA8Ri4rYLqLWie0iOq0TW6d0P0S0KmK7iE5FbBdRO5bWEfAPEYOK2B4s2rF0EFE7lg4iasfSQUTtWDqIqB1Lu4heO5YOImrH0kFE7Vg6iKgdSwcRg4rYLqIW2x1E/KbECeveI5vCsS7JueefSC5lQcT6+uep5W2hC8934yDO4vnzQMVy8J/vj7c8FsbjYDwexhNgPBHGk2A8GcZTRvOsxv/nHtyWp7J4ooHxWBiPg/F4GM9H/fl9FMfOsck8KzaXbD489mjAx2OVkbzK9WU1Lr2NkPnFKtMk/5Yhb9nz6Lr3bZyN29GywHgqiyd18FWbn9/FPjo54WAXn598F98OtU8cz8IJLJzIwkksnMzCKSycisLJZjDOOvTFvW21+HNranOo9+kZ5N6Xl7+mnWPD42bLcmxw9v3YZZn2Hst091imv8cywz2WGe+xzHSPZeZ7LHN0VbFuUnRZWKaIXqdFLwaLnkp8QqSS7Rbdzovu5kX3XPRq1tsH1e181sO86HFe9DQvep4XnZumIjo3TSX0Ck5TCR2cphI6OE0l9HnTtM6bpnXeNK3zpmmdN03rvGlayWm6QqQaN+jWkNNUQCenqYBOTlMBnZymAjo5TQV0SpouOF28Or1whIe8Y16fX4rZvb9gaeGpLB5rYDwWxuNgPB7GE2A8EcaTYDwZxgPzZwvzZwfzZwfzZwfzZwfzZzfcn0NaeYQXsj++gVxrt8fXplv2yGW3pb7eJR/Cln20r9UX+/tGvT325MzzmbXkXN2y13nZvQGzH3+Zar2dmN1NzO7B7Mc39KwPE7PHidnTxOx5YnZyrkrs5FwV2AM5VyV2cq5K7ORcldgnztUecwA+xj5xroaJczVMnKth4lwN6Fw9/rosonNVYEfnqsCOzlWBHZ2rAjs6VwV2TDYtPD18z9aVx8fjg2sMz3tvjx+39zyTGc3zGo4e3wZ7rzwexhNgPBHGk2A8GcZTYDyVxZNh/tNlU3xPHjeYJ63zdmpy+TB7hZ2JNvuJ2cPE7HFi9jQxe56YvUzMXudlL6PzL6X11YHpbb7bbm9lVvZkjX8/8QJvwfD2dQPKWrMDPzpZs3meuWZ73NXGtD5lE1PZg/czw4eZ4ePM8Glm+DwzfJkZvk4MX83M8HZmeHDC2vT4+uyJ8bjDe/yqBluTfbbpj5+j3fTpFRzI3dcKzu/uawXHffe1gquD7msFFxM/XWsOr9er5L21gmuPH681ldda83b/QQWXKp3X6gy4sjla60IPLm3+gn7S2mahn7RaWejD1PSTVhQL/aQ1wkI/aeov9OwcP+1Fee71nghv7NsK9959F2teF7h9b7wz7PpgCg0tu+6YQ0N29TOHhuwabA4N2ZXgHBoG1bBZQ3ZVPIeG7Nr8ExouwrDL/g8Kox3FN8Jom7AvjNPa/xthtKD/Rhit0r8RRkvvb4QJ9xTGm/ULH2+KPa4FbXTmeeb4/rLbVcWbVtSdVbxpTd1ZxZsW4J1VvGm13lnFm5b2fVX0N+0DOqt406ahs4o37TA6q3jTdqSzikFV7KCi9i5/o+L66l4bS91RUXuXHipq79JDRe1dOqgY7lov2nVivrdeUjHn58gjm6s7PjiH5z6BHNKO4EEF7yt4DU/m9/FYL8HvmvwfE/yuRcLHBL9rPfExwe9aenxM8LveYf2U4PGuN2M/JrjW4YMFv+st3o8Jfte7wR8TPKjgYwXXTrOz4Na4deiCSTsPqEftNYdLrt3mcMm13xwuuXacoyVP2nMOl1y7zuGSa985XHLtPJskX1QMqmIHFbVH7KGitn09VNRO7i9UrGZ9gqa6PRW1Oeuh4lX7rWDejv5aa75qo7O31qt2GHtrnbS0X+gnrZIX+jA1PTqJ3fq2yj8/5w19wVzjCw/6syCqOfdnAV0NifToKkSiJ7+X4i/o0ZWCSI/OfpEenf0i/dR+z34fhEiPvhPj/dp1Jh/r8dHV5td0/EfFtl0rOpk7rxWd453Xik79rmv17Dc8dF4ruqLovFZ0/dF5rehqpfNaw4XWmoS1oiuhzmu9Ut0krfVKdZO01ivVTeu7kR/f2RizXeuV6qZkDtfKfkNF57VeqW6S1nqlukla65Xqpvj2fbLZ+jD7DQqd13qlukla65XqJmmtk9ZNC/2kldBCP2lt80XPnqkf7IqRgndbenT9IdKjKwqRHl0jiPRhanp0jov06GQW6dFZK9Kjs1akR2etRM+eWy3ST5217DnNIv3UWcueSyzSo7M2pnVHW4r5uI90xj4fLnXGC2d+vSjHme0TzJ493/cnqogrRWdOzq9P7/vWnb2jX7t8cnmbN7qsM6Ad8vt1LvRoj/n+87jQT+oxC/2kXrDQo+v59Hb/JkW/pUfX8yI92lslevboQ5EeXc+L9Oi0EunRaSVlLXuuU3XrXuZU/2Fn6kKPdkyRHu2YNb12r9Wy/dyzB/eI9GjHFOnRjinSo++AiPRovxfp0d2JSI/uTkR6dtZK9Oysleinzlr27AiRfuqsZc93EOmnzlr2fAeRfuqszVNnLXu2hkg/ddbmqbO2TJ21nKksv6KfOmvL1FnLnp8j0k+dtWXqrGXPLhLpp85a9uwiiZ49u0iknzpr2dN/RHqdBTz0DcaePQZnyvdKmeeJq9sKHtgzW64ouL4WY7Dg+lKMwYLrKzEGCx5U8JEvYwzsYUJXFFzr8MGCax3eW/D1ofKa447g+qaPwYLrSxjHCs6ecjW5h+8Krp3m2NBkz/u6ouDaaQ4WPKjgYwXXTnOw4NppDhZcO83BgmunOVhw7TTHCs6eUHhFwbXTHCy4Nj6DBR9dFgb/VOVBZg5FiXkVJWb3/o+zsOeJ2cvE7HVe9uGDB3uy24nZ3cTsfmL2MDF7nJh94lz1E+eqnzhX/cS5GibO1TBxrgZ0roa0sgsv9nA2rwNZncnbdaIz+O/XaUt9vb8khO06yblRX+t8byb3jn30x88eNTlXt+skZ0zPdZLz6CfrLPFJnEp+3aBIz3WSs6vjOiM553quk5yJP1lnNc9cSdXl7TrJ+dlzneT87LnOcJN1knvjnuu8Sj0krfMq9ZC0zqvUQ9I6r1IPCetMV6mHpHXepB5KN6mH0k3qoeHjdj+1zpvUQ+km9VC6TD20Eqcad9Z5mXpIWOdl6qHjdebL1EPCOi9TDwnrvEw9JKwzzLjOhb09K+LrzXfJvD0HuHuwrdk+z1zL28N6T54ylscZ83ptn/Vbnsri6TAiti+PHc2zfqfrjItbHgfj8TCe8MnPz/vrIrfHHr5YMnQYs/pDp3p7oafb4UkwnsziqT2cak3FWH1jslQ7lkdyzupgPB7GE0bzHDtnjTCeBOPJn/z8tCRLLaOdSnDOiuKJxsB4OjhVSc8WKpZShU9afH56XHw7r33iBBZOZOEkFk5m4RQWTkXhdJgO1RXHDsZZX6Dr3saQP3C2h3qfnv7qfXm/RbU9NjzK4+XY4OzmdlbsMLFoimX6eyxzdDqt0/NdFpYposd50RMWXXh6Ndo8L3qZF71y0Y+/bo7OzItu50V386L7edG5aSqic9NURAen6fF3w9GB01RCB6ephE5O02N0T05TAZ2cpgI6JU0XnB5end0LJx0fnGsyzxvkNb+PW1p4Eownw3gKjKeyeIKB8VgYj4PxeBhPgPHA/DnA/DkM9+fyvGFajHFvPDvRezwtI4bCZRcmYMQ42NeKKWFlr/GQvXj//Hal+O2TqDG6idk9l1268xjDxOxxYvYEZhduyMQ8MXuZmL3Oy57MxOzgXBXZwbkqspNzVbil1GH38OfYybkqsaNzVWBH56rAjs7VY/aMyaaFp4fvrY9Hx+KEHYXCg285sHAiCyexcDILp7BwKgqnx3bOnjh2MM5nnonssUl0hmX6eyxzdDr1e0y0xHnRExZduvNW8rzoZV70ykUXbkNUMy+6nRfdzYvu50XnpqmIzk1TER2cpsK9kwpOUwkdnKYSOjlND9GTIaepgE5OUwGdkqYLTg+vtuaF444PfriuW+XxL6D85EkwngzjKTCeyuLpslW9J4+F8TgYj4fxBBgPzJ8tzJ/tcH+OduVJ709+7kTv8ROuyRYuu/CEa3KDfS2b9czZRH/ILjwlmpybmN1z2YU7j8mFidnjxOwJzH58Qya5PDF7mZi9zsvuzcTs4FwV2cG5KrKTc1W4peTJuSqxk3NVYkfnqsCOzlWBHZ2rx+wBk00LTwffy2v5GXPOxwdbm21ZT51t3RKF4UShvojSjkYRR5RwRBlHVHBElUbU4U3gvYksjsjhiDyOCOfZEefZEefZEefZEefZEefZabxnF/Miqsf1r/SdR7JkeulbjzTc50pdX6bzB+6QPuZg11OHf9j6tuAPN8WS8wu/xK2gCUc03BTrW0NUvdsSFRxRpRFlgyOyOCKHI/I4ooAjijiihCPCeXbGeXbGeXbBeXbBeXbBeXbBeXbBeXbBeXbBeXbBeXbBeXbBeXbFeXbFeXbFeXbFeXbFeXbFeXbFeXbFeXaleXY2NIfMPV7T+gjHlcgI71SwppT1puXj5x2iMJqomvUmsKnWb4kyjqjgiCqNqMdmr85EFkfkcEQeR4Tzox7bvjoTpeFEr1Obmo4HSwpTkrLNU9OXqenrzPTOTE1vp6Z3U9P7qelHZ6I161SLx882HdLHtD5m8vgr5v3UC34cjv92avMPOzd/g5/mxs9z45e58evU+N7MjW/nxndz4/u58cPc+OjUtcmG9VZpsv/wvrydo2uyz9Ejj5/j5u162aNDuvtq0ZnefbXoEqD7atEVQ+/VBnSB8dPVvh76fvy8t1p0PfLj1a4v9378nPN2tejypftq0dXO0WoX/jA5/7T1zsI/bQWz8E9bkyz801YZC/+0dcMXf5y2Elj46dle48rvjDRxsLweZCnFH2ejq/V5t9gb+7bGsrfG+tzzlWx8P3RRkV4zzKEivRaZQ8WgKnZQkV6XzaEivTqcQ0V6jTqHivRKeQ4V6fX6J1T8kibRW4EPSqNdxrfSaOvwrTTaD3wrTVBpvpNGK/dvpdFy/Ftpbltje7N+ReRNscfVoY1ufcg/hryj422r7M463rbO7qtjvm1R3lnH21bwnXW8bbnfWcfb9gaddQyqYxcdb9t1dNbxti1KZx21n+mjo/Yzf6djWscex1J3dNR+pouORfuZPjpqP9NHx3BbHa19flPqrZd0fDQszzPn6o4PzuG5++AfZrCvkt832k+TvIYnc31b30vy+1YBH5P8vgXDpySv960tPib5fcuQj0l+3zuwH5P8vjdrPyZ5UMlHS37fW8Afk/y+d4s/Jrl2n8Ml1+6zu+TWuHXEg0k7D7pX7T+Hi16MdqAfEF170A+Irl3oB0TXPvQDogcVfbzo2ot+QHTtRhtFX3TUFrOPjto39tFRW8EuOlrt7v5Kx2rWZ26q29NRG7Y+Ol63Bwvm7ehltddtfvZWG2612mnL/YV/2sp54Z+2Yv3id/Bkdjm9+LdTbIsDXe0LEfwTISnKfoXGX/DDaySRH16biPzwakPkh9cPIj+8IhD54RWByD+7/8PvHYn88Hs23q+9afKxHh9dbV7r//qo5Tarpb+PovNq4dneebXwSqDzauF1Q+fVhlutFl6TdF4tvILpvFp4vfPD1SZhtfDqqPNqr1VLCaulv9Gj82qvVUulvK7Wme19cvp7On66WnO82mvVUtJqw61We61aSlrttWqp+Pa9tNnx5GvVUtJqr1VLSau9Vi0lrJb+SoTvV7vwT1sdLfzT1jsLP7yCCXY9OgXvtvxhcn54lSHyw+sGkR9eCYj88GwX+eFpLfHTp5+L/PD8Ffnh+SvyT56/9OnWIv/k+Uuf5izyT56/9OnFMa076lLMx92mM/b5EKszXjjz63U/zuw8L02fRvwTXaS1FngG5fz6DL9vG9o7+rXDKJe3yajPlcLd8vuVLvxwt/n+U7nwT+s2C/+0rvDFT5/fmd7u9qTot/zwal/khzutyA+v9kX+MDk/PL9Efnh+Cflb6dOnqlv3V6f6DztlF364f4r8cP+s6bWLrha/5Yf7p8gP90+RH+6fIj/8bonID/d/kR/ev4j88P5F4qfPBxH56fkr8U+ev/QJFyL/5PlLn0Ih8k+ev/QpFCL/5PlrJ89f+hQQkX/y/HWT56+bPH9JU2R+xT95/rrJ85c+80fknzx/3eT5S5+5JPJPnr/0mUsi/+T5S5+5JPJPnl/0mTnXe5dzpQ/umfJtWuZ54kdFuSO5vgRkuORwY7+i5PoCkOGS6+s/hkuubwoZ/DLKSh99dEXJtS4fLTl9CNSUkq+Pr9ccdyTXt5oMl1xfQjlccu0+z/TyXcmDSj46PrX7HC65dp/DJdfuc7jk2n0Ol1y7z9GS08fmXVFy7T6HS67d53DJtfscLnlQyUdLrq3QcMlHF4kmv14AZnI5ljzmVZaY3fuxX/TDxyT2pbdT07up6f3U9GFq+jg1fZqaPk9NX6amnzpry9RZW6bO2jJ11paps7ZMnbUFnrUhracWXlribF7HyDqTtyuF5/Lfr9SW+no7SwjblbJzpL5WWoWW+tFFPzvZ5NxmMGat7MzpuVJ2Pv1kpSU+mVPJr1sZ6blSdpb1XCk793qulJ2RP1lpNc+USdXl7UrZedpzpew87blSdk/cc6Xs/rnnSq9TIx2u1BtznRpJWul1aiRppdepkaSVXqdGklYabrPSm9RIj5XepEZ6rPQmNdJjpTepkR4rvU2NZC9UI63MqcadlV6oRhJWeqEaSVjphWokYaXhNiu9UI0krHTSyuGLvstoXfc8OKa39x/u0yf3on/8nLdEHkcUcEQRR5RwRBlHVHBElUbkcX7UZXhoXyI3msi/vWDNS9/uV5vXB8OrrXHL7yfnD5Pzx8n50+T8eXL+Mjl/nZs/GDh/Evjt5Pz0/JX46fkr8dPzN+WV3xmz5afnbzLH/PT8lfjp+Svx0/NX4qfnb6xv/Fv/ifT8lfjp+Svx0/NX4gfl70IEStSFCJSRC9Hw1At2PXUK3m2JMo6o4IgqjSgZHJHFETkckccRBRxRxBHhPDvhPDvhPDvhPDvjPDsP9+y4zo9+/JyFvazGrntZjS9CvVzTemzYdovZkVcq0g/3xJxfn5z36Ul79K9BS7m8vcXkyV447F9ExXA+CwsR6DpciEDXy0I0vHZKb71cin5LFHBEEUeUcEQZR1RoRNXQPLsOv/qrW8cHpvoPgwkXooAjGn71H79y9UGUcEQZR1RwRBVGZI3BEVkckcMReRxRwBHRPNsammdbQ/Nsa2iebQ3Osy3Osy3Osy3Osy3Osy3Osy3Osy3Osy3Osy3Osy3Osx3Osx3Osx3Osx3Osx3Osx3Osx3Osx3Osx3OIcfvmpvxdSo5PL/LySG9H7qI6FXEv3gnjXmeuLo9EZOK2C5iVhHbRSwqYruIVUVsFnH8nsbLvezsIaJVEdtF1Dqxg4haJ/6NiOuDUzXHHRGDitguYlQR20XUjuVnnrgronYsHYJFO5YOImrH0i5i1I6lg4jasXQQUTuWDiJqx9JBxKAitouoHUsHEbVj6SCidiwdRNRiu13EHgMhYl2HrCfrJBGFIby2x7CDzkQJR5RxRAVHVGlEPYYddCayOCKcH2WPIwqjibqO2bU5Ts6fJufPk/OXyfnr3PzFTM5vJ+d3cP4k8PvJ+en5K/HT81fip+fv8ZhyW+j5ezxm2hZ6/kr89PwV+Cs9fyV+ev4ej5l+/JeT89PzV+Kn56/ED8rfhQiUqAsRKCMXouGpJ4wqtbXCiJwxOCKLI3I4Io8jCjiiiCNKOKKMI6J5tjM4z7Y4z7Y4z7Y4z7bDPftDY8qdDeSVivTDPbHbmHLnDId9IXKcz8JCBLoOFyLQ9bIQDa+dhGHOziUcUcYRFRxRpRF5gyNyNM/2w69+YSi48wlHNPzqF4Y6OV9wRJVGFAyOyOKIHI7I44gCjijiiBKOCOfZAefZAefZEefZEefZEefZEefZEefZEefZEefZEefZEefZEefZCefZCefZCefZCefZCefZCefZCefZCefZCefZCefZGeeQ43fNXW9MuRu/de96I3nd+P1rVxSxqojNIo7fyXdFEa2K2C6iUxFbh7m48RsrryhiUBHbRdQ6sXk4tBu/z/WKImYVsV1E7Viax5S7oh1Le7BU7Vg6iKgdSwcRtWPpIKJ2LB1EDCpiu4jasXQQUTuWDiJqx9JBRO1YOoioHUuziN5osd1BxNBBxPy8xxHj+27XfRGFIby+y7CDvkQFR1RpRF2GHfQlsjgihyPyOCKcH9mII0qjibqO2fU2T85fJuevc/M7Mzm/nZzfTc7vJ+cPcP4k8MfJ+en5K/HT81fip+fv8Zhy7+j5ezxm2nt6/kr89PyV+On5K/HT8/d4zLT39PyV+On5K/HT81fiB+XvQgRK1IUIlJFfRGF46gmjSn2wOCKHI/I4ooAjijiihCPKOKKCI6o0oojz7Ijz7Ijz7Ijz7Ijz7Djcsz80ptzHRF6pSD/cE7uNKffJcdgXosD5LCxEoOtwIQJdLwvR8NpJGObsU8ERVRpRNjgiiyNyOKJA8+w8/OoXhoL7XHBEw69+YaiTLwZHZHFEDkfkcUQBRxRxRAlHlHFEBUeE8+yK8+yK8+yK8+yK8+yK8+yK8+yK8+yK8+yK8+xK8+xgaJ4dDM2zg6F5djA0zw6G5tnB0Dw7GJpnB0Pz7GBonh0MzrMtzrMtzrMtziHH75q73pjyMH7r3vVG8obx+9euKKJVEdtFdCpiu4heRWwXMaiIrcNcwviNlVcUUevEDiJqndg8HDqM3+d6RRGritgsoteOpXlMefDasbQHi9eOpYOI2rF0EDGoiO0iasfSQUTtWDqIqB1LBxG1Y+kgonYs7SIG7Vg6iKgdSwcRtdjuIOI3JY5bdx7at23G+yL6dSxV9DULItZsn2eu5W2hT548lscZ89pmbP2Wp8B4Kovnu0EQH+OxMB4H4/EwngDjiaN5VuN3xsUtT4LxZBhPgfFUFk8yMJ6P+vP7KI6dY5N5Vmwu2Xx47OGAj5AceZWurqt8p/j5Kv0k/5Yhb9nD6Lr3bZyN29EywngSjKeDr7qyvpPKm9LWp2QzlkeqW7KF8TgYjx/Nc5yDOcB4IownffLzkxpSMefRTnXsnLnAeCqLp/RwKrcmnfONyVL8WB7JOUuA8UQYTxrNc+ycJcN4CoynfvLz05Is1Yx2qmPnrBbG42A8HZzq9cqbaEsVPmnx+elx8e2LL/vESSyczMIpLJxKwonGsHAsC8excPxgnHVQpXvbHv7A2fme26fnzcc/w9DWg9POscGu7xAPzr4fuywz3GOZ8R7LTPdYZr7HMss9lllvsUxr7rHM0VXFOljFZWGZIrqbF91j0VOJzw9iKtlu0cO86HFe9MRFr+Z5bKpu57Oe50Uv86LXadGdmRedm6YiOjdNRXRwmkro4DSV0MFpKqHPm6Zu3jR186apmzdN/bxp6udNU09O03WzWKpxB52cpgI6OU0FdHKaCujkNBXQyWkqoFPS9Asn9PDq9SGxB46wMTXm9YmXmN3rzPnJ42A8HsYTYDwRxpNgPBnGU2A8lcXTY49wVx6YP0eYP0eYP0eYP0eYP0eYP8fh/hzSyhOPXyv/+AZyrd2cyVv2wmV/1KXrO4ofFfGGPY32tfpifx8usseenHk+s5acq1t2NzG7B7MLX6amMDF7nJg9gdmFG3opT8xeJmav87JnMzE7OVcldnKuSuzkXJXYybkqsZNzVWKfOFfzxLmaJ87VPHGulolztUycqwWdq8dflxV0rgrs6FwV2NG5KrCjc1VgR+eqwI7Jpi+eHnvsTX191W6Fg4WtrtWzcAILJ7JwEgsns3AKC6eScFKPAQQ/wvnIFsTUY7DBDMt091jm6HTqtiszmTAvesSiC98KJZPmRc/zohcu+vFtiGTqtOjWzItu50V386Jz01RE56apiA5O0+N7J8mC01RCB6ephE5OUwGdnKbH6I6cpgI6JU0XnA5ebc3rjquNxwfnur4mIdf8/pq4hSfCeBKMJ8N4Coynsni6bMLuyWNhPA7G42E8MH/2MH/2w/25PG+YFmPcG89O9B7vvkg+c9mF3RcpDPa1YkpY2Ws8ZC/eP79dKX77rW4KdmJ2x2WX7jwGPzF7mJg9gtmFGzIhTcyeJ2YvE7PXedkjOFdFdnCuiuzkXBVuKUVyrkrs5FyV2NG5KrCjc1VgR+eqwI7Jpi+eHjvRjX9aazTvT7P94sG3HpvLe+IEFk5k4SQWTmbhFBZOReH02CH9I5zPPBPZYzP1DMt091jm6HTq95hojx3an0KPWHTpzltO86LnedELF124DZHrtOjFzItu50V386Jz01RE56apiA5OU+HeSQGnqYQOTlMJnZymAjo5TY/RKzlNBXRKmi44Xby6vnDs8cEP13WrPP4F9Lzj2mWbek+eBOPJMJ4C46kontxlr3pPHgvjcTAeD+Nh+XM2LH/OZrg/R7vypPcnP3ei9/gJ12wyl114wjXbwb72uBCeZdXjM+gP2YWnRLO1E7M7Lrtw5zFbPzF7mJg9gtmPb8hkmyZmzxOzl4nZ67zsDpyrIjs4V0V2cq4e31LKjpyrEjs5VyV2dK4K7OhcFdjRuSqwY7Lpi6fDDuNQyzpwwRiBxyaXn0Nl//y87Yo77KHtTZRwRBlHVHBElUbUYVdwbyKLI8L5UYd9ub2JwmgivybO42fpzYTV5rLeOrTbXRU5xMn50+T8eXL+Mjl/nZs/msn57eT8Ds6fBH4/OT89fyV+ev5K/PT8TXnld8Zs+en5uw6V+oafnr8SPz1/Bf5Ez1+Jn56/sb7xb/0n0fNX4qfnr8RPz1+JH5S/CxEoURciUEYuRMNTL9iwEgXvtkSVRpQNjsjiiByOyOOIAo4o4ogSjijjiHCenXGeXXCeXXCeXXCeXYZ7dkzrqVPMxzWwM3Z98t34ItTLNa3Hhm23WAJ5pSL9cE/M+fXJyfV4jvUj+pdj8/vLgBf2ajjsC5HjfBYWItB1uBCBrpeFaHjtlN56ubTz1FNNOKKMIyo4ogojKsbgiBzMs4sZfvVX51ei6u2WKOGIhl/9dR0L8Pi57HyOCo6o0oiswRFZHJHDEXkcUcARRRxRwhHhPNviPNviPNvhPNvhPNvhPNvhPNvhPNvhPNvhPNvhPNvhPNvhPNvjPNvjPNvjPNvjPNvjPNvjPNvjPNvjPNvjPNvjPDvgHHL8rjlbX0SPLwffiHaOLo/27Xl0Kf9wj3B7tLf2CeLt27F/BkZtT/36ls++36DdPTiHpxw5pPdDFxGjiiiLWM3zxNXtiVhUxHYRq4rYLOL4nXxXFNGqiO0iOhXxL0QMT+b6NhvyJaJXEdtFDCpiu4haJ/6NiOuDUzXHHRGTitguYlYR20XUjuVnnrgronYs7cGStGPpIKJ2LB1E1I6lg4jasXQQMaiI7SJqx9JBRO1YOoioHUsHEbVj6SCidiztImYttjuIGDqImJ5vvwr/0J/viygM4S1dhh30JSo4okoj6jLsoC+RxRE5HJHHEeH8qEQcURpN1HXMbil5cv4yOX+dm7+ayfnt5Pxucn4/OX+A8yeBP07OT89fiZ+evxI/PX+Px5SXSs/f4zHT1dDzV+Kn56/ET89fiZ+ev8djpquh56/ET89fiZ+evxI/KH8XIlCiLkSgjPwissNTTxhVWq3FETkckccRBRxRxBElHFHGERUcUaUROZxnO5xnO5xnO5xnO5xnu+Ge/aEx5dUl8kpF+uGe2G1MefWOw74QBc5nYSECXYcLEeh6WYiG107CMOfqC46o0oiCwRFZHJHDEQWaZ4fhV78wFLyGgiMafvULQ51qNDgiiyNyOCKPIwo4oogjSjiijCMqOCKcZyecZyecZyecZyecZyecZyecZyecZyecZyecZyecZ2ecZ2ecZ2ecZ2ecZ2ecZ2ecZ2ecZ2ecZ2ecZ2ecZxecZxecZxecQ47fNXe9MeV1/Na9643kreP3r11RRKsitovoVMR2Eb2K2C5iUBFbh7nU8Rsrryii1okdRNQ6sXk4dB2/z/WKIlYVsVHEYIx2LK1jyh8iasfSGiwPEbVj6SCidiwdRAwqYruI2rF0EFE7lg4iasfSQUTtWDqIqB1Lu4hWO5YOImrH0kFELbY7iNijxPFxFTFUScTjIbwPokoj6jLsoC+RxRE5HJHHEQUcUcQR4fzIZRxRGU3Uc8zug7/Oze/N5Px2cn43Ob+fnD9Mzh8n509w/iTw58n56fkr8dPzV+AP9Pw9HFP+4Kfn7+GY6Qc/PX8lfnr+Svz0/JX46fl7OGb6wU/PX4mfnr8SPz1/JX5Q/n4RRVCiLkSgjFyIhqfe8ajSB5HHEQUcUcQRJRxRxhEVHFGlESWDI7I4IpxnJ5xnJ5xnJ5xnJ5xnp+Ge/Zkx5Y+VFvJKJfo83BN7jSl/sAcO+0KUOJ+FhQh0HS5EoOtlIRpeOx0Pcw6mGByRxRE5HJHHEQUcUaJ5dhl+9R8PBQ+mGhzR8Kv/eKjTg8jhiDyOKOCIIo4o4YgyjqjgiCqMyBqDI6J5tjU0z7aG5tnW0DzbGppnW0PzbGtonm0NzbOtwXm2xXm2xXm2xXm2xXm2xXm2xXm2xXm2xXm2xXm2xXm2w3m2w3m2w3m2w3m2wznk+F1zlxtT/hCxqoiNI3mDHb9/7YoiehWxXcSgIraLGFXEdhGTitg6zMWO31h5RRG1TuwgotaJzcOh7fh9rlcU0aqI7SJqx9I8ptwG7Vjag2X83ucriqgdSwcRtWPpIKJ2LB1E1I6lg4jasbSLGLVj6SCidiwdRNSOpYOI2rF0EFGL7Q4iflPimPUvWJsEEV14blQKLkqz3qOx6xCrx8+bLTv2u2EHHyRyOCKPIwo4oogjSjiijCPi+VEdTvSy92iqP44ZaaitzWZyfjs5v5uc30/OHybnj5Pzp8n5M5w/Cfxlcn56/gr8hZ6/Ej89f4+HgttCz9/joc620PNX4qfnr8RPz1+Jn56/x0OdbaHnr8RPz1+Jn56/An8F5e9CBErUhQiUkQvR8NSz69GPn5PbEgUcUcQRJRxRxhEVHFGFETljcEQWR+RwRDTPfnxHiyMa7tnujcjFfFhNucfdxuVg50ze0icy/aNUfZWCIWzph/ucf/Vm0edySH84MtrZ4Vf726D0GPymQnPW44gijmh01ofq1ksgVGlA/BSjEZytKmLrNmDnnIrYLqJXEdtFDCpiu4hRRWwXMamIrQ+QOpdVxHYRtU7sIKLWic0b0p03KmK7iFZFbBdRO5bm0QjOa8fSHixeO5YOImrH0kFE7Vg6iKgdSwcRtWPpIKJ2LO0iBu1YOoioHUsHEbVj6SCidiwdRNRiu4OIHUoc654PgPyZCS6I+CiqVlkeP2/e9+xCHU0U7PrP+rgytw8ERYMjsjgihyPyOKKAI4o4ooQjyjiigiPCeXbCeXbCeXbCeXbCeXbCeXYa79kxvIhS28PVKZHppYer03Cfi3GdxvbIxuOW488b3NdTm3/g+MLPZhp863bwh7tDrHbFT6ZsPg854IiGu0Py7kX09mjzSpRwRBlHVHBEw50uvUZ0uFS2RMXgiCyOyOGIPI4o4IgijijhiDKOqOCIcJ5dcZ5dcZ5dcZ5dcZ5dcZ5dcZ5dcZ5dcZ5dcZ5daZ7tDc2zvaF5tjc0z/aG5tne0DzbG5pne0PzbG9onu0NzbO9wXm2xXm2xTlkj8EZZn1KJ5j3p3R2idLj1ufz1I+f85ao4IgqjcgZHJHFETkckccRBRwRzo96jAroTJRHE3m/fgGcfHx/OnHnaGmsvndlcv46N783k/Pbyfnd5Px+cv4wOX+E8yeBP03OT89fiZ+evxI/PX+PX0viAz1/j18r4QM9fyV+ev5K/PT8lfjp+Xv8Wgkf6Pkr8dPzV+Kn56/ED8rfhQiUqF9EEZSRC9Hw1HsbMZ0edx22RA5H5HFEAUcUcUQJR5RxRAVHVGlEyeCIcJ6dcJ6dcJ6dcJ6dcJ6dhnt2XGd2Pn7OxzWwM3bd72ikkSC1pvXYsO0WUyavVKLPwz0x59cn530Oyo9fPOOz57AvRJHzWViIQNfhQgS6Xhai4bVTeuvlUvRbokojKgZHZHFEDkfkcUSR5tll+NVf3XrqVP9hxNhCVGlEdfjVX1N8EZXt56haHJHDEXkcUcARRRxRwhFlHFHBEVUYUTA0zw6G5tnB0Dw7GJpnB0Pz7GBonh0MzbODoXl2MDTPDgbn2Rbn2Rbn2Rbn2Rbn2Rbn2Rbn2Rbn2Rbn2Rbn2Rbn2Q7n2Q7n2Q7n2Q7nkON3zdn6Inp8OfhGtHM05MUIOTy/y8lv8w+fL0YI47fuzSji8cunw/j9a1cU0amI7SJ6FbFdxKAitosYVcTW1xaF8Rsrryii1okdRNQ6sfk16GH8PtcLijh+s+0VRdSO5WeeuCuidiztwRK0Y+kgYlAR20XUjqWDiNqxdBBRO5YOImrH0kFE7VjaRYzasXQQUTuWDiJqx9JBxKAitovYXuL4Gp8H+/r2xtNvRBSG8IYOww56E1kckcMReRxRwBFFHFHCEfH8qOCI6miirmN2QzaT89vJ+d3k/H5y/jA5f5ycP03On+H8SeAvk/PT81fgL/T8lfjp+Xs8pjwUev4ej5kOhZ6/Ej89fyV+ev5K/PT8PR4zHQo9fyV+ev5K/PT8FfgrKH8XIlCiLkSgjFyIhqeeMKo0dBhK1Jso4ogSjijjiAqOqMKIojE4IosjcjgimmdHQ/PsaGieHQ3Ns6OheXY0wz37Q2PKo6nklUr0drgndhtTHm3ksC9EmfNZWIhA1+FCBLpevojc8NpJGOYcncURORyRxxEFHFHEEWWaZ/vhV78wFDx6iyMafvULQ52i9ziigCOKOKKEI8o4ooIjqjSiYHBEFkeE8+yA8+yA8+yA8+yA8+yA8+yA8+yA8+yI8+yI8+yI8+yI8+yI8+yI8+yI8+yI8+yI8+yI8+yE8+yE8+yE8+yE8+yE8+yEc8jxu+auN6Y8jt+6d72RvHH8/rUrihhUxHYRo4rYLmJSEdtFzCpi6zCXOH5j5RVF1DqxXcSidWLzcOg4fp/rFUV0KmK7iNqxNI8pj+O3HV8xWLRj6SCidiwdRNSOpYOI2rF0EFE7lnYRq3YsHUTUjqWDiNqxdBBRO5YOIgYVsV1ELbY7iNihxCmlriIaL4koDOFNPYYddCbyOKKAI4o4ooQjyjiigiPC+ZE1OCI7mqjrmN1k3eT8fnL+MDl/nJw/Tc6fJ+cvk/NXOP/xmOnkzOT89PyV+On5K/HT8/d4THnqMW7lXH5zzE/PX4mfnr8SPz1/JX56/h6PmU6Onr8Cv6fnr8RPz1+JH5S/CxEoURciUEYuRMNTTxhVmnzCEWUcUcERVRpRMDgiiyNyOCKPIwo4IpxnB5xnB5xnB5xnB5xnx+Ge/aEx5Sla8kpF+uGe2G1MeYqZw74QVc5n4Ysoga7DhQh0vSxEw2snYZhzSh5HFHBEEUeUcEQZR1Rpnp2HX/3CUPCUPY5o+NUvDHVKOeKIEo4o44gKjqjSiIrBEVkckcMReRwRzrMLzrMLzrMLzrMLzrMLzrMrzrMrzrMrzrMrzrMrzrMrzrMrzrMrzrMrzrMrzbOzoXl2NjTPzobm2dnQPDsbmmdnQ/PsbGienQ3NIfP4XXPXG1Oex2/du95I3jx+/9oVRUwqYruIWUVsF7GoiO0iVhWxdZhLHr+x8ooiap3YQUStE5uHQ+fx+1yvKGJQEdtF1I6leUx5dtqxdAgW7Vg6iKgdSwcRtWNpF9Frx9JBRO1YOoioHUsHEbVj6SBiUBHbRdSOpYOI2rF0EFGL7XYRvxkIYV6T4kwVxreH10alkKuguDPlbQdzefvG4vk4wTcDIT5J5HFEAUcUcUQJR5RxRAVHVGlE3wyE+CQRzrMjzrMjzrMjzrMjzrMjzrMjzrPjcM+u9jWJpTphQI3NK74zeUtfyfS21NeEyRA29Gl4FlRTXvTbDe45Dfe5ujYfj5/r9l84BRxRxBElHFHGERUcUaURZYMjGl2bPm73PC378XMQRqKFUtdbJ6Hu5FN2k/P7yfnD5Pxxcv40OX+enL9Mzl/n5i9mcv7J87dMnr9l8vwtk+dvgefv4w7Ei18a4PujrxDda2CuN/Z172L3W8FYn183JrvzRG2BVwGTqAivRSZREV4RTaIivC6bQ8UKrw4nURFeo06iIrxSnkRFeL3+ERUXaYJK85002mV8K422Dt9Ko/3At9Jokf+tNFq5fyNNMVqOfyvNbWts/1qjN0V6lD669ZXKMeQdHW9bZXfW8bZ1dmcdg+rYRcfbVvCddbxtud9Zx9v2Bp11vG0j0VnH23YdfXW0t21ROuuo/UwfHbWf+Tsd08oRS93RUfuZPjoG1bGLjtrP9NHxvvXjh159UNx9o/1DUz+Ku28V8DHJ71swfEzyoJKPlvy+ZcjHJL/vHdiPSX7fm7Ufk1zr8uGS3/cW8Kck9/e9W/wxybX7HC65dp/dJbfGuVW9FHdE1/7zA6IHFX286NqDfkB07UI/ILr2oR8QXTvRD4iuveh40YN2o42iLzpqi9lHR+0b++iorWAfHYPq+Dc6VrNyVLenozZsfXS8bg8WzNvRy2qv2/zsrfa6Xcfeaqct97/447SV88I/bcW68LOTORr7ekrfWLvlZ3tbDDas/MH7LT/brUT+NP7zn9/46/YTPfw9D9ZltxK5t/J3T9FXpZzL24mf7InDvhAVGhF8br7oWPC57TI/uweR+dm1v8wPTzyRH554Ij+74hb54XPbZf7J/R8+tz2a1728aKo/PrravGJXW+N2tew7qL1XS8/2vqulVwJ9V0uvG/qull5l9F0tvSbpu1p6BdN1tfBJ5D9dbRJWS6+O+q72WrWUtNpr1VLSasO1VpvX1Tqz/R4HPif7x6s1x6u9Vi0lrfZatZS02mvVUtJqr1VLxbfnJszGkyt8jHTv1V6rlpJWe61aSlrttLXUwh8m55+23ln44RWMDa/v7W1yW354TSLyw6sMkR9eN0j88GmtMj8820V+eFqL/PD8Ffnh+Svyw/NX5J88f+3k+Quf/inzT56/bvL8hY8ylfnh+eve+F3Mh0c7m59TaJzbvim+wgdy/mit9nHHbr0xEMJ2rfBc8a/7kdHn46MPnzWu8KFl0pPnFT4BTOaHO6DID3cFkV/nsAyeX151Ckt/yR938pZjH9m1lVwnU4yXXIdYDJdc510Ml1xHYwyXPKjkYwewVh24MV5yrcuHS651eX/J07MVqjnuSK6zEYdLrpMRR0s+73SXKbx8V3LtPkfHZ9Tuc7jk2n0Olzyo5KMl1+5zuOTafQ6XXLvP4ZJr9zlccu0+R0uetPscLrl2n8Ml11ZouOQ9ikRvVsmDIPkD+DVU7PHzZqhYTZVGlA2OyOKIHI7I44gCjijiiHB+1GVIaV+iMpzoPXBax1jVXOfmL2Zyfjs5v5uc30/OHybnj5PzJzh/Evjz5Pz0/JX46fkr8Fd6/h4PyKuVnr/Hg8JqpeevxE/PX4mfnr8SPz1/hYFblZ6/Ej89fyV+ev5K/KD8/UMUjQEl6kIEysiFaHTqlccXEs9TF5PSlsjjiAKOKOKIEo4o44gKjqjSiKzBEVkcEc6zLc6zLc6zLc6zLc6zLc6z7XDPtm9ENh0/YHE8GOpBX8n0x6OeonHDfc69evziGoY3PdiHX+3exJXdO7dVM+GIhl/tPr7+fX0qW6KCI6o0Im9wRBZH5HBEHkcUcEQRR5RwRDjP9jjP9jjPDjjPDjjPDjjPDjjPDjjPDjjPDjjPDjjPDjjPDjjPjjjPjjjPjjjPjjjPjjjPjjjPjjjPjsM9Oxi7EgUbt0QFR1RpRMngiCyOyOGIPI4o4oiGP51UXttSc7nCePWHiFVFbByyG834PZlXFNGriO0iBhWxXcSoIraLmFTExqERDxGzitguotaJHUTUOvFvRDwabRzN+P3sVxTRqojtImrH8jNP3BVRO5b2YBk/4+CKImrH0kFE7Vg6iKgdSwcRtWPpIKJ2LO0iVu1YOoioHUsHEbVj6SCidiwdRNRiu4OIHUqclJ8PCIT0Nkdi92D3uG+07kt83P7YbqvsMSykK5HtMSykM5HFETkckccRBRxRxBElHFHGEdE82xqcZ1ucZ1ucZ1ucZ1ucZ1ucZ9vhnl1tWomqq4eFrDB2wtpEphfGTlg7PAuqKS96bzdEbrjPvcbGPX6u239hZ3FEDkfkcUQBRxRxRAlHlHFEo2vTH77RqtT11kmoO/nk6tz83kzObyfnd5Pz+8n5w+T8cXL+NDl/npx/8vz1k+dvmDx/w+T5G+D5e94bVV2tzxsd3tjXvYvdbwVjfX7dmOz2iVob4FXAJCoGVbGDivCKaBIV4XXZJCrCq8NJVITXqJOoCK+U51Axwuv1j6i4SANvBT4pjXYZ30qjrcO30gSV5jtptMj/Vhqt3L+VRsvxb6W5bY3tX2v0pkiP0ke3DtuMIe/oeNsqu6+O6bZ1dmcdb1uUd9bxthV8Zx1vW+531jGojl10vG0j0VnH23YdnXW8bYvSWUftZ/roqP3M3+mYVo5Y6lbHrP1MHx21n+mjo/YzfXS8b/34oVcf2HzfaP/Q1A+b71sFfEryct+C4WOS37e2+Jjk9y1DPib5fe/AfkzyoJKPllzr8uGS3/cW8Mckv+/d4o9Jrt3ncMm1++wuuTXOreqlnQfdq/afHxBdO9APiK496AdE1y70A6IHFX286NqJfkB07UU/ILp2o42iLzpqi9lHR+0be+jojLaCfXTU7u6vdKxm5ahuT0dt2ProeN0eLJi3o5fVhlut9rpdx95qpy33F/5pK+eFf9qK9YvfspM5Gvt6St9Yu+Vne1sMNqz8wfstP9utZP7xn//8xl+3n+jh73mwLruVyL2Vv3uKvirlXN6e8H2yew77QhRxRGzHFR0LPrdd5mf3IDI/u/aX+eGJJ/LDE0/kZ1fcMj+74pb5Z/d/9r3ZaF738v68fvn46Grzil0fX/htVguf8t57tfRs77taeiXQd7X0uqHvasOtVkuvSfqull7B9F0tvd752WqTsFp6ddR3tdeqpYTVwidw917ttWqplNfVOrP9Hgc+J/vHqzXHq71WLSWtNtxqtdeqpaTVXquWim/PTZgdT75WLSWt9lq1lLTaa9VSwmrhU5YPVrvwT1sdLfzT1jsLP7yCseH1vb1N229R4VN0ZX54lSHyw+sGkR9eCYj88GwX+eFpLfHDp4LK/PD8Ffnh+SvyT56/efL8hU//lPknz988ef7CR5nK/PD8dW/8j9s2h0c7m59TaJzbvinewQdy/mitttTXjYEQtmuF54p/3Y+MPh8fffysMXxomfjkOXwCmMwPd0CJHz4mSebXOSyD55c7ncLSX/Jqnieubk9ynUwxXHIdYjFccp13MVhyr6MxxkuuUzQGD2D1OnBjvORalw+XPKjk3SVPz1ao5rgjuc5GHC65TkYcLrl2n2d6+a7k2n0Oj0/tPkdLbrX7HC65dp/DJdfuc7jk2n0Olzyo5KMl1+5zuOTafQ6XXLvP4ZJr9zlacqet0HDJOxSJcf0TIUbzfvDyN8KAvxEH/I004G/kAX+jDPgb9fy/4c2Av9HhVkFMqyXFLBwc0/oAc0xlD8jRgDwNKNCAIg0o0YAyDajQgCoMqMc0zL5Ag53aJhvWUyebjws8W5NdX7xWU9wMU/XBTc7vJ+cPk/PHyfkTmz8Hu/LnPf4M538bUpffTr7yl8n5K4f/iygaHBEoIxciUOotRKAcW4hAybQQgbJmIQKlx0I0Pg9qXImcCf/W7/akqzU9b08a+zrz7h3HWJ+3MpPdeaorFtVlV5equuzpkozqsquLVV12dXGqy64uXnXZ1SWoLru6xFvosiw23Wmx96hMl8Xeo9xcFnuPGvJrsfkeheGy2HtUe8ti71HCLYu9UF3mX9TeFOkxpuheA8BC3lEmqDLfKHOh2qyzMhcq5Dorc6Gqr7MyFyoROytzoXqyrzLlQsVnZ2UuVKl2VuZCZW1nZbQG/k6ZcFtl0rrZIpa6o8x9a2BJmfvWwJIy962BBWXqleqZDw0F9vVKMfapHWk9JiuriFcKx4+JeKUc/ZiIV4rcj4l4pTtUHxPxSjezPiRiMFondhDxSrfIPibile6mfUxE7Vg6iBhURFlEa9y6AdCkuCOj9ixdZNSupYuM2rd0kVE7ly4yau/SQ0ar3UsXGbV/6SKjdjAbGRdltC35TpmgynyjjLYP3ylz246gmtcbst2eMrct8kVlZqrbg3k7euGfqWDe4XczVap7/KAScSECVVsLEajKWYiGJ4XL6UW0neoUesyRTfY1EtoJB0tjBkOPobN9gSwNyNGAPA0o0IAiDSjRgDINqNCABjt15/mTIZjJ+e3k/G5yfj85f2DzC/NXQ4hw/uP5pSGkyfkzh38hKjgiUEZ+EUVQ6i1EoBxbiEDJtBCBsmYhAqXHQjQ+D2aY6xZiUl12dcmqy64uRXXZ1aWqLnu6JKO67OpiVZddXZzqsquLv4Uuy2LDnRZ7j8p0Wew9ys1lsfeoIZfF3qMwXBZ7j2rva7H5HiXcstgL1WVdZ0+FfKHKrLMyF6rNOisTVJlvlLlQ1ddZmQuViJ2VuVA92VmZCxWfnZW5UKXaV5lyobK2szJaA3+nzH1r4OOJkaHctwaWlAmqzDfK3LcGlpS5Uj3zofmroV4pxj41zaheKfE+JuKVwvFjIl4pRz8m4pUi92MiXukO1cdEvNLNrI+JqHViBxGvdIvsQyJGc6W7aR8TUTuWDiJqx9JhHFk02rN0kTGojD1k1L6li4zauXSRUXuXLjJq99JFRu1feshotYPZnxgZrbYl3ymjvcZ3ymj78J0y4a7KCFNGo71tkS8qM1Pdvp3/Ge1MBfMe/0yV6h4/qET8InKgamshAlU5C9HwpBDmr0Z36nX89Te8oa3aexwR7pPhI44o4YgyjqjgiCqNKOD8aPxsT5FoeB/s/VoxJx/rcX1UbV5B6iN1t/x+cv4wOX+cnD9Nzp8n5y+T89e5+cfPDf0hfxL47eT89PyV+On5K/HT8zfl1/1Fs70/FOn5m8wxPz1/JX56/kr89PyV+On5G9++HzBb/0n0/JX46fkr8dPzV+IH5e9CBErUhQiUkQvR8NQLNqxEwbstUcYRFRxRpRGNH/AnElkckcMReRxRwBFFHBHOszPOszPOszPOswvOs8dPjXqU3SvR45/osAZ2xj4ftnDGF6FeXofEOrPzNM34KVA/WalIP9wTc359ct4fidyjfz09mcvbTJcne+GwfxFVw/ksLESg63AhAl0vC9Hw2im99XIp+i1RwBFFHFHCEWUcUYERpfGTAQTPTuO3Nle37glI1dstUcARDb/6a3o9DVvLzuco4YgyjqjgiCqNaPw+P5HI4ogcjsjjiAKOCOfZFufZFufZFufZFufZDufZDufZDufZDufZDufZDufZDufZDufZDufZDufZHufZHufZHufZHufZHufZHufZHufZHufZHueQQafHNL/lIQUdNPM3M1PN88TV7YmocwE7iKhTATuIqDMBO4ioEwHbRYw6D7B5GHeKOjqwg4haJ3YQUevEvxFxfXCq5rgjYlAR20XUWeYdRNSO5WeeuCuidiwdgkU7lg4iasfSLmLSjqWDiNqxdBBRO5YOImrH0kHEoCK2i6gdSwcRtWPpIKJ2LB1E1GK7XcQeAyFiWkWMWRRRGMKbegw76EyUcEQZR1RwRJVG1GPYQWciiyPC+VHxOKIwmqjrmN1U4uT8aXL+PDl/mZy/zs1fzeT8dnJ+B+dPAr+fnJ+evxI/PX8lfnr+Ho8pT5Wev8djplOl56/ET8/fY/5s6Pkr8dPz93jMdDb0/JX46fkr8dPzV+IH5e9CBErUhQiUkQvR8NQTRpVmU2lE1uCILI7I4Yg8jijgiCKOKOGIMo4I59kW59kO59kO59kO59luuGd/aEx5doG8UpF+uCd2G1OeveGwL0SO81lYiEDX4UIEul4WouG1kzDMOfuEI8o4ooIjqjSiYHBEjubZYfjVLwwFzyHhiIZf/cJQpxwKjqjSiKLBEVkckcMReRxRwBFFHFHCEeE8O+I8O+I8O+E8O+E8O+E8O+E8O+E8O+E8O+E8O+E8O+E8O+E8O+M8O+M8O+M8O+M8O+M8O+M8O+M8O+M8O+M8O+M8u+AccvyuueuNKc/jt+5dbyRvHr9/7YoiVhWxWcTxO/muKKJVEdtFdCpi6zCXPH5j5RVFDCpiu4haJzYPh87j97leUcSsIraLqB1L85jyXLVjaQ6WYrRj6SCidiwdRNSOpYOI2rF0EDGoiO0iasfSQUTtWDqIqB1LBxG1Y+kgonYs7SJaLbY7iBj2RfTrzkOT3LEuPoTnTl0fon0/ePkbccDfSAP+Rh7wN8qAv1HP/xvfDT/o+jfsgL/hBvwNP+BvDLjO3YDr3A24zl2H6zya5+ZNH12QUmg1/xBdPI6VUOpq/uHx3e/b0Qt9mZq+zkzvzdT0dmp6NzW9n5o+TE0fp6ZPU9NPnbUenbXV1Re9NCzqR+2qew1n8saG4w401idzsttvb4tHJ/4cGgZ03TGJhujqZxIN0TXYJBqiK8FJNAyqYbOG6Kp4Eg3RtflHNFyEQZf9nxRGO4pvhNE2YV+YqLX/N8JoQf+NMFqlfyOMlt7fCBPuKYx/PUziTZEey4hufT1XDHlHxZtW1J1VvGlN3VnFmxbgnVW8abXeWcWblvZ9VUw37QM6q3jTpqGzijftMDqreNN2pLOKQVXsoKL2Ln+jYlo5Yqk7Kmrv0kNF7V16qKi9SwcV813rxQ8Nyiz5rnH+qR1i+a7J/zHB71okfEzwu9YTHxP8rqXHxwS/6x3WTwle7noz9mOCax0+WPC73uL9mOB3vRv8McGDCj5WcO00OwtujXvTbucB9aK95nDJtdscLrn2m8Ml145ztORVe87hkmvXOVxy7TuHS66dZ5Pki4pBVeygovaIPVTUtq+HitrJ/YWK1awc1e2pqM1ZDxWv2m8F83b0v6+1mqs2OntrvWqHsbfWSUv7hX7SKnmhD1PTk5M4Gvt6tt5Yu6G3ZD+LwYaVPni/pe/sUD6+H7z8DTfgb/gBfyMM+BtxwN9IA/5GHvA3yoC/Uc//G84M+BsDrnM34Dp3A65zN+A6dwOuczfgOncDrnM34Dp3A65zP+A69wOucz/gOkdP9RZrQvRkaZmefDdCpEdPU5bpyXcMZHryPQCZnnwPQKYPU9NP7ffoSbHRvL4Jiab646Mfndt6n+/R/cTtWtl3a/qulZ3jfdfKTv2ua0VPXe29VnZF0Xet7Pqj71rZ1UrftYYLrTUJa2VXQn3XeqW6SVrrleomaa1XqptSXtfqzPZ7b/T8yx+v1RyuFT2lsvdar1Q3SWu9Ut0krfVKdVN8e67MbH0YPT2x91qvVDdJa71S3SStddK6aaGftBJa6Cetbb7oM7paseH1ZJZ941jp0fWHSI+uKER6dI0g0oep6dE5LtKjk1mkR2etSI/OWpEenbUSPXpkmkw/ddaih3k9zvaidzEfHu1sfs4Ycs7k7UrRufyTldpSX21PCNuVonPEv+6xRJ+Pdw699mHm8jYR+rlOtOtJuyfQQztkerRviPS6l3zo7Paq2867T9QzzxNXtye4TmEaKXgyl92ajBVcJzANFlznLw0WXKcvjRxD+xA8qOBjBdc6fLDgWof3Fjw9pXt8+7AjuE6KGiy4DpUaLLh2mud5+J7g6KExVwxNq53mYMG10xwsuHaagwUPKvhYwbXTHCy4dpqDBddOc7Dg2mkOFlw7zbGCO+00Bwuujc9gwTuUhS6v7K78w8HL30gD/kYe8DfKgL9Rz/8bPUYpin/DDvgbbsDf6HBjwNXn5er923O5uwfHtD7EG1MxO0CBBhRpQIkGlGlAhQZUYUA95mD2BbI0IEcDGuzUNtmwFnjJ5uMCz9ZkV5Ca4n8cg/jgD5Pzx8n50+T8eXL+wubPwa78eY+/wvnfxk7lnDf80UzObzn8C5HDEYEyciECpd5CBMqxhQiUTAsRKGsWIlB6LETj86DGlciZ8G/9bk+6WtMT5PHV/b8d3nGM9XlLJdmdp7eSUV12dbGqy64uTnXZ1cWrLru6BNVlV5eouuzqklSXXV3yLXRZFlvutNh7VKZfi833KDeXxd6jhlwWe4/CcFnsPaq9ZbHhTou9UF3mzXqT1psiPcYU3WsQVsg7ylyoMuuszIVqs87KXKiQ66zMhaq+vsqUC5WInZW5UD3ZWZkLFZ+dlblQpdpZmaDKfKOM1sDfKXPfGjitmy1iqTvK3LcGlpS5bw0sKXPfGlhQpl6pnvnMkN+HiFeKsU/tSKtXSryPiXilcPyYiFfK0Y+JeKXI/ZCI1lzpDtXHRLzSzayPiah1YgcRr3SL7GMiBhWxXUTtWDqIqB3LX4j4iI43PeKOjNqzdJFRu5YuMmrf0kNGq51LFxm1d+kio3YvXWTU/qWLjEFl/I8yLspoW/KdMtprfKeMtg/fKXPbjqCa13ui3Z4yty3yJWXcTHV7MG9HL/wzFcx7/DNVqnv8oBJxIQo4IlCVsxANTwqX04toO9XJ+lOv4+VvBNyqM46I98moNKJgcEQWR+RwRB5HhPOj8bM9RaLhfbD3a8WcfKzH9VG1+TWt8JG6W/48OX+ZnL/OzT9+Wmdnfjs5v5uc30/OH+D8SeCPk/PT81fip+evxE/P35Rf9xfN9v5QpOdvMof8iZ6/Ej89fyV+ev5K/PT8jW/fD5it/4yfstmZn56/Ej89fyV+UP4uRKBEXYhAGflFNH6YYrBhJQrebYksjsjhiDyOKOCIIo4o4YgyjqjgiCqNqOA8u+A8u+A8u+A8u+A8e/zUqJjWU6eYj2tgZ+zzYQtnpJdFv4bEOrPzNM34KVA/WalIP9wTc359ct4fidyjfz09mcvbTJeFffxcnO/ZF6LA+SwsRKDrcCECXS8L0fDaKb31cin6LVHBEVUYkRs/d0MksjgihyMKMM9247c2V7fuCUjV2y1RwRENv/prej0NW8v2czR+76pIZHFEDkfkcUQBRxRxRAlHlHFEBUeE82yH82yH82yH82yH82yH82yH82yH82yH82yH82yH82yP82yP82yP82yP82yP82yP82yP82yP82yP82yP8+yA8+yA8+yAc8ig02Oa3/Lggg6a+ZuZqeZ54up2RIw6F7CDiDoVsIOIOhOwg4g6EbCDiEFFbB3G7aKODuwgotaJHUTUOvFvRFwfnKo57oio08w7iKizzNtFTNqx/MwTd0XUjqU9WJJ2LB1E1I6lg4hBRWwXUTuWDiJqx9JBRO1YOoioHUsHEbVjaRcxa8fSQUTtWDqIqMV2BxF3S5ya7Krh+5cKe7K4Ep/rdCVVQcNo7DrD6vHzdsfO/qyDDwLtjzr4JJClATkakKcBBRpQpAHRfKjk0UAvU4+m+uNwkUbZulLmxq9T41czN76dG9/Nje/nxg9z40c2fhLw09z48NSV8OGpK+HDU/d4/Lc38NQ9nt7sDTx1JXx46kr48NSV8OGpezy52Rt46kr48NSV8OGpK+FzUncB4uToF5DlJOMCNDrrbFiHaUWb3BbI0YA8DSjQgCINKNGAMg2o0IAqDMgZGhDNqR3NqR3NqR3NqR3NqR3Nqd1op3ZvQC7mwwrc2bwOHXcmb+ELGN6W+uoewubt9N6P9jf/6uSjz8cj3A/HiHs/+jp/m50fg99W9T7SgBINqMCAwuCPf6huvRxDld5gMMXsDh+cati4Td2HqBo2a5hUw2YNs2rYrGFRDZs1rKph47PNPhrVsFlDrQ/bNdT6sHVQgo9eNWzWMKiGzRpqn9I6r8NH7VPaM0X7lHYNtU9p11D7lGYNk/Yp7Rpqn9KuofYp7Rpqn9KuYVANmzXUPqVdQ+1T2jXUGrtZw9xe2+TwVMXl5AUN/0wFeZ768fP2gZ8caECRBpRoQJkGVGhAFQbUYfBMZyCaD3UYPNMZyA8G8m9vrX/cizlOO2nvuy9hbvw4N36aGz/PjV/mxq9T41czN75l4ycB382ND09dCR+euhI+PHWFoSEVnrrC3IcKT10JH566Ej48dY/xg4Gn7vHch2DgqSvhw1NXwoenroTPSd0FiJOjCxAnGReg0Vn3tnkuBe+2QIUGVGFA1tCALA3I0YA8DSjQgCINKNGAaE5taU5taU7taE7taE7tRjt1XLciPH7OxwWvM3ad0WGkxx5qTeuxYdsWOg9eqAg/2gtzfn1s3p/0+PE8j+AqBv0LyFvMB2EB4lyCCxDnUlmAwmCg9Na0pei3QJEGlGhAmQZUaEAVBhQszKnD6Mu+uvXxxlS93QJFGtDoy76m18viatn5DGUaUKEBVRhQNDQgSwNyNCBPAwo0oEgDojl1pDl1pDl1pDl1ojl1ojl1ojl1ojl1ojl1ojl1ojl1ojl1ojl1ojl1pjl1pjl1pjl1pjl1pjl1pjl1pjl1pjl1pjl1oRnj8M1ttr6AHt/1vQHtHD3FqPAwfIfdjBoej8YNwzeaXVHDoho2a1hVw1YNh+/7u6KGVjVsHLEShu+AvKKGWh+2axhUw8YRzWH4htQraphUw2YNtU9pHRUeqvYp7ZmifUqrhtFon9KuofYp7Rpqn9KuofYp7RoG1bBZQ+1T2jXUPqVdQ+1T2jXUPqVZQ6s1druGHWqbFd3ld/R9DYWJuLHHaIK+QJkGVGhAFQbUYzRBXyBLA3I0IJoPuUADioOBuk68jS7NjZ/nxi9z49ep8b2ZG9/Oje/mxvds/CTgh7nx4akr4cNTV8KHp+7xqPDo4al7PO05enjqCvgBnroSPjx1JXx46h5Pe44BnroSPjx1JXx46kr4nNRdgDg5ugBxknEBGp11wvDQGA0NyNKAHA3I04ACDSjSgBINKNOACg2I5tSJ5tSJ5tSJ5tSJ5tRptFN/aFR4TBG8UBF+tBd2GxUes8WgL0Ae80FYgDiX4ALEuVQWoNHFkjBVOeZMAyo0oAoDKoYGZGlAHubUZfRlL0zmjiXTgEZf9sLkpVgqDKgaGpClATkakKcBBRpQpAElGlCmAdGcusKcOhmYUycDc+pkYE6dDMypk4E5dTIwp04G5tTJwJw6GZhTJ0NzaktzaktzaktzaktzaktzaktzaktzaktzaktzaktzakdzakczxuGb2643KjwN32F3vdG4afhGswtqOHy32xU1tKphs4ZONWzW0KuGjSNW0vAdkFfUUOvDdg21Pmwd0ZyGb0i9ooZFNWzWUPuU1lHhKWif0pwpQfuUdg21T2nXUPuUdg2DatisofYp7Rpqn9KuofYp7Rpqn9KuofYpzRpG7VPaNdQau13D3dqm1Lr+UhQk9O65TOd9FSSMxq4Tph4/b3bdpP3JBB/kqSye/bkEH+SxMB4H4/EwngDjgflPSoN5XlYeTfXHkSKNlU0pT01fpqavM9NnMzW9nZreTU3vp6YPaPok0Mep6dlZK9Gzs1aiZ2ft8QzulNlZezxFORV21kr07KyV6NlZK9Gzs/Z4gnIq7KyV6NlZK9Gzs1aix2TtwoNJz4UHk4dfPHVwwtmwTruKj1vzWx4L43EwHg/jCTCeCONJMJ4M4ykwnoriyYblz9mw/Dkblj9nw/LnbFj+nA3Ln7MZ7M/ujcfFfFhtO5vXwd/O5C175rLbF4atIWzY7WBf869+Pfp8PET9cJR3toOv8LfZ9TF4v1UywHgijCezeNzYT36obr0QQ5VeHzDFqI3srErYtrM8u6AStkoYVcJWCZNK2CphVglbJSwqYdvDydlVlbBRQq91YbOEWhc2TjbI3qmErRJ6lbBVwqASto3XyF67k+Y40e6kWULtTpol1O6kWULtTlolDNqdNEuo3UmzhNqdNEuo3UmzhEElbJVQu5NmCbW0bpUwNhc1tqxvrH/fBbJ7cEzr4zwxlX84eMGxLBzHwvEsnMDCiSycxMLJLJzCwqkonDTUlW2yYY2qZPNxVNma7PPO9ePnuBlLkpOdmt5NTe+npg9T00cy/ePmy0qf9+gTmv5tREDO2wfBU56avlDoF57K4smYPFx4MAm38GAya+HBpNDCg8mVhQeTFAvPaO8/bTapq/UJ4o0Nx/dGYn3edEl25/mBnFWVHVWKqrKjSlVVtqoUo6rsqGJVlR1VnKqyo4pXVXZUCTdQZVlqvM9S71CFLku9Q2m5LPUO9eKy1DsUgV9LrXeo7Jal3qFcW5Z6mRrMm/WWqzdFeqAiutdojJB3dLlMFdZZl6C67OpymaKtsy6XqfA663KZcrCzLpepHTvrcplCs6suxVymKu2sy2VK2M66aL27r8td6920PuAdS93RJaguu7rctd6VdLlrvSvpcp365UMDAIu9TnR9aO9LsddJuY9JeJ1A/JiE18nOj0l4nZj9mITXuQP1MQmvc7PqYxJqXdgqobvOLbCPSXidu2Ufk1C7k2YJtTsRJbTGrVvyTIo7IgYVsV1E7VA6iKg9SgcRtUvpIKL2KR1E1E6lXUSvvUoHEbVb+Q8iLrpoC7Kvi/YV+7oE1WVXl5tW/9Ws32FXt6fLTQt6UZd5avRg3o5e6Ocpjvfo56lKd+gDphxceDCV1cKDqWgWnsHJ4HJ68WynKJVw4rX79ReiZa147ATOv+CBfSJigvFkGE+B8VQWz+g5nCIPzH9Gz8oUeQb3tt6vtXDysR7XP9Xm1xTAR7Zu6cPU9HFq+jQ1fZ6avkxNX2emHz1ZszO9RdMngd5NTc/OWomenbUSPTtrU37dITTb+zyZnbXJHNOzs1aiZ2etRM/OWoG+sLM2vt3XN1vPKeyslejZWSvRs7NWosdk7cKDSc+FB5OHC8/ghAs2rDzBuy1PgfFUFs/oWXwij4XxOBiPh/EEGE+E8SQYD8yfK8yfK8ufq2H5czUsf66jpzDFtD5Rm2I+rm6dsc+HIJyRXvn6Gq/qzPb5ljp6qtJP1imyD/bAnF+fmffHEvfYX08w5vI2KeVJXinkXzzWUj4FCw/m6lt4MFfJwhPG8qS37ixFv+WJMJ4E48kwngLjqSye0bvtJX8evWW4uvX5+1S93fJEGM/g672m11Ootex8fjKMp8B4Kotn9KY/kcfCeByMx8N4Aownwnhg/uxh/uxh/uxh/hxg/hxg/hxg/hxg/hxg/hxg/hxg/hxg/hxg/hxg/hxh/hxh/hxh/hxh/hxh/hxh/hxh/hxh/hxh/pxgfph0vkrjuw3q6I1wU04PNc8TP+7I7kiok/KaJdQ5ec0S6pS8VgmzzshrllAn5DUOo65Zh+k1S6h1YbOEQSUUJVwfZ6o57kios7ybJdRJ3s0SanfyEy/clVC7k+Y40e6kVcKi3UmzhNqdNEuo3UmzhNqdNEsYVMJWCbU7aZZQu5NmCbU7aZZQu5NWCauW1s0S7hc14YleqhdUKWEdOFtiFg6Oxq4DoB4/b7fOfDNI4HM8GcZTYDyVxJPNN4MEPsdjYTwOxoPynwdPGMzzsvJoqj+OFGHY64M+Tk2fpqbPU9OXqenrzPTWTE1vp6Z3aPok0Pup6dlZK9Gzs1aiZ2ft4XjsBz07aw+HHD/o2Vkr0bOzVqB37KyV6NlZezjk+EHPzlqJnp21Ej07ayV6TNYuPJj0XHgwebjwDE44G9aBVfFxa37LU1k83sB4LIzHwXg8jCfAeCKMJ8F4MowH5s8e5s9hsD+7Nx73dvjuuGWb13HLzuQtu+Wy29d387aGsGUf7Gv+1W9Fn49HVx+NUH6QD77C3waGx+C3FVgoLJ5oYDxjEz1Ut37wQ5WGpM8wguAhYVAJm7bdPiTMKmGrhEUlbJWwqoSNEiajErZKaFXCpoc5HxI6lbBVQq0LmyUMKmHT5u+HhFElbJUwqYStEmp30jaC4CGhdifNcaLdSauEWbuTZgm1O2mWULuTZgm1O2mWMKiErRJqd9IsoXYnzRJqd9IsoXYnrRIWLa2bJWwualJ5e99AFQ7O9bUF+PHzdgtwSTCeDOMpMJ7K4qkGxmNhPA7GA/OfGmA8cTDPe7Q0b/CtaWr6PDV9mZq+TkxvjZma3k5N76am92j6JNCHqenZWSvRs7NWomdn7fFIBGvYWXu8sd0adtYK9JadtRI9O2slenbWHm9st5adtRI9O2slenbWSvSYrF14MOm58GDycOEZm3DFhNetf5PShscZGI+F8TgYj4fxBBhPhPEkGE+G8RQYD8yfPcyfPcyfPcyfPcyfPcyf/WB/tm88Nh0/+iCM1LA+cdmFkRrWD/Y19+rXi2sZqWHD4Cvcm/Xo4t1mKIwNHsYz+Ar38fUv61PZ8kQYT4LxZBhPgfFUFk80MB4L43EwHg/jgflzhPlzhPlzhPlzhPlzhPlzgvlzgvlzgvlzgvlzgvlzgvlzgvlzgvlzgvlzgvlzhvlzhvlzhvlzhvlzHuzPwdiVJ9jtN+45wngSjCfDeAqMp7J4ioHxOBjP4OeDymtrZy6XGBFsR2+lnFHC47GYdvTuxgtKOHpD5hUltCphq4ROJWyV0KuEbcMW7OjNxVeUUOvCZgm1LmwczmpH7wy/ooRFJWyVULuTxhHBzmh30hgnzmh30iyhdifNEmp30ixhUAlbJdTupFlC7U6aJdTupFlC7U6aJdTupFVCq91Js4RaWjdL2FzUhNcuuWiNcHA0r5GYj583IzFd+3CJzjyVxdM+XKIzj4XxOBiPh/EEGA/Mf9qHS/yQ52Xl0ciji44HTLr2URQfpS9T09eZ6b2Zmt5OTe+mpvdT0wc0fRLo49T07KyV6NlZK9Gzs/Z4JK/z7Kw9HqzqAjtrJXp21kr07KyV6NlZezxY1bWP1fkoPTtrJXp21kr0mKxdeDDpufBg8vCLJw5OOBvC6+jktjwWxuNgPB7GE2A8EcaTYDwZxlNgPJXFk2D+nGD+nGD+nGD+nGD+nGD+nAb7s3vjcTEfVtvCSF6XMpddGMnr8mBf869+PfqWkbwuD77Cg32pHvy2gs8BxhNhPJnFU8Z+8qd8W/rxSA1XrErYto3claAStkoYVcJWCZNK2CphVglbJSwqYePDyaWqhI0SVq0LmyXUurBxmIGrTiVsldCrhK0SBpWwcaRG1e6kOU60O2mWULuTZgm1O2mWULuTRgm90e6kWULtTpol1O6kWULtTpolDCphq4TanTRLqKV1q4Ttg118Wt+f4d+78N2Dk8vpefTj580DPY/Fw3gCjCfCeBKMJ8N4CoynsngczH/aR8R05nFjebxfIy75WI8jTtqw7p2fmj5MTR+npk9T0+ep6cvU9HVmem/Q9Emgt1PTs7NWomdnrUTPztrjER/es7P2eFCD9+yslejZWSvRs7NWomdn7fGgBh/YWSvRs7NWomdnrUSPydqFB5OeCw8mDxeewQn3tgEuBe+2PBnGU2A8lcUTDYzHwngcjMfDeAKMJ8J4YP4cYf4cYf4cYf6cYP6cBvtzXPcSPH7Ox9WtM3YdqWGkhxhqTeuxYdv/Jcddp8g+2ANzfn1m3p/a+PH4DZ8KhfyLJxvKp2DhwVx9Cw/mKll4BldH6a07S9FveQKMJ8J4Eownw3gKi6cYlj+Xwdd7devjial6u+UJMJ7B13tNb+9xKzufnwTjyTCeAuOpLJ5qYDwWxuNgPB7GE2A8MH+uMH+uMH+uMH+uLH8OhuXPwbD8ORiWPwfD8udgWP4cDMufg2H5czAsfw6G5c/BwPzZwvzZwvzZwvzZwvzZwvzZwvzZwvzZwvzZwvxw9B40W188j6/u3nh2jp5iXHcYvRFuRgmPR9SG0TvCrihhVglbJSwqYauEVSVslHD0LsEpJTwcfBJGb1W8ooRaFzZLqHVh46DkMHrn6BUljCphq4TanTSO6w5eu5PmONHupFlC7U5aJQzanTRLqN1Js4TanTRLqN1Js4RBJWyVULuTZgm1O2mWULuTZgm1tG6UMO4/qpns8w8k95IwPH9nN4JSfN7PSCW+/c4WqZjnkeXtjffr2eOpZ0+nnj23nd3555HubSP1evbSeHa37tOOdnv2eubZ9x+B63Z2e+rZ3aln96eevfUTadY972+vM3ie3TX+q/r43Gjo087Z7alnd6ee3Z969nDq2Rsd2Ndnevhat2dPp549n3r2curZ65ln943X6mtESXBhe3Z76tndqWdvvFaDeTpwsFsH9uHUs8dTz55OPXs+9ezl1LPXM88eWq9V/xyzGsLW34M99ezu1LP7U88eTj17PPXs6dSz51PPvn+t1mcDne22C90fWZjj+jt553fcL37H/+J3wi9+Z/fTkd36O8Vtfyf94nfyL36n/OJ36s9/Z3/smvA79he/437xO/4Xv7N/p9k97/WUsPM76Re/k3/xO+UXv7N/w+3wnsg3w7yOf8f+4nfcL37H/+J3wi9+J/7id9Ivfif//HdK652ZwzsExZ56dnfq2f2pZ2+sNY7vFZZ46tnTqWc/9S5qKaeevfUuajDr3bztZ6aaU89uTz176+f9m/uce91+Wrv9F8fudzrVl+edgRrMyxzt3lcp3pfnnDbv69vBu1NRa3l+teSNcccHW2vy+tWSNbW8g/y7fMmceZs4mXDq2eOpZ0+nnj0P+9ia+ronYNL7B3dBKR9BsW6LYusolFLWFH18o7qD4gwHxY5DWb8vLsX5HRTHQfED/4HiCyXsoJz5DWpyZ36Dmrw59ez21LO7U8/e+gFbX6HoStiePZx69njq2Vu/azNvT6Vsz55PPXs59eyt1+p6b9Kbre6t9++Fs9tTz+5OPbs/9ezh1LPHU8/eeq2ud+68337eW+/fC2cvp569nnn2aE49uz317O7Us/tTz954rR4+w5JiPPXs6dSz51PPXs48ezKnnj38+GnVlBrVPLx7nlI59ez1zLPn1irl6E5oymfeTUz51I4ityb90Z3/lE+9AnM98+zl1Ou72FPP7k49e2taHj29l1q/LRLOHk89ezr17PnUs5dTz37mE5+p9dsi4ez21LO7U8/e+hTZ0fOkqfWbLuHs8dSzp1PPnk89ezn17PXEs2fT+sTn0fOk2dhTz+5OPbs/9ezh1LPHU8+eTj17PvXs5dSzn/l0dranXqv21GvVnnqt2lOvVdt6rR49g5xtPPXs6dSz51PPXk49ez3z7M6cenZ76tndqWf3p5791GvVnXqtulOvVXfqtepOvVa/ecLhaJ9G9j/fc5G9/8XvhF/8TvzF7/x8z0X2+Re/U37xOz/fc5GD+cXv2F/8jvvF7/hf/E74xe/8fM9FDvkXv1N+8Tv1578Tf77nIkf7i99xv/gd/4vfCb/4nfiL30m/+J38i98pP/+ddOZOipzcqWf3p549nHr2M3dS5JROPXs+9ezl1LPXM89+6nef+dTvPnPzd5/HZ/ennr31Wv3rh4FjfSZkMsIYsGl2geR80m6E5ezl1LOf+Xh0LubUs5+qezlV93Kq7vVU3as99eytRnr08HWu/tSzh1PPHk89ezr17PnUs5dTz15PPHtp/ZLx8JH60volo3B2d+rZ/alnD6eePZ569nTq2Vuv1aNH6kvzhsnjs5+5haRYc+rZ7alnd6ee3Z969nDq2eOpZ0+nnv3Ua9Weeq3aU69Vd+q16s7cQlKcO/Xs/tSzh1PPHk89ezr17PnUs5dTz37mdq/izalnP/Va9adeq/7Ua9Wfeq36U69Vf+Z2r+LzqWcvp579zM0mJZhTz37WdpB/e/w//+9/+dd/+i//9Z//+//z+IU//9v//h//7X/907/8j+X//V//3/98/i//9V//6Z//+Z/+7//8P//1X/7bf/+//ve//vf//M//8t/+/G//h1n+4/98sCbznx7/WeyD/M9V6vx/8v7PKr7+5/Bg/vOf+c9/Zb9+o8R//438oHkQ/f8=",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "4": {
      "source": "unconstrained fn partition<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_recursive<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) {\n    if low < high {\n        let pivot_index = partition(arr, low, high, sortfn);\n        if pivot_index > 0 {\n            quicksort_recursive(arr, low, pivot_index - 1, sortfn);\n        }\n        quicksort_recursive(arr, pivot_index + 1, high, sortfn);\n    }\n}\n\npub(crate) unconstrained fn quicksort<T, Env, let N: u32>(\n    _arr: [T; N],\n    sortfn: fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = _arr;\n    if arr.len() <= 1 {} else {\n        quicksort_recursive(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n",
      "path": "std/array/quicksort.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "6": {
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n",
      "path": "std/collections/bounded_vec.nr"
    },
    "7": {
      "source": "use crate::cmp::Eq;\nuse crate::collections::bounded_vec::BoundedVec;\nuse crate::default::Default;\nuse crate::hash::{BuildHasher, Hash, Hasher};\nuse crate::option::Option;\n\n// We use load factor alpha_max = 0.75.\n// Upon exceeding it, assert will fail in order to inform the user\n// about performance degradation, so that he can adjust the capacity.\nglobal MAX_LOAD_FACTOR_NUMERATOR: u32 = 3;\nglobal MAX_LOAD_FACTOR_DEN0MINATOR: u32 = 4;\n\n/// `HashMap<Key, Value, MaxLen, Hasher>` is used to efficiently store and look up key-value pairs.\n///\n/// `HashMap` is a bounded type which can store anywhere from zero to `MaxLen` total elements.\n/// Note that due to hash collisions, the actual maximum number of elements stored by any particular\n/// hashmap is likely lower than `MaxLen`. This is true even with cryptographic hash functions since\n/// every hash value will be performed modulo `MaxLen`.\n///\n/// Example:\n///\n/// ```noir\n/// // Create a mapping from Fields to u32s with a maximum length of 12\n/// // using a poseidon2 hasher\n/// use std::hash::poseidon2::Poseidon2Hasher;\n/// let mut map: HashMap<Field, u32, 12, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n///\n/// map.insert(1, 2);\n/// map.insert(3, 4);\n///\n/// let two = map.get(1).unwrap();\n/// ```\npub struct HashMap<K, V, let N: u32, B> {\n    _table: [Slot<K, V>; N],\n\n    /// Amount of valid elements in the map.\n    _len: u32,\n\n    _build_hasher: B,\n}\n\n// Data unit in the HashMap table.\n// In case Noir adds support for enums in the future, this\n// should be refactored to have three states:\n// 1. (key, value)\n// 2. (empty)\n// 3. (deleted)\nstruct Slot<K, V> {\n    _key_value: Option<(K, V)>,\n    _is_deleted: bool,\n}\n\nimpl<K, V> Default for Slot<K, V> {\n    fn default() -> Self {\n        Slot { _key_value: Option::none(), _is_deleted: false }\n    }\n}\n\nimpl<K, V> Slot<K, V> {\n    fn is_valid(self) -> bool {\n        !self._is_deleted & self._key_value.is_some()\n    }\n\n    fn is_available(self) -> bool {\n        self._is_deleted | self._key_value.is_none()\n    }\n\n    fn key_value(self) -> Option<(K, V)> {\n        self._key_value\n    }\n\n    fn key_value_unchecked(self) -> (K, V) {\n        self._key_value.unwrap_unchecked()\n    }\n\n    fn set(&mut self, key: K, value: V) {\n        self._key_value = Option::some((key, value));\n        self._is_deleted = false;\n    }\n\n    // Shall not override `_key_value` with Option::none(),\n    // because we must be able to differentiate empty\n    // and deleted slots for lookup.\n    fn mark_deleted(&mut self) {\n        self._is_deleted = true;\n    }\n}\n\n// While conducting lookup, we iterate attempt from 0 to N - 1 due to heuristic,\n// that if we have went that far without finding desired,\n// it is very unlikely to be after - performance will be heavily degraded.\nimpl<K, V, let N: u32, B> HashMap<K, V, N, B> {\n    /// Creates a hashmap with an existing `BuildHasher`. This can be used to ensure multiple\n    /// hashmaps are created with the same hasher instance.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    /// let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::with_hasher(my_hasher);\n    /// assert(hashmap.is_empty());\n    /// ```\n    // docs:start:with_hasher\n    pub fn with_hasher<H>(_build_hasher: B) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let _table = [Slot::default(); N];\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    /// Clears the hashmap, removing all key-value pairs from it.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// assert(!map.is_empty());\n    /// map.clear();\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:clear\n    pub fn clear(&mut self) {\n        // docs:end:clear\n        self._table = [Slot::default(); N];\n        self._len = 0;\n    }\n\n    /// Returns `true` if the hashmap contains the given key. Unlike `get`, this will not also return\n    /// the value associated with the key.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// if map.contains_key(7) {\n    ///     let value = map.get(7);\n    ///     assert(value.is_some());\n    /// } else {\n    ///     println(\"No value for key 7!\");\n    /// }\n    /// ```\n    // docs:start:contains_key\n    pub fn contains_key<H>(self, key: K) -> bool\n    where\n        K: Hash + Eq,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:contains_key\n        self.get(key).is_some()\n    }\n\n    /// Returns `true` if the length of the hash map is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// assert(map.is_empty());\n    ///\n    /// map.insert(1, 2);\n    /// assert(!map.is_empty());\n    ///\n    /// map.remove(1);\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:is_empty\n    pub fn is_empty(self) -> bool {\n        // docs:end:is_empty\n        self._len == 0\n    }\n\n    /// Returns a vector of each key-value pair present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let entries = map.entries();\n    ///\n    /// // The length of a hashmap may not be compile-time known, so we\n    /// // need to loop over its capacity instead\n    /// for i in 0..map.capacity() {\n    ///     if i < entries.len() {\n    ///         let (key, value) = entries.get(i);\n    ///         println(f\"{key} -> {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:entries\n    pub fn entries(self) -> BoundedVec<(K, V), N> {\n        // docs:end:entries\n        let mut entries = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                // SAFETY: slot.is_valid() should ensure there is a valid key-value pairing here\n                let key_value = slot.key_value().unwrap_unchecked();\n                entries.push(key_value);\n            }\n        }\n\n        let self_len = self._len;\n        let entries_len = entries.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {entries_len}.\";\n        assert(entries.len() == self._len, msg);\n\n        entries\n    }\n\n    /// Returns a vector of each key present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let keys = map.keys();\n    ///\n    /// for i in 0..keys.max_len() {\n    ///     if i < keys.len() {\n    ///         let key = keys.get_unchecked(i);\n    ///         let value = map.get(key).unwrap_unchecked();\n    ///         println(f\"{key} -> {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:keys\n    pub fn keys(self) -> BoundedVec<K, N> {\n        // docs:end:keys\n        let mut keys = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (key, _) = slot.key_value_unchecked();\n                keys.push(key);\n            }\n        }\n\n        let self_len = self._len;\n        let keys_len = keys.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {keys_len}.\";\n        assert(keys.len() == self._len, msg);\n\n        keys\n    }\n\n    /// Returns a vector of each value present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let values = map.values();\n    ///\n    /// for i in 0..values.max_len() {\n    ///     if i < values.len() {\n    ///         let value = values.get_unchecked(i);\n    ///         println(f\"Found value {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:values\n    pub fn values(self) -> BoundedVec<V, N> {\n        // docs:end:values\n        let mut values = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (_, value) = slot.key_value_unchecked();\n                values.push(value);\n            }\n        }\n\n        let self_len = self._len;\n        let values_len = values.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {values_len}.\";\n        assert(values.len() == self._len, msg);\n\n        values\n    }\n\n    /// Iterates through each key-value pair of the HashMap, setting each key-value pair to the\n    /// result returned from the given function.\n    ///\n    /// Note that since keys can be mutated, the HashMap needs to be rebuilt as it is iterated\n    /// through. If this is not desired, use `iter_values_mut` if only values need to be mutated,\n    /// or `entries` if neither keys nor values need to be mutated.\n    ///\n    /// The iteration order is left unspecified. As a result, if two keys are mutated to become\n    /// equal, which of the two values that will be present for the key in the resulting map is also unspecified.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Add 1 to each key in the map, and double the value associated with that key.\n    /// map.iter_mut(|k, v| (k + 1, v * 2));\n    /// ```\n    // docs:start:iter_mut\n    pub fn iter_mut<H>(&mut self, f: fn(K, V) -> (K, V))\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_mut\n        let mut entries = self.entries();\n        let mut new_map = HashMap::with_hasher(self._build_hasher);\n\n        for i in 0..N {\n            if i < self._len {\n                let entry = entries.get_unchecked(i);\n                let (key, value) = f(entry.0, entry.1);\n                new_map.insert(key, value);\n            }\n        }\n\n        self._table = new_map._table;\n    }\n\n    /// Iterates through the HashMap, mutating each key to the result returned from\n    /// the given function.\n    ///\n    /// Note that since keys can be mutated, the HashMap needs to be rebuilt as it is iterated\n    /// through. If only iteration is desired and the keys are not intended to be mutated,\n    /// prefer using `entries` instead.\n    ///\n    /// The iteration order is left unspecified. As a result, if two keys are mutated to become\n    /// equal, which of the two values that will be present for the key in the resulting map is also unspecified.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Double each key, leaving the value associated with that key untouched\n    /// map.iter_keys_mut(|k| k * 2);\n    /// ```\n    // docs:start:iter_keys_mut\n    pub fn iter_keys_mut<H>(&mut self, f: fn(K) -> K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_keys_mut\n        let mut entries = self.entries();\n        let mut new_map = HashMap::with_hasher(self._build_hasher);\n\n        for i in 0..N {\n            if i < self._len {\n                let entry = entries.get_unchecked(i);\n                let (key, value) = (f(entry.0), entry.1);\n                new_map.insert(key, value);\n            }\n        }\n\n        self._table = new_map._table;\n    }\n\n    /// Iterates through the HashMap, applying the given function to each value and mutating the\n    /// value to equal the result. This function is more efficient than `iter_mut` and `iter_keys_mut`\n    /// because the keys are untouched and the underlying hashmap thus does not need to be reordered.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Halve each value\n    /// map.iter_values_mut(|v| v / 2);\n    /// ```\n    // docs:start:iter_values_mut\n    pub fn iter_values_mut(&mut self, f: fn(V) -> V) {\n        // docs:end:iter_values_mut\n        for i in 0..N {\n            let mut slot = self._table[i];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                slot.set(key, f(value));\n                self._table[i] = slot;\n            }\n        }\n    }\n\n    /// Retains only the key-value pairs for which the given function returns true.\n    /// Any key-value pairs for which the function returns false will be removed from the map.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// map.retain(|k, v| (k != 0) & (v != 0));\n    /// ```\n    // docs:start:retain\n    pub fn retain(&mut self, f: fn(K, V) -> bool) {\n        // docs:end:retain\n        for index in 0..N {\n            let mut slot = self._table[index];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                if !f(key, value) {\n                    slot.mark_deleted();\n                    self._len -= 1;\n                    self._table[index] = slot;\n                }\n            }\n        }\n    }\n\n    /// Returns the current length of this hash map.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // This is equivalent to checking map.is_empty()\n    /// assert(map.len() == 0);\n    ///\n    /// map.insert(1, 2);\n    /// map.insert(3, 4);\n    /// map.insert(5, 6);\n    /// assert(map.len() == 3);\n    ///\n    /// // 3 was already present as a key in the hash map, so the length is unchanged\n    /// map.insert(3, 7);\n    /// assert(map.len() == 3);\n    ///\n    /// map.remove(1);\n    /// assert(map.len() == 2);\n    /// ```\n    // docs:start:len\n    pub fn len(self) -> u32 {\n        // docs:end:len\n        self._len\n    }\n\n    /// Returns the maximum capacity of this hashmap. This is always equal to the capacity\n    /// specified in the hashmap's type.\n    ///\n    /// Unlike hashmaps in general purpose programming languages, hashmaps in Noir have a\n    /// static capacity that does not increase as the map grows larger. Thus, this capacity\n    /// is also the maximum possible element count that can be inserted into the hashmap.\n    /// Due to hash collisions (modulo the hashmap length), it is likely the actual maximum\n    /// element count will be lower than the full capacity.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_map: HashMap<Field, Field, 42, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// assert(empty_map.len() == 0);\n    /// assert(empty_map.capacity() == 42);\n    /// ```\n    // docs:start:capacity\n    pub fn capacity(_self: Self) -> u32 {\n        // docs:end:capacity\n        N\n    }\n\n    /// Retrieves a value from the hashmap, returning `Option::none()` if it was not found.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn get_example(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    ///     let x = map.get(12);\n    ///\n    ///     if x.is_some() {\n    ///         assert(x.unwrap() == 42);\n    ///     }\n    /// }\n    /// ```\n    // docs:start:get\n    pub fn get<H>(self, key: K) -> Option<V>\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:get\n        let mut result = Option::none();\n\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let slot = self._table[index];\n\n                // Not marked as deleted and has key-value.\n                if slot.is_valid() {\n                    let (current_key, value) = slot.key_value_unchecked();\n                    if current_key == key {\n                        result = Option::some(value);\n                        should_break = true;\n                    }\n                }\n            }\n        }\n\n        result\n    }\n\n    /// Inserts a new key-value pair into the map. If the key was already in the map, its\n    /// previous value will be overridden with the newly provided one.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// map.insert(12, 42);\n    /// assert(map.len() == 1);\n    /// ```\n    // docs:start:insert\n    pub fn insert<H>(&mut self, key: K, value: V)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:insert\n        self.assert_load_factor();\n\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let mut slot = self._table[index];\n                let mut insert = false;\n\n                // Either marked as deleted or has unset key-value.\n                if slot.is_available() {\n                    insert = true;\n                    self._len += 1;\n                } else {\n                    let (current_key, _) = slot.key_value_unchecked();\n                    if current_key == key {\n                        insert = true;\n                    }\n                }\n\n                if insert {\n                    slot.set(key, value);\n                    self._table[index] = slot;\n                    should_break = true;\n                }\n            }\n        }\n    }\n\n    /// Removes the given key-value pair from the map. If the key was not already present\n    /// in the map, this does nothing.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// map.insert(12, 42);\n    /// assert(!map.is_empty());\n    ///\n    /// map.remove(12);\n    /// assert(map.is_empty());\n    ///\n    /// // If a key was not present in the map, remove does nothing\n    /// map.remove(12);\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:remove\n    pub fn remove<H>(&mut self, key: K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:remove\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let mut slot = self._table[index];\n\n                // Not marked as deleted and has key-value.\n                if slot.is_valid() {\n                    let (current_key, _) = slot.key_value_unchecked();\n                    if current_key == key {\n                        slot.mark_deleted();\n                        self._table[index] = slot;\n                        self._len -= 1;\n                        should_break = true;\n                    }\n                }\n            }\n        }\n    }\n\n    // Apply HashMap's hasher onto key to obtain pre-hash for probing.\n    fn hash<H>(self, key: K) -> u32\n    where\n        K: Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        let mut hasher = self._build_hasher.build_hasher();\n        key.hash(&mut hasher);\n        hasher.finish() as u32\n    }\n\n    // Probing scheme: quadratic function.\n    // We use 0.5 constant near variadic attempt and attempt^2 monomials.\n    // This ensures good uniformity of distribution for table sizes\n    // equal to prime numbers or powers of two.\n    fn quadratic_probe(_self: Self, hash: u32, attempt: u32) -> u32 {\n        (hash + (attempt + attempt * attempt) / 2) % N\n    }\n\n    // Amount of elements in the table in relation to available slots exceeds alpha_max.\n    // To avoid a comparatively more expensive division operation\n    // we conduct cross-multiplication instead.\n    // n / m >= MAX_LOAD_FACTOR_NUMERATOR / MAX_LOAD_FACTOR_DEN0MINATOR\n    // n * MAX_LOAD_FACTOR_DEN0MINATOR >= m * MAX_LOAD_FACTOR_NUMERATOR\n    fn assert_load_factor(self) {\n        let lhs = self._len * MAX_LOAD_FACTOR_DEN0MINATOR;\n        let rhs = self._table.len() * MAX_LOAD_FACTOR_NUMERATOR;\n        let exceeded = lhs >= rhs;\n        assert(!exceeded, \"Load factor is exceeded, consider increasing the capacity.\");\n    }\n}\n\n// Equality class on HashMap has to test that they have\n// equal sets of key-value entries,\n// thus one is a subset of the other and vice versa.\n// docs:start:eq\nimpl<K, V, let N: u32, B, H> Eq for HashMap<K, V, N, B>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    B: BuildHasher<H>,\n    H: Hasher,\n{\n    /// Checks if two HashMaps are equal.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map1: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// let mut map2: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    ///\n    /// map1.insert(1, 2);\n    /// map1.insert(3, 4);\n    ///\n    /// map2.insert(3, 4);\n    /// map2.insert(1, 2);\n    ///\n    /// assert(map1 == map2);\n    /// ```\n    fn eq(self, other: HashMap<K, V, N, B>) -> bool {\n        // docs:end:eq\n        let mut equal = false;\n\n        if self.len() == other.len() {\n            equal = true;\n            for slot in self._table {\n                // Not marked as deleted and has key-value.\n                if equal & slot.is_valid() {\n                    let (key, value) = slot.key_value_unchecked();\n                    let other_value = other.get(key);\n\n                    if other_value.is_none() {\n                        equal = false;\n                    } else {\n                        let other_value = other_value.unwrap_unchecked();\n                        if value != other_value {\n                            equal = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        equal\n    }\n}\n\n// docs:start:default\nimpl<K, V, let N: u32, B, H> Default for HashMap<K, V, N, B>\nwhere\n    B: BuildHasher<H> + Default,\n    H: Hasher + Default,\n{\n    /// Constructs an empty HashMap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// assert(hashmap.is_empty());\n    /// ```\n    fn default() -> Self {\n        // docs:end:default\n        let _build_hasher = B::default();\n        let map: HashMap<K, V, N, B> = HashMap::with_hasher(_build_hasher);\n        map\n    }\n}\n",
      "path": "std/collections/map.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "42": {
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "50": {
      "source": "mod utils;\n\nuse std::collections::map::HashMap;\nuse std::hash::BuildHasherDefault;\nuse poseidon::poseidon2::Poseidon2Hasher;\n\nuse utils::cut;\n\ntype K = Field;\ntype V = Field;\n\n// It is more convenient and readable to use structs as input.\nstruct Entry {\n    key: Field,\n    value: Field,\n}\n\nglobal HASHMAP_CAP: u32 = 8;\nglobal HASHMAP_LEN: u32 = 6;\n\nglobal FIELD_CMP: fn(Field, Field) -> bool = |a: Field, b: Field| a.lt(b);\n\nglobal K_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal V_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal KV_CMP: fn((K, V), (K, V)) -> bool = |a: (K, V), b: (K, V)| a.0.lt(b.0);\n\nglobal ALLOCATE_HASHMAP: fn() -> HashMap<K, V, HASHMAP_CAP, BuildHasherDefault<Poseidon2Hasher>> =\n    || -> HashMap<K, V, HASHMAP_CAP, BuildHasherDefault<Poseidon2Hasher>> HashMap::default();\n\nfn main(input: [Entry; HASHMAP_LEN]) {\n    test_sequential(input[0].key, input[0].value);\n    test_multiple_equal_insert(input[1].key, input[1].value);\n    test_value_override(input[2].key, input[2].value, input[3].value);\n    test_insert_and_methods(input);\n    test_hashmaps_equality(input);\n    test_retain();\n    test_iterators();\n    test_mut_iterators();\n\n    doc_tests();\n}\n\n// Insert, get, remove.\nfn test_sequential(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    hashmap.insert(key, value);\n    assert(hashmap.len() == 1, \"HashMap after one insert should have a length of 1 element.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n\n    hashmap.remove(key);\n    assert(\n        hashmap.is_empty(),\n        \"HashMap after one insert and corresponding removal should be empty.\",\n    );\n    let got = hashmap.get(key);\n    assert(got.is_none(), \"Value has been removed, but is still available (not none).\");\n}\n\n// Insert same pair several times.\nfn test_multiple_equal_insert(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    for _ in 0..HASHMAP_LEN {\n        hashmap.insert(key, value);\n    }\n\n    let len = hashmap.len();\n    assert(len == 1, f\"HashMap length must be 1, got {len}.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n}\n\n// Override value for existing pair.\nfn test_value_override(key: K, value: V, new_value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New hashmap should be empty.\");\n\n    hashmap.insert(key, value);\n    hashmap.insert(key, new_value);\n    assert(hashmap.len() == 1, \"HashMap length is invalid.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(got == new_value, f\"Expected {new_value}, but got {got}.\");\n}\n\n// Insert several distinct pairs and test auxiliary methods.\nfn test_insert_and_methods(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    for entry in input {\n        hashmap.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap.len() == HASHMAP_LEN, \"hashmap.len() does not match input length.\");\n\n    for entry in input {\n        let entry_key = entry.key;\n        assert(hashmap.contains_key(entry.key), f\"Not found inserted key {entry_key}.\");\n    }\n\n    hashmap.clear();\n    assert(hashmap.is_empty(), \"HashMap after clear() should be empty.\");\n}\n\n// Insert several pairs and test retaining.\nfn test_retain() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    let (key, value) = (5, 11);\n    hashmap.insert(key, value);\n    let (key, value) = (2, 13);\n    hashmap.insert(key, value);\n    let (key, value) = (11, 5);\n    hashmap.insert(key, value);\n\n    let predicate = |key: K, value: V| -> bool { key * value == 55 };\n    hashmap.retain(predicate);\n\n    assert(hashmap.len() == 2, \"HashMap should have retained 2 elements.\");\n    assert(\n        hashmap.get(2).is_none(),\n        \"Pair should have been removed, since it does not match predicate.\",\n    );\n}\n\n// Equality trait check.\nfn test_hashmaps_equality(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap_1 = ALLOCATE_HASHMAP();\n    let mut hashmap_2 = ALLOCATE_HASHMAP();\n\n    for entry in input {\n        hashmap_1.insert(entry.key, entry.value);\n        hashmap_2.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap_1 == hashmap_2, \"HashMaps should be equal.\");\n\n    hashmap_2.remove(input[0].key);\n\n    assert(hashmap_1 != hashmap_2, \"HashMaps should not be equal.\");\n}\n\n// Test entries, keys, values.\nfn test_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let keys: [K; 3] = cut(hashmap.keys()).sort_via(K_CMP);\n    let values: [V; 3] = cut(hashmap.values()).sort_via(V_CMP);\n    let entries: [(K, V); 3] = cut(hashmap.entries()).sort_via(KV_CMP);\n\n    assert(keys == [2, 5, 11], \"Got incorrect iteration of keys.\");\n    assert(values == [3, 7, 13], \"Got incorrect iteration of values.\");\n    assert(entries == [(2, 3), (5, 7), (11, 13)], \"Got incorrect iteration of entries.\");\n}\n\n// Test mutable iteration over keys, values and entries.\nfn test_mut_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let f = |k: K| -> K { k * 3 };\n    hashmap.iter_keys_mut(f);\n\n    let f = |v: V| -> V { v * 5 };\n    hashmap.iter_values_mut(f);\n\n    let keys: [K; 3] = cut(hashmap.keys()).sort_via(K_CMP);\n    let values: [V; 3] = cut(hashmap.values()).sort_via(V_CMP);\n\n    assert(keys == [6, 15, 33], f\"Got incorrect iteration of keys: {keys}\");\n    assert(values == [15, 35, 65], \"Got incorrect iteration of values.\");\n\n    let f = |k: K, v: V| -> (K, V) { (k * 2, v * 2) };\n    hashmap.iter_mut(f);\n\n    let entries: [(K, V); 3] = cut(hashmap.entries()).sort_via(KV_CMP);\n\n    assert(entries == [(12, 30), (30, 70), (66, 130)], \"Got incorrect iteration of entries.\");\n}\n\n// docs:start:type_alias\ntype MyMap = HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>>;\n// docs:end:type_alias\n\n/// Tests examples from the stdlib hashmap documentation\nfn doc_tests() {\n    // docs:start:default_example\n    let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    assert(hashmap.is_empty());\n    // docs:end:default_example\n    // docs:start:with_hasher_example\n    let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> =\n        HashMap::with_hasher(my_hasher);\n    assert(hashmap.is_empty());\n    // docs:end:with_hasher_example\n    // docs:start:insert_example\n    let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    map.insert(12, 42);\n    assert(map.len() == 1);\n    // docs:end:insert_example\n    get_example(map);\n\n    // docs:start:remove_example\n    map.remove(12);\n    assert(map.is_empty());\n\n    // If a key was not present in the map, remove does nothing\n    map.remove(12);\n    assert(map.is_empty());\n    // docs:end:remove_example\n    // docs:start:is_empty_example\n    assert(map.is_empty());\n\n    map.insert(1, 2);\n    assert(!map.is_empty());\n\n    map.remove(1);\n    assert(map.is_empty());\n    // docs:end:is_empty_example\n    // docs:start:len_example\n    // This is equivalent to checking map.is_empty()\n    assert(map.len() == 0);\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n    map.insert(5, 6);\n    assert(map.len() == 3);\n\n    // 3 was already present as a key in the hash map, so the length is unchanged\n    map.insert(3, 7);\n    assert(map.len() == 3);\n\n    map.remove(1);\n    assert(map.len() == 2);\n    // docs:end:len_example\n    // docs:start:capacity_example\n    let empty_map: HashMap<Field, Field, 42, BuildHasherDefault<Poseidon2Hasher>> =\n        HashMap::default();\n    assert(empty_map.len() == 0);\n    assert(empty_map.capacity() == 42);\n    // docs:end:capacity_example\n    // docs:start:clear_example\n    assert(!map.is_empty());\n    map.clear();\n    assert(map.is_empty());\n    // docs:end:clear_example\n    // docs:start:contains_key_example\n    if map.contains_key(7) {\n        let value = map.get(7);\n        assert(value.is_some());\n    } else {\n        println(\"No value for key 7!\");\n    }\n    // docs:end:contains_key_example\n    entries_examples(map);\n    iter_examples(map);\n\n    // docs:start:retain_example\n    map.retain(|k, v| (k != 0) & (v != 0));\n    // docs:end:retain_example\n    // docs:start:eq_example\n    let mut map1: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    let mut map2: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n\n    map1.insert(1, 2);\n    map1.insert(3, 4);\n\n    map2.insert(3, 4);\n    map2.insert(1, 2);\n\n    assert(map1 == map2);\n    // docs:end:eq_example\n}\n\n// docs:start:get_example\nfn get_example(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    let x = map.get(12);\n\n    if x.is_some() {\n        assert(x.unwrap() == 42);\n    }\n}\n// docs:end:get_example\n\nfn entries_examples(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:entries_example\n    let entries = map.entries();\n\n    // The length of a hashmap may not be compile-time known, so we\n    // need to loop over its capacity instead\n    for i in 0..map.capacity() {\n        if i < entries.len() {\n            let (key, value) = entries.get(i);\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:entries_example\n    // docs:start:keys_example\n    let keys = map.keys();\n\n    for i in 0..keys.max_len() {\n        if i < keys.len() {\n            let key = keys.get_unchecked(i);\n            let value = map.get(key).unwrap_unchecked();\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:keys_example\n    // docs:start:values_example\n    let values = map.values();\n\n    for i in 0..values.max_len() {\n        if i < values.len() {\n            let value = values.get_unchecked(i);\n            println(f\"Found value {value}\");\n        }\n    }\n    // docs:end:values_example\n}\n\nfn iter_examples(mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:iter_mut_example\n    // Add 1 to each key in the map, and double the value associated with that key.\n    map.iter_mut(|k, v| (k + 1, v * 2));\n    // docs:end:iter_mut_example\n    // docs:start:iter_keys_mut_example\n    // Double each key, leaving the value associated with that key untouched\n    map.iter_keys_mut(|k| k * 2);\n    // docs:end:iter_keys_mut_example\n    // docs:start:iter_values_mut_example\n    // Halve each value\n    map.iter_values_mut(|v| v / 2);\n    // docs:end:iter_values_mut_example\n}\n",
      "path": ""
    },
    "51": {
      "source": "// Compile-time: cuts the M first elements from the BoundedVec<T, N>.\npub(crate) fn cut<T, let N: u32, let M: u32>(input: BoundedVec<T, N>) -> [T; M] {\n    assert(M < N, \"M should be less than N.\");\n\n    let mut new = BoundedVec::new();\n    for i in 0..M {\n        new.push(input.get(i));\n    }\n    new.storage()\n}\n",
      "path": ""
    },
    "58": {
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
